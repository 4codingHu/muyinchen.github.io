<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="只记空山，只念新雨">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      tomcat从启动到接轨Servlet二三事 | 一叶知秋
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>一叶知秋</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>tomcat从启动到接轨Servlet二三事</h2>
  <p class="post-date">2018-12-26</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="tomcat从启动到接轨Servlet二三事"><a href="#tomcat从启动到接轨Servlet二三事" class="headerlink" title="tomcat从启动到接轨Servlet二三事"></a>tomcat从启动到接轨Servlet二三事</h1><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>也是因为之前自己的不谨慎，在写<code>Java编程方法论-Reactor与Webflux</code>的时候，因觉得tomcat关于connector部分已经有不错的博文了，草草参考了下，并没有对源码进行深入分析，导致自己在录制分享视频的时候，发现自己文章内容展现的和源码并不一致，又通过搜索引擎搜索了一些中文博客的文章，并不尽如人意，索性，自己的就通过最新的源码来重新梳理一下关于tomcat connector部分内容，也是给自己一个警醒，凡事务必仔细仔细再仔细！<br>参考源码地址: <a href="https://github.com/apache/tomcat" target="_blank" rel="noopener">https://github.com/apache/tomcat</a></p>
<p>关于<code>Java编程方法论-Reactor与Webflux</code>的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:</p>
<p>Rxjava源码解读与分享：<a href="https://www.bilibili.com/video/av34537840" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840</a></p>
<p>Reactor源码解读与分享：<a href="https://www.bilibili.com/video/av35326911" target="_blank" rel="noopener">https://www.bilibili.com/video/av35326911</a></p>
<a id="more"></a>
<h2 id="Tomcat的启动过程详解"><a href="#Tomcat的启动过程详解" class="headerlink" title="Tomcat的启动过程详解"></a>Tomcat的启动过程详解</h2><p>###　启动与结束Tomcat基本操作<br>在Linux系统下，启动和关闭Tomcat使用命令操作。</p>
<p>进入Tomcat下的bin目录:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /java/tomcat/bin</span><br></pre></td></tr></table></figure></p>
<p>启动Tomcat命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./startup.sh</span><br></pre></td></tr></table></figure>
<p>停止Tomcat服务命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure>
<p>执行tomcat 的<code>./shutdown.sh</code>后，虽然tomcat服务不能正常访问了，但是<code>ps -ef | grep tomcat</code> 后，发现<code>tomcat</code>对应的<code>java</code>进程未随web容器关闭而销毁，进而存在僵尸<code>java</code>进程。网上看了下导致僵尸进程的原因可能是有非守护线程（即User Thread）存在，jvm不会退出（当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出）。通过一下命令查看Tomcat进程是否结束：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep tomcat</span><br></pre></td></tr></table></figure>
<p>如果存在用户线程，给kill掉就好了即使用<code>kill -9 pid</code></p>
<h3 id="启动过程Bootstrap详解"><a href="#启动过程Bootstrap详解" class="headerlink" title="启动过程Bootstrap详解"></a>启动过程Bootstrap详解</h3><p>我们接着从<code>startup.sh</code>这个shell脚本中可以发现，其最终调用了<code>catalina.sh start</code>，于是，我们找到<code>catalina.sh</code>里，在<code>elif [ &quot;$1&quot; = &quot;start&quot; ] ;</code>处，我们往下走，可以发现，其调用了<code>org.apache.catalina.startup.Bootstrap.java</code>这个类下的<code>start()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.apache.catalina.startup.Bootstrap</span></span><br><span class="line"><span class="comment">* Start the Catalina daemon.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception Fatal start error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( catalinaDaemon==<span class="keyword">null</span> ) init();</span><br><span class="line"></span><br><span class="line">    Method method = catalinaDaemon.getClass().getMethod(<span class="string">"start"</span>, (Class [] )<span class="keyword">null</span>);</span><br><span class="line">    method.invoke(catalinaDaemon, (Object [])<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，在服务器第一次启动的时候，会调用其<code>init()</code>，其主要用于创建<code>org.apache.catalina.startup.Catalina.java</code>的类实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.apache.catalina.startup.Bootstrap</span></span><br><span class="line"><span class="comment">* Initialize daemon.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception Fatal initialization error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    initClassLoaders();</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line"></span><br><span class="line">    SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load our startup class and call its process() method</span></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">"Loading startup class"</span>);</span><br><span class="line">    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">"org.apache.catalina.startup.Catalina"</span>);</span><br><span class="line">    Object startupInstance = startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the shared extensions class loader</span></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">"Setting startup class properties"</span>);</span><br><span class="line">    String methodName = <span class="string">"setParentClassLoader"</span>;</span><br><span class="line">    Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">    paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">"java.lang.ClassLoader"</span>);</span><br><span class="line">    Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">    paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">    Method method =</span><br><span class="line">        startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">    method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">    catalinaDaemon = startupInstance;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="启动过程Catalina详解"><a href="#启动过程Catalina详解" class="headerlink" title="启动过程Catalina详解"></a>启动过程Catalina详解</h3><h4 id="Catalina中start解读"><a href="#Catalina中start解读" class="headerlink" title="Catalina中start解读"></a>Catalina中start解读</h4><p>接着，在Bootstrap的start()方法中会调用Catalina实例的start方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.apache.catalina.startup.Catalina</span></span><br><span class="line"><span class="comment">* Start a new server instance.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">"catalina.noServer"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">"catalina.serverStartFail"</span>), e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getServer().destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e1) &#123;</span><br><span class="line">            log.debug(<span class="string">"destroy() failed for failed Server "</span>, e1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(sm.getString(<span class="string">"catalina.startup"</span>, Long.valueOf((t2 - t1) / <span class="number">1000000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register shutdown hook</span></span><br><span class="line">    <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">            shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If JULI is being used, disable JULI's shutdown hook since</span></span><br><span class="line">        <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">        <span class="comment">// if JULI's hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">        LogManager logManager = LogManager.getLogManager();</span><br><span class="line">        <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">            ((ClassLoaderLogManager) logManager).setUseShutdownHook(</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (await) &#123;</span><br><span class="line">        await();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里面，我们主要关心<code>load()</code>，<code>getServer().start()</code>，对于后者，在它的前后我们看到有启动时间的计算，这也是平时我们在启动tomcat过程中所看到的日志打印输出所在，后面的我这里就不提了。</p>
<h4 id="Catalina中load-解读"><a href="#Catalina中load-解读" class="headerlink" title="Catalina中load()解读"></a>Catalina中load()解读</h4><p>首先我们来看load()，这里，其会通过<code>createStartDigester()</code>创建并配置我们将用来启动的Digester，然后获取我们所配置的ServerXml文件，依次对里面属性进行配置，最后调用<code>getServer().init()</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.apache.catalina.startup.Catalina</span></span><br><span class="line"><span class="comment">* Start a new server instance.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    initDirs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before digester - it may be needed</span></span><br><span class="line">    initNaming();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set configuration source</span></span><br><span class="line">    ConfigFileLoader.setSource(<span class="keyword">new</span> CatalinaBaseConfigurationSource(Bootstrap.getCatalinaBaseFile(), getConfigFile()));</span><br><span class="line">    File file = configFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and execute our Digester</span></span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (ConfigurationSource.Resource resource = ConfigFileLoader.getSource().getServerXml()) &#123;</span><br><span class="line">        InputStream inputStream = resource.getInputStream();</span><br><span class="line">        InputSource inputSource = <span class="keyword">new</span> InputSource(resource.getURI().toURL().toString());</span><br><span class="line">        inputSource.setByteStream(inputStream);</span><br><span class="line">        digester.push(<span class="keyword">this</span>);</span><br><span class="line">        digester.parse(inputSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span>  (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(sm.getString(<span class="string">"catalina.configFail"</span>, getConfigFile() + <span class="string">"] or [server-embed.xml"</span>), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(sm.getString(<span class="string">"catalina.configFail"</span>, file.getAbsolutePath()), e);</span><br><span class="line">            <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">                log.warn(sm.getString(<span class="string">"catalina.incorrectPermissions"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stream redirection</span></span><br><span class="line">    initStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"catalina.initError"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(sm.getString(<span class="string">"catalina.init"</span>, Long.valueOf((t2 - t1) / <span class="number">1000000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，这个server从哪里来，我们从<code>digester.addObjectCreate(&quot;Server&quot;, &quot;org.apache.catalina.core.StandardServer&quot;, &quot;className&quot;);</code>中可以知道，其使用了这个类的实例，我们再回到<code>digester.push(this); digester.parse(inputSource);</code>这两句代码上来，可知，未开始解析时先调用Digester.push(this)，此时栈顶元素是Catalina，这个用来为catalina设置server，这里，要对<code>digester</code>的解析来涉及下:</p>
<p>如解析到<code>&lt;Server&gt;</code>时就会创建<code>StandardServer</code>类的实例并反射调用<code>Digester</code>的<code>stack</code>栈顶对象的<code>setter</code>方法(调用的方法通过传入的<code>name</code>值确定)。<br><code>digester</code>中涉及的<code>IntrospectionUtils.setProperty(top, name, value)</code>方法，即<code>top</code>为栈顶对象，<code>name</code>为这个栈顶对象要设置的属性名，<code>value</code>为要设置的属性值。<br>刚开始时栈顶元素是<code>Catalina</code>，即调用<code>Catalina.setServer(Server object)</code>方法设置<code>Server</code>为后面调用<code>Server.start()</code>做准备，然后将<code>StandardServer</code>对象实例放入<code>Digester</code>的<code>stack</code>对象栈中。</p>
<h5 id="getServer-init"><a href="#getServer-init" class="headerlink" title="getServer().init()"></a>getServer().init()</h5><p>接下来，我们来看<code>getServer().init()</code>，由上知，我们去找<code>org.apache.catalina.core.StandardServer.java</code>这个类，其继承<code>LifecycleMBeanBase</code>并实现了<code>Server</code>，通过<code>LifecycleMBeanBase</code>此类，说明这个<code>StandardServer</code>管理的生命周期，即通过<code>LifecycleMBeanBase</code>父类<code>LifecycleBase</code>实现的<code>init()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.util.LifecycleBase.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        initInternal();</span><br><span class="line">        setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleSubClassException(t, <span class="string">"lifecycleBase.initFail"</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于是，我们关注 <code>initInternal()</code>在<code>StandardServer</code>中的实现，代码过多，这里就把过程讲下:<br>1、调用父类org.apache.catalina.util.LifecycleMBeanBase#initInternal方法，注册MBean</p>
<p>2、注册本类的其它属性的MBean</p>
<p>3、NamingResources初始化 : globalNamingResources.init();</p>
<p>4、从common ClassLoader开始往上查看，直到SystemClassLoader，遍历各个classLoader对应的查看路径，找到jar结尾的文件，读取Manifest信息，加入到ExtensionValidator#containerManifestResources属性中。</p>
<p>5、初始化service，默认实现是StandardService。</p>
<p>　　 i) 调用super.initInternal()方法</p>
<p>   ii) container初始化，这里container实例是StandardEngine。<br>​<br>   iii) Executor初始化<br>​<br>   iv)Connector初始化:<br>​<br>​      a）org.apache.catalina.connector.Connector   Connector[HTTP/1.1-8080]<br>​<br>​      b) org.apache.catalina.connector.Connector   Connector[AJP/1.3-8009]</p>
<h4 id="Catalina中start里的getServer-start-解读"><a href="#Catalina中start里的getServer-start-解读" class="headerlink" title="Catalina中start里的getServer().start()解读"></a>Catalina中start里的getServer().start()解读</h4><p>这里，我们可以看到<code>StandardServer</code>的父类<code>org.apache.catalina.util.LifecycleBase.java</code>的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||</span><br><span class="line">            LifecycleState.STARTED.equals(state)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> LifecycleException();</span><br><span class="line">            log.debug(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">        stop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;</span><br><span class="line">            !state.equals(LifecycleState.STOPPED)) &#123;</span><br><span class="line">        invalidTransition(Lifecycle.BEFORE_START_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setStateInternal(LifecycleState.STARTING_PREP, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        startInternal();</span><br><span class="line">        <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">            <span class="comment">// This is a 'controlled' failure. The component put itself into the</span></span><br><span class="line">            <span class="comment">// FAILED state so call stop() to complete the clean-up.</span></span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.STARTING)) &#123;</span><br><span class="line">            <span class="comment">// Shouldn't be necessary but acts as a check that sub-classes are</span></span><br><span class="line">            <span class="comment">// doing what they are supposed to.</span></span><br><span class="line">            invalidTransition(Lifecycle.AFTER_START_EVENT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setStateInternal(LifecycleState.STARTED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// This is an 'uncontrolled' failure so put the component into the</span></span><br><span class="line">        <span class="comment">// FAILED state and throw an exception.</span></span><br><span class="line">        handleSubClassException(t, <span class="string">"lifecycleBase.startFail"</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<code>StandardServer</code>，我们关注的是其对于<code>startInternal();</code>的实现，源码不贴了，具体过程如下:<br>1、触发CONFIGURE_START_EVENT事件。</p>
<p>2、设置本对象状态为STARTING</p>
<p>3、NameingResource启动:globalNamingResources.start();<br>4、StandardService启动。</p>
<p>　　 i)  设置状态为STARTING</p>
<p>   ii)  container启动，即StandardEngine启动<br>​<br>   iii)  Executor 启动<br>​<br>   iv) Connector启动:<br>​<br>​       a）org.apache.catalina.connector.Connector   Connector[HTTP/1.1-8080]<br>​<br>​       b) org.apache.catalina.connector.Connector   Connector[AJP/1.3-8009]</p>
<p>终于，我们探究到了我要讲的主角<code>Connector</code>。</p>
<h2 id="Connector解读"><a href="#Connector解读" class="headerlink" title="Connector解读"></a>Connector解读</h2><h3 id="Connector构造器"><a href="#Connector构造器" class="headerlink" title="Connector构造器"></a>Connector构造器</h3><p>我们由<code>apache-tomcat-9.0.14\conf</code>目录(此处请自行下载相应版本的tomcat)下的server.xml中的<code>Connector</code>配置可知，其默认8080端口的配置协议为<code>HTTP/1.1</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>知道了这些，我们去看它的代码中的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> aprConnector = AprLifecycleListener.isAprAvailable() &amp;&amp;</span><br><span class="line">            AprLifecycleListener.getUseAprConnector();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"HTTP/1.1"</span>.equals(protocol) || protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aprConnector) &#123;</span><br><span class="line">            protocolHandlerClassName = <span class="string">"org.apache.coyote.http11.Http11AprProtocol"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            protocolHandlerClassName = <span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"AJP/1.3"</span>.equals(protocol)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aprConnector) &#123;</span><br><span class="line">            protocolHandlerClassName = <span class="string">"org.apache.coyote.ajp.AjpAprProtocol"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            protocolHandlerClassName = <span class="string">"org.apache.coyote.ajp.AjpNioProtocol"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        protocolHandlerClassName = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate protocol handler</span></span><br><span class="line">    ProtocolHandler p = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(protocolHandlerClassName);</span><br><span class="line">        p = (ProtocolHandler) clazz.getConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(sm.getString(</span><br><span class="line">                <span class="string">"coyoteConnector.protocolHandlerInstantiationFailed"</span>), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.protocolHandler = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default for Connector depends on this system property</span></span><br><span class="line">    setThrowOnFailure(Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于tomcat8.5以上，其默认就是<code>Http11NioProtocol</code>协议，这里，我们给其设定了<code>HTTP/1.1</code>，但根据上面的if语句的判断，是相等的，也就是最后还是选择的<code>Http11NioProtocol</code>。</p>
<h3 id="Connector初始化与启动"><a href="#Connector初始化与启动" class="headerlink" title="Connector初始化与启动"></a>Connector初始化与启动</h3><p>同样，由上一节可知，我们会涉及到Connector初始化，也就是其也会继承<code>LifecycleMBeanBase</code>，那么，我们来看其相关<code>initInternal()</code>实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"coyoteConnector.protocolHandlerInstantiationFailed"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize adapter</span></span><br><span class="line">    adapter = <span class="keyword">new</span> CoyoteAdapter(<span class="keyword">this</span>);</span><br><span class="line">    protocolHandler.setAdapter(adapter);</span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        protocolHandler.setUtilityExecutor(service.getServer().getUtilityExecutor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == parseBodyMethodsSet) &#123;</span><br><span class="line">        setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">"coyoteConnector.protocolHandlerNoApr"</span>,</span><br><span class="line">                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable() &amp;&amp; AprLifecycleListener.getUseOpenSSL() &amp;&amp;</span><br><span class="line">            protocolHandler <span class="keyword">instanceof</span> AbstractHttp11JsseProtocol) &#123;</span><br><span class="line">        AbstractHttp11JsseProtocol&lt;?&gt; jsseProtocolHandler =</span><br><span class="line">                (AbstractHttp11JsseProtocol&lt;?&gt;) protocolHandler;</span><br><span class="line">        <span class="keyword">if</span> (jsseProtocolHandler.isSSLEnabled() &amp;&amp;</span><br><span class="line">                jsseProtocolHandler.getSslImplementationName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// OpenSSL is compatible with the JSSE configuration, so use it if APR is available</span></span><br><span class="line">            jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation.class.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        protocolHandler.init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"coyoteConnector.protocolHandlerInitializationFailed"</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里涉及的过程如下：<br>1、注册MBean</p>
<p>2、CoyoteAdapter实例化，CoyoteAdapter是请求的入口。当有请求时，CoyoteAdapter对状态进行了处理，结尾处对请求进行回收，中间过程交由pipeline来处理。</p>
<p>3、protocolHandler 初始化（org.apache.coyote.http11.Http11Protocol）</p>
<p>  在这一步中，完成了endpoint的初始化</p>
<p>关于启动就不说了，其设定本对象状态为STARTING，同时调用<code>protocolHandler.start();</code>，接下来，就要进入我们的核心节奏了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate settings before starting</span></span><br><span class="line">    <span class="keyword">if</span> (getPortWithOffset() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(</span><br><span class="line">                <span class="string">"coyoteConnector.invalidPort"</span>, Integer.valueOf(getPortWithOffset())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        protocolHandler.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"coyoteConnector.protocolHandlerStartFailed"</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Protocol的相关解读"><a href="#Protocol的相关解读" class="headerlink" title="Protocol的相关解读"></a>Protocol的相关解读</h3><p>这里，我们直接从其抽象实现<code>org.apache.coyote.AbstractProtocol.java</code>来看，其也是遵循生命周期的，所以其也要继承<code>LifecycleMBeanBase</code>并实现自己的<code>init()</code>与<code>start()</code>等生命周期方法，其内部都是由相应的自实现的<code>endpoint</code>来执行具体逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.coyote.AbstractProtocol.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">        getLog().info(sm.getString(<span class="string">"abstractProtocolHandler.init"</span>, getName()));</span><br><span class="line">        logPortOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oname == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Component not pre-registered so register it</span></span><br><span class="line">        oname = createObjectName();</span><br><span class="line">        <span class="keyword">if</span> (oname != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rgOname = <span class="keyword">new</span> ObjectName(domain + <span class="string">":type=GlobalRequestProcessor,name="</span> + getName());</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(</span><br><span class="line">                getHandler().getGlobal(), rgOname, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String endpointName = getName();</span><br><span class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line"></span><br><span class="line">    endpoint.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">        getLog().info(sm.getString(<span class="string">"abstractProtocolHandler.start"</span>, getName()));</span><br><span class="line">        logPortOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    endpoint.start();</span><br><span class="line">    monitorFuture = getUtilityExecutor().scheduleWithFixedDelay(</span><br><span class="line">            <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isPaused()) &#123;</span><br><span class="line">                        startAsyncTimeout();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拿<code>org.apache.coyote.http11.Http11NioProtocol</code>这个类来讲，其接收的是<code>NioEndpoint</code>来进行构造器的实现，其内部的方法的具体实现也经由此<code>NioEndpoint</code>来实现其逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Http11NioProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractHttp11JsseProtocol</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Http11NioProtocol.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Http11NioProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> NioEndpoint());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Log <span class="title">getLog</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> log; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------- Pool setup --------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPollerThreadCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        ((NioEndpoint)getEndpoint()).setPollerThreadCount(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPollerThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((NioEndpoint)getEndpoint()).getPollerThreadCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSelectorTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        ((NioEndpoint)getEndpoint()).setSelectorTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSelectorTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((NioEndpoint)getEndpoint()).getSelectorTimeout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPollerThreadPriority</span><span class="params">(<span class="keyword">int</span> threadPriority)</span> </span>&#123;</span><br><span class="line">        ((NioEndpoint)getEndpoint()).setPollerThreadPriority(threadPriority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPollerThreadPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ((NioEndpoint)getEndpoint()).getPollerThreadPriority();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------------------------------------------- JMX related methods</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getNamePrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSSLEnabled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"https-"</span> + getSslImplementationShortName()+ <span class="string">"-nio"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"http-nio"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Endpoint相关解读"><a href="#Endpoint相关解读" class="headerlink" title="Endpoint相关解读"></a>Endpoint相关解读</h3><p>这里，<code>EndPoint</code>用于处理具体连接和传输数据，即用来实现网络连接和控制，它是服务器对外<code>I/O</code>操作的接入点。主要任务是管理对外的<code>socket</code>连接，同时将建立好的<code>socket</code>连接交到合适的工作线程中去。<br>里面两个主要的属性类是<code>Acceptor</code>和<code>Poller</code>、<code>SocketProcessor</code>。<br>我们以<code>NioEndpoint</code>为例，其内部请求处理具体的流程如下:</p>
<p><img src="https://github.com/muyinchen/woker/blob/master/mypics/NioEndpoint%20%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E5%A6%82%E5%9B%BE.png?raw=true" alt=""></p>
<p>结合上一节最后，我们主要还是关注其对于<code>Protocol</code>有关生命周期方法的具体实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.tomcat.util.net.AbstractEndpoint.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">        bindWithCleanup();</span><br><span class="line">        bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Register endpoint (as ThreadPool - historical name)</span></span><br><span class="line">        oname = <span class="keyword">new</span> ObjectName(domain + <span class="string">":type=ThreadPool,name=\""</span> + getName() + <span class="string">"\""</span>);</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        ObjectName socketPropertiesOname = <span class="keyword">new</span> ObjectName(domain +</span><br><span class="line">                <span class="string">":type=ThreadPool,name=\""</span> + getName() + <span class="string">"\",subType=SocketProperties"</span>);</span><br><span class="line">        socketProperties.setObjectName(socketPropertiesOname);</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(socketProperties, socketPropertiesOname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (SSLHostConfig sslHostConfig : findSslHostConfigs()) &#123;</span><br><span class="line">            registerJmx(sslHostConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindState == BindState.UNBOUND) &#123;</span><br><span class="line">        bindWithCleanup();</span><br><span class="line">        bindState = BindState.BOUND_ON_START;</span><br><span class="line">    &#125;</span><br><span class="line">    startInternal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//org.apache.tomcat.util.net.AbstractEndpoint.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindWithCleanup</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bind();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Ensure open sockets etc. are cleaned up if something goes</span></span><br><span class="line">        <span class="comment">// wrong during bind</span></span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        unbind();</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个方法主要调用<code>bind</code>(此处可以查阅<code>bindWithCleanup()</code>的具体实现) 和<code>startlntemal</code> 方法，它们是模板方法，可以自行根据需求实现，这里，我们参考<code>NioEndpoint</code> 中的实现， <code>bind</code> 方法代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.tomcat.util.net.NioEndpoint.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    initServerSocket();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize thread count defaults for acceptor, poller</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> Doesn't seem to work that well with multiple accept threads</span></span><br><span class="line">        acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//minimum one poller thread</span></span><br><span class="line">        pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的bind 方法中首先初始化了<code>ServerSocket</code>(这个东西我们在jdk网络编程里都接触过，就不多说了，这里是封装了一个工具类，看下面实现)，然后检查了代表<code>Acceptor</code> 和<code>Poller</code> 初始化的线程数量的<code>acceptorThreadCount</code>属性和<code>pollerThreadCount</code> 属性，它们的值至少为1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Separated out to make it easier for folks that extend NioEndpoint to</span></span><br><span class="line"><span class="comment">// implement custom [server]sockets</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initServerSocket</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">        serverSock = ServerSocketChannel.open();</span><br><span class="line">        socketProperties.setProperties(serverSock.socket());</span><br><span class="line">        InetSocketAddress addr = <span class="keyword">new</span> InetSocketAddress(getAddress(), getPortWithOffset());</span><br><span class="line">        serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Retrieve the channel provided by the OS</span></span><br><span class="line">        Channel ic = System.inheritedChannel();</span><br><span class="line">        <span class="keyword">if</span> (ic <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">            serverSock = (ServerSocketChannel) ic;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (serverSock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">"endpoint.init.bind.inherited"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>Acceptor</code> 用于接收请求，将接收到请求交给<code>Poller</code> 处理，它们都是启动线程来处理的。另外还进行了初始化<code>SSL</code> 等内容。<code>NioEndpoint</code> 的<code>startInternal</code> 方法代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The socket pollers.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Poller[] pollers = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Start the NIO endpoint, creating acceptor, poller threads.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">        running = <span class="keyword">true</span>;</span><br><span class="line">        paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getProcessorCache());</span><br><span class="line">        eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                        socketProperties.getEventCache());</span><br><span class="line">        nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create worker collection</span></span><br><span class="line">        <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start poller threads</span></span><br><span class="line">        pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">            Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">"-ClientPoller-"</span>+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里首先初始化了一些属性，初始化的属性中的<code>processorCache</code> 是<code>SynchronizedStack&lt;SocketProcessor&gt;</code>类型， <code>SocketProcessor</code> 是<code>NioEndpoint</code> 的一个内部类， <code>Poller</code> 接收到请求后就会交给它处理， <code>SocketProcessor</code> 又会将请求传递到<code>Handler</code>。<br>然后启动了<code>Poller</code> 和<code>Acceptor</code> 来处理请求，这里我们要注意的的是，<code>pollers</code>是一个数组，其管理了一堆<code>Runnable</code>，由前面可知，假如我们并没有对其进行设定，那就是1，也就是说，其默认情况下只是一个单线程。这个线程创建出来后就将其设定为守护线程，直到tomcat容器结束，其自然也会跟着结束。<br>这里，我们想要对其进行配置的话，可以在<code>server.xml</code>中进行相应设定:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxHeaderCount</span>=<span class="string">"64"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxParameterCount</span>=<span class="string">"64"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxHttpHeaderSize</span>=<span class="string">"8192"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">useBodyEncodingForURI</span>=<span class="string">"false"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxThreads</span>=<span class="string">"128"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">minSpareThreads</span>=<span class="string">"12"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">acceptCount</span>=<span class="string">"1024"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">connectionLinger</span>=<span class="string">"-1"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">keepAliveTimeout</span>=<span class="string">"60"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxKeepAliveRequests</span>=<span class="string">"32"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxConnections</span>=<span class="string">"10000"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">acceptorThreadCount</span>=<span class="string">"1"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">pollerThreadCount</span>=<span class="string">"2"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">selectorTimeout</span>=<span class="string">"1000"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">useSendfile</span>=<span class="string">"true"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">selectorPool.maxSelectors</span>=<span class="string">"128"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>启动<code>Acceptor</code>的<code>startAcceptorThreads</code> 方法在 <code>AbstractEndpoint</code> 中，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">    acceptors = <span class="keyword">new</span> ArrayList&lt;&gt;(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Acceptor&lt;U&gt; acceptor = <span class="keyword">new</span> Acceptor&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">        String threadName = getName() + <span class="string">"-Acceptor-"</span> + i;</span><br><span class="line">        acceptor.setThreadName(threadName);</span><br><span class="line">        acceptors.add(acceptor);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(acceptor, threadName);</span><br><span class="line">        t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">        t.setDaemon(getDaemon());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>getAcceptorThreadCount</code> 方法就是获取的init 方法中处理过的acceptorThreadCount属性，获取到后就会启动相应数量的Acceptor 线程来接收请求。默认同样是1，其创建线程的方式和Poller一致，就不多说了。</p>
<p>这里，我们再来看下webapps/docs/config/http.xml的文档说明:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">"acceptorThreadCount"</span> <span class="attr">required</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>The number of threads to be used to accept connections. Increase this</span><br><span class="line">    value on a multi CPU machine, although you would never really need more</span><br><span class="line">    than <span class="tag">&lt;<span class="name">code</span>&gt;</span>2<span class="tag">&lt;/<span class="name">code</span>&gt;</span>. Also, with a lot of non keep alive connections, you</span><br><span class="line">    might want to increase this value as well. Default value is</span><br><span class="line">    <span class="tag">&lt;<span class="name">code</span>&gt;</span>1<span class="tag">&lt;/<span class="name">code</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">attribute</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">"pollerThreadCount"</span> <span class="attr">required</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>(int)The number of threads to be used to run for the polling events.</span><br><span class="line">    Default value is <span class="tag">&lt;<span class="name">code</span>&gt;</span>1<span class="tag">&lt;/<span class="name">code</span>&gt;</span> per processor but not more than 2.<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    When accepting a socket, the operating system holds a global lock. So the benefit of</span><br><span class="line">    going above 2 threads diminishes rapidly. Having more than one thread is for</span><br><span class="line">    system that need to accept connections very rapidly. However usually just</span><br><span class="line">    increasing <span class="tag">&lt;<span class="name">code</span>&gt;</span>acceptCount<span class="tag">&lt;/<span class="name">code</span>&gt;</span> will solve that problem.</span><br><span class="line">    Increasing this value may also be beneficial when a large amount of send file</span><br><span class="line">    operations are going on.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">attribute</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>由此可知，<code>acceptorThreadCount</code>用于设定接受连接的线程数。 在多CPU机器上增加这个值，虽然你可能真的不需要超过2个。哪怕有很多非keep alive连接，你也可能想要增加这个值。 其默认值为1。<br><code>pollerThreadCount</code>用于为轮询事件运行的线程数。默认值为每个处理器1个但不要超过2个(上面的优化配置里的设定为2)。接受socket时，操作系统将保持全局锁定。 因此，超过2个线程的好处迅速减少。 当系统拥有多个该类型线程，它可以非常快速地接受连接。 尽管增加acceptCount就可以解决这个问题。但当正在进行大量发送文件操作时，增加此值也可能是有益的。</p>
<h3 id="Acceptor和Poller的工作方式"><a href="#Acceptor和Poller的工作方式" class="headerlink" title="Acceptor和Poller的工作方式"></a>Acceptor和Poller的工作方式</h3><p>我们先来看一张NioEndpoint处理的的时序图:</p>
<p><img src="https://github.com/muyinchen/woker/blob/master/mypics/NioEndpoint%E5%A4%84%E7%90%86%E7%9A%84%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png?raw=true" alt=""></p>
<h4 id="Acceptor工作方式"><a href="#Acceptor工作方式" class="headerlink" title="Acceptor工作方式"></a>Acceptor工作方式</h4><p>我们由前面可知，Acceptor和Poller都实现了Runnable接口，所以其主要工作流程就在其实现的run方法内，这里我们先来看Acceptor对于run方法的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.tomcat.util.net.NioEndpoint.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SocketChannel <span class="title">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serverSock.accept();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//org.apache.tomcat.util.net.Acceptor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span>&lt;<span class="title">U</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Acceptor.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StringManager sm = StringManager.getManager(Acceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_ERROR_DELAY = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ERROR_DELAY = <span class="number">1600</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractEndpoint&lt;?,U&gt; endpoint;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> AcceptorState state = AcceptorState.NEW;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(AbstractEndpoint&lt;?,U&gt; endpoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.endpoint = endpoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AcceptorState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setThreadName</span><span class="params">(<span class="keyword">final</span> String threadName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> String <span class="title">getThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop until we receive a shutdown command</span></span><br><span class="line">        <span class="keyword">while</span> (endpoint.isRunning()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Loop if endpoint is paused</span></span><br><span class="line">            <span class="keyword">while</span> (endpoint.isPaused() &amp;&amp; endpoint.isRunning()) &#123;</span><br><span class="line">                state = AcceptorState.PAUSED;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!endpoint.isRunning()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            state = AcceptorState.RUNNING;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//if we have reached max connections, wait</span></span><br><span class="line">                endpoint.countUpOrAwaitConnection();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Endpoint might have been paused while waiting for latch</span></span><br><span class="line">                <span class="comment">// If that is the case, don't accept new connections</span></span><br><span class="line">                <span class="keyword">if</span> (endpoint.isPaused()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                U socket = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Accept the next incoming connection from the server</span></span><br><span class="line">                    <span class="comment">// socket</span></span><br><span class="line">                    <span class="comment">// 创建一个socketChannel，接收下一个从服务器进来的连接  </span></span><br><span class="line">                    socket = endpoint.serverSocketAccept();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ioe) &#123;</span><br><span class="line">                    <span class="comment">// We didn't get a socket</span></span><br><span class="line">                    endpoint.countDownConnection();</span><br><span class="line">                    <span class="keyword">if</span> (endpoint.isRunning()) &#123;</span><br><span class="line">                        <span class="comment">// Introduce delay if necessary</span></span><br><span class="line">                        errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">                        <span class="comment">// re-throw</span></span><br><span class="line">                        <span class="keyword">throw</span> ioe;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Successful accept, reset the error delay</span></span><br><span class="line">                errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Configure the socket</span></span><br><span class="line">                <span class="comment">// 如果EndPoint处于running状态并且没有没暂停</span></span><br><span class="line">                <span class="keyword">if</span> (endpoint.isRunning() &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line">                    <span class="comment">// setSocketOptions() will hand the socket off to</span></span><br><span class="line">                    <span class="comment">// an appropriate processor if successful</span></span><br><span class="line">                    <span class="keyword">if</span> (!endpoint.setSocketOptions(socket)) &#123;</span><br><span class="line">                        endpoint.closeSocket(socket);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    endpoint.destroySocket(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">                String msg = sm.getString(<span class="string">"endpoint.accept.fail"</span>);</span><br><span class="line">                <span class="comment">// APR specific.</span></span><br><span class="line">                <span class="comment">// Could push this down but not sure it is worth the trouble.</span></span><br><span class="line">                <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    Error e = (Error) t;</span><br><span class="line">                    <span class="keyword">if</span> (e.getError() == <span class="number">233</span>) &#123;</span><br><span class="line">                        <span class="comment">// Not an error on HP-UX so log as a warning</span></span><br><span class="line">                        <span class="comment">// so it can be filtered out on that platform</span></span><br><span class="line">                        <span class="comment">// See bug 50273</span></span><br><span class="line">                        log.warn(msg, t);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(msg, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(msg, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state = AcceptorState.ENDED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> AcceptorState &#123;</span><br><span class="line">        NEW, RUNNING, PAUSED, ENDED</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面run方法可以看到，<code>Acceptor</code>使用<code>serverSock.accept()</code>阻塞的监听端口，如果有连接进来，拿到了<code>socket</code>，并且<code>EndPoint</code>处于正常运行状态，则调用<code>NioEndPoint</code>的<code>setSocketOptions</code>方法，对于<code>setSocketOptions</code>，概括来讲就是根据<code>socket</code>构建一个<code>NioChannel</code>，然后把这个的<code>NioChannel</code>注册到<code>Poller</code>的事件列表里面，等待<code>poller</code>轮询:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.apache.tomcat.util.net.NioEndpoint.java</span></span><br><span class="line"><span class="comment">* Process the specified connection.</span></span><br><span class="line"><span class="comment">* 处理指定的连接</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> socket The socket channel</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &lt;code&gt;true&lt;/code&gt; if the socket was correctly configured</span></span><br><span class="line"><span class="comment">*  and processing may continue, &lt;code&gt;false&lt;/code&gt; if the socket needs to be</span></span><br><span class="line"><span class="comment">*  close immediately</span></span><br><span class="line"><span class="comment">* 如果socket配置正确，并且可能会继续处理，返回true </span></span><br><span class="line"><span class="comment">* 如果socket需要立即关闭，则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setSocketOptions</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Process the connection</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//disable blocking, APR style, we are gonna be polling it</span></span><br><span class="line">        socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Socket sock = socket.socket();</span><br><span class="line">        socketProperties.setProperties(sock);</span><br><span class="line">    <span class="comment">//从缓存中拿一个nioChannel  若没有，则创建一个。将socket传进去</span></span><br><span class="line">        NioChannel channel = nioChannels.pop();</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            SocketBufferHandler bufhandler = <span class="keyword">new</span> SocketBufferHandler(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="keyword">if</span> (isSSLEnabled()) &#123;</span><br><span class="line">                channel = <span class="keyword">new</span> SecureNioChannel(socket, bufhandler, selectorPool, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel = <span class="keyword">new</span> NioChannel(socket, bufhandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.setIOChannel(socket);</span><br><span class="line">            channel.reset();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//从pollers数组中获取一个Poller对象，注册这个nioChannel</span></span><br><span class="line">        getPoller0().register(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"endpoint.socketOptionsError"</span>), t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(tt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Tell to close the socket</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return an available poller in true round robin fashion.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> The next poller in sequence</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Poller <span class="title">getPoller0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = Math.abs(pollerRotater.incrementAndGet()) % pollers.length;</span><br><span class="line">    <span class="keyword">return</span> pollers[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于<code>getPoller0()</code>，默认情况下， 由前面可知，这个pollers数组里只有一个元素，这点要注意。我们来看NioEndPoint中的Poller实现的register方法，主要做的就是在Poller注册新创建的套接字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Registers a newly created socket with the poller.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> socket    The newly created socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> NioChannel socket)</span> </span>&#123;</span><br><span class="line">    socket.setPoller(<span class="keyword">this</span>);</span><br><span class="line">    NioSocketWrapper ka = <span class="keyword">new</span> NioSocketWrapper(socket, NioEndpoint.<span class="keyword">this</span>);</span><br><span class="line">    socket.setSocketWrapper(ka);</span><br><span class="line">    ka.setPoller(<span class="keyword">this</span>);</span><br><span class="line">    ka.setReadTimeout(getConnectionTimeout());</span><br><span class="line">    ka.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">    ka.setKeepAliveLeft(NioEndpoint.<span class="keyword">this</span>.getMaxKeepAliveRequests());</span><br><span class="line">    ka.setSecure(isSSLEnabled());</span><br><span class="line">    <span class="comment">//从缓存中取出一个PollerEvent对象，若没有则创建一个。将socket和NioSocketWrapper设置进去</span></span><br><span class="line">    PollerEvent r = eventCache.pop();</span><br><span class="line">    ka.interestOps(SelectionKey.OP_READ);<span class="comment">//this is what OP_REGISTER turns into.</span></span><br><span class="line">    <span class="keyword">if</span> ( r==<span class="keyword">null</span>) r = <span class="keyword">new</span> PollerEvent(socket,ka,OP_REGISTER);</span><br><span class="line">    <span class="keyword">else</span> r.reset(socket,ka,OP_REGISTER);</span><br><span class="line">    <span class="comment">//添到到该Poller的事件列表</span></span><br><span class="line">    addEvent(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对以上过程进行一下总结：</p>
<p>从Acceptor接收到请求，它做了如下工作：</p>
<ul>
<li>如果达到了最大连接数，则等待。否则，阻塞监听端口。</li>
<li>监听到有连接，则创建一个socketChannel。若服务正常运行，则把socket传递给适当的处理器。如果成功，会关闭socket。</li>
</ul>
<p>在这里，会调用NioEndPoint的setSocketOptions方法，处理指定的连接：</p>
<ul>
<li>将socket设置为非阻塞</li>
<li>从缓存中拿一个nioChannel  若没有，则创建一个。将socket传进去。</li>
<li>从pollers数组中获取一个Poller对象，把nioChannel注册到该Poller中。</li>
</ul>
<p>其中最后一步注册的过程，是调用Poller的register()方法：</p>
<ul>
<li>创建一个NioSocketWrapper，包装socket。然后配置相关属性，设置interestOps为SelectionKey.OP_READ</li>
<li>从缓存中取出一个PollerEvent对象，若没有则创建一个。初始化或者重置此Event对象，会将其interestOps设置为OP_REGISTER (Poller轮询时会用到)</li>
<li>将新的PollerEvent添加到这个Poller的事件列表events，等待Poller线程轮询。</li>
</ul>
<h4 id="Poller工作方式"><a href="#Poller工作方式" class="headerlink" title="Poller工作方式"></a>Poller工作方式</h4><p>由前面可知，poller也实现了Runnable接口，并在start的这部分生命周期执行的过程中创建对应工作线程并加入其中，所以，我们来通过其run方法来看下其工作机制。</p>
<p>其实上面已经提到了Poller将一个事件注册到事件队列的过程。接下来Poller线程要做的事情其实就是如何处理这些事件。</p>
<p>Poller在run方法中会轮询事件队列events，将每个PollerEvent中的SocketChannel的interestOps注册到Selector中，然后将PollerEvent从队列里移除。之后就是SocketChanel通过Selector调度来进行非阻塞的读写数据了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Poller class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Selector selector;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> SynchronizedQueue&lt;PollerEvent&gt; events =</span><br><span class="line">               <span class="keyword">new</span> SynchronizedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> nextExpiration = <span class="number">0</span>;<span class="comment">//optimize expiration handling</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> AtomicLong wakeupCounter = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> keyCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Poller</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKeyCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> keyCount; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Selector <span class="title">getSelector</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> selector;&#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The background thread that adds sockets to the Poller, checks the</span></span><br><span class="line"><span class="comment">        * poller for triggered events and hands the associated socket off to an</span></span><br><span class="line"><span class="comment">        * appropriate processor as events occur.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// Loop until destroy() is called</span></span><br><span class="line">            <span class="comment">// 循环直到 destroy() 被调用</span></span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">boolean</span> hasEvents = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!close) &#123;</span><br><span class="line">                       <span class="comment">//遍历events，将每个事件中的Channel的interestOps注册到Selector中</span></span><br><span class="line">                       hasEvents = events();</span><br><span class="line">                       <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">//if we are here, means we have other stuff to do</span></span><br><span class="line">                           <span class="comment">//do a non blocking select</span></span><br><span class="line">                           <span class="comment">//如果走到了这里，代表已经有就绪的IO Channel</span></span><br><span class="line">                           <span class="comment">//调用非阻塞的select方法，直接返回就绪Channel的数量</span></span><br><span class="line">                           keyCount = selector.selectNow();</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">//阻塞等待操作系统返回 数据已经就绪的Channel，然后被唤醒</span></span><br><span class="line">                           keyCount = selector.select(selectorTimeout);</span><br><span class="line">                       &#125;</span><br><span class="line">                       wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                       events();</span><br><span class="line">                       timeout(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           selector.close();</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                           log.error(sm.getString(<span class="string">"endpoint.nio.selectorCloseFail"</span>), ioe);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                   ExceptionUtils.handleThrowable(x);</span><br><span class="line">                   log.error(sm.getString(<span class="string">"endpoint.nio.selectorLoopError"</span>), x);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//either we timed out or we woke up, process events first</span></span><br><span class="line">               <span class="comment">//如果上面select方法超时，或者被唤醒，先将events队列中的Channel注册到Selector上。</span></span><br><span class="line">               <span class="keyword">if</span> ( keyCount == <span class="number">0</span> ) hasEvents = (hasEvents | events());</span><br><span class="line"></span><br><span class="line">               Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">                   keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line">               <span class="comment">// any active event.</span></span><br><span class="line">                <span class="comment">// 遍历已就绪的Channel，并调用processKey来处理该Socket的IO。</span></span><br><span class="line">               <span class="keyword">while</span> (iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">                   SelectionKey sk = iterator.next();</span><br><span class="line">                   NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">                   <span class="comment">// Attachment may be null if another thread has called</span></span><br><span class="line">                   <span class="comment">// cancelledKey()</span></span><br><span class="line">                   <span class="comment">// 如果其它线程已调用，则Attachment可能为空</span></span><br><span class="line">                   <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       iterator.remove();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       iterator.remove();</span><br><span class="line">                   <span class="comment">//创建一个SocketProcessor，放入Tomcat线程池去执行</span></span><br><span class="line">                       processKey(sk, attachment);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//process timeouts</span></span><br><span class="line">               timeout(keyCount,hasEvents);</span><br><span class="line">           &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">           getStopLatch().countDown();</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面读取已就绪Channel的部分，是十分常见的Java NIO的用法，即 Selector调用selectedKeys()，获取IO数据已经就绪的Channel，遍历并调用processKey方法来处理每一个Channel就绪的事件。而processKey方法会创建一个SocketProcessor，然后丢到Tomcat线程池中去执行。</p>
<p>这里还需要注意的一个点是，events()方法，用来处理PollerEvent事件，执行PollerEvent.run()，然后将PollerEvent重置再次放入缓存中，以便对象复用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Processes events in the event queue of the Poller.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &lt;code&gt;true&lt;/code&gt; if some events were processed,</span></span><br><span class="line"><span class="comment">*   &lt;code&gt;false&lt;/code&gt; if queue was empty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">events</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    PollerEvent pe = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != <span class="keyword">null</span>; i++ ) &#123;</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//把SocketChannel的interestOps注册到Selector中</span></span><br><span class="line">            pe.run();</span><br><span class="line">            pe.reset();</span><br><span class="line">            <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                eventCache.push(pe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( Throwable x ) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"endpoint.nio.pollerEventError"</span>), x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，PollerEvent.run()方法才是我们关注的重点:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* PollerEvent, cacheable object for poller events to avoid GC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PollerEvent</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NioChannel socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interestOps;</span><br><span class="line">    <span class="keyword">private</span> NioSocketWrapper socketWrapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PollerEvent</span><span class="params">(NioChannel ch, NioSocketWrapper w, <span class="keyword">int</span> intOps)</span> </span>&#123;</span><br><span class="line">        reset(ch, w, intOps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(NioChannel ch, NioSocketWrapper w, <span class="keyword">int</span> intOps)</span> </span>&#123;</span><br><span class="line">        socket = ch;</span><br><span class="line">        interestOps = intOps;</span><br><span class="line">        socketWrapper = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reset(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Acceptor调用Poller.register()方法时，创建的PollerEvent的interestOps为OP_REGISTER，因此走这个分支</span></span><br><span class="line">        <span class="keyword">if</span> (interestOps == OP_REGISTER) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.getIOChannel().register(</span><br><span class="line">                        socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">"endpoint.nio.registerFail"</span>), x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The key was cancelled (e.g. due to socket closure)</span></span><br><span class="line">                    <span class="comment">// and removed from the selector while it was being</span></span><br><span class="line">                    <span class="comment">// processed. Count down the connections at this point</span></span><br><span class="line">                    <span class="comment">// since it won't have been counted down when the socket</span></span><br><span class="line">                    <span class="comment">// closed.</span></span><br><span class="line">                    socket.socketWrapper.getEndpoint().countDownConnection();</span><br><span class="line">                    ((NioSocketWrapper) socket.socketWrapper).closed = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> NioSocketWrapper socketWrapper = (NioSocketWrapper) key.attachment();</span><br><span class="line">                    <span class="keyword">if</span> (socketWrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//we are registering the key to start with, reset the fairness counter.</span></span><br><span class="line">                        <span class="keyword">int</span> ops = key.interestOps() | interestOps;</span><br><span class="line">                        socketWrapper.interestOps(ops);</span><br><span class="line">                        key.interestOps(ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        socket.getPoller().cancelledKey(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.getPoller().cancelledKey(key);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Poller event: socket ["</span> + socket + <span class="string">"], socketWrapper ["</span> + socketWrapper +</span><br><span class="line">                <span class="string">"], interestOps ["</span> + interestOps + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，可以看出Poller线程的作用</p>
<ul>
<li>将Acceptor接收到的请求注册到Poller的事件队列中</li>
<li>Poller轮询事件队列中，处理到达的事件，将PollerEvent中的通道注册到Poller的Selector中</li>
<li>轮询已就绪的通道，对每个就绪通道创建一个SocketProcessor，交由Tomcat线程池去处理</li>
</ul>
<p>剩下的事情，就是SocketProcessor怎么适配客户端发来请求的数据、然后怎样交给Servlet容器去处理了。</p>
<p>即Poller的run方法中最后调用的<code>processKey(sk, attachment);</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper attachment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( close ) &#123;</span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( sk.isValid() &amp;&amp; attachment != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sk.isReadable() || sk.isWritable() ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( attachment.getSendfileData() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                    processSendfile(sk,attachment, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unreg(sk, attachment, sk.readyOps());</span><br><span class="line">                    <span class="keyword">boolean</span> closeSocket = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// Read goes before write</span></span><br><span class="line">                    <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_READ, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_WRITE, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (closeSocket) &#123;</span><br><span class="line">                        cancelledKey(sk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//invalid key</span></span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( CancelledKeyException ckx ) &#123;</span><br><span class="line">        cancelledKey(sk);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        log.error(sm.getString(<span class="string">"endpoint.nio.keyProcessingError"</span>), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即从<code>processSocket</code>这个方法中会用到<code>SocketProcessor</code>来处理请求:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Process the given SocketWrapper with the given status. Used to trigger</span></span><br><span class="line"><span class="comment">    * processing as if the Poller (for those endpoints that have one)</span></span><br><span class="line"><span class="comment">    * selected the socket.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> socketWrapper The socket wrapper to process</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> event         The socket event to be processed</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dispatch      Should the processing be performed on a new</span></span><br><span class="line"><span class="comment">    *                          container thread</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> if processing was triggered successfully</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">        SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (socketWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.reset(socketWrapper, event);</span><br><span class="line">        &#125;</span><br><span class="line">        Executor executor = getExecutor();</span><br><span class="line">        <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(sc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">        getLog().warn(sm.getString(<span class="string">"endpoint.executor.fail"</span>, socketWrapper) , ree);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="comment">// This means we got an OOM or similar creating a thread, or that</span></span><br><span class="line">        <span class="comment">// the pool and its queue are full</span></span><br><span class="line">        getLog().error(sm.getString(<span class="string">"endpoint.process.fail"</span>), t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SocketProcessor处理请求"><a href="#SocketProcessor处理请求" class="headerlink" title="SocketProcessor处理请求"></a>SocketProcessor处理请求</h3><p>这里简单提一下<code>SocketProcessor</code>的处理过程，帮助大家对接到Servlet容器处理上。通过上面可以知道，具体处理一个请求，是在SocketProcessor通过线程池去执行的，这里，我们来看其执行一次请求的时序图:<br><img src="https://github.com/muyinchen/woker/blob/master/mypics/%E4%BB%8ESocketProcessor%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png?raw=true" alt=""></p>
<p>由图中可以看到，<code>SocketProcessor</code>中通过<code>Http11ConnectionHandler</code>，拿到<code>Htpp11Processor</code>，然后<code>Htpp11Processor</code>会调用<code>prepareRequest</code>方法来准备好请求数据。接着调用<code>CoyoteAdapter</code>的<code>service</code>方法进行<code>request</code>和<code>response</code>的适配，之后交给<code>Tomcat</code>容器进行处理。</p>
<p> 下面通过一个系列调用来表示下过程:</p>
<p><code>connector.getService().getContainer().getPipeline().getFirst().invoke(request,response);</code></p>
<p>  这里首先从Connector 中获取到Service ( Connector 在initInternal 方法中创建CoyoteAdapter的时候已经将自己设置到了CoyoteAdapter 中)，然后从Service 中获取Container ，接着获取管道，再获取管道的第一个Value，最后调用invoke 方法执行请求。Service 中保存的是最顶层的容器，当调用最顶层容器管道的invoke 方法时，管道将逐层调用各层容器的管道中Value 的invoke 方法，直到最后调用Wrapper 的管道中的BaseValue ( StandardWrapperValve)来处理Filter 和Servlet。</p>
<p>将请求交给Tomcat容器处理后，然后将请求一层一层传递到Engine、Host、Context、Wrapper，最终经过一系列Filter，来到了Servlet，执行我们自己具体的代码逻辑。</p>
<p>至此关于Connector的一些东西就算涉及差不多了，剩下的假如以后有精力的话，继续探究下，接着分享Webflux的解读去。</p>
<p>补充:<br>感谢零度大佬(博客:<a href="http://www.jiangxinlingdu.com)的提问，这里我将自己的一些额外的问题理解进行内容补充" target="_blank" rel="noopener">http://www.jiangxinlingdu.com)的提问，这里我将自己的一些额外的问题理解进行内容补充</a>:</p>
<p>这里对于其中<code>NioEndpoint</code>中其有关生命周期部分的实现所涉及的<code>initServerSocket()</code>再来关注下细节:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Separated out to make it easier for folks that extend NioEndpoint to</span></span><br><span class="line"><span class="comment">// implement custom [server]sockets</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initServerSocket</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">        serverSock = ServerSocketChannel.open();</span><br><span class="line">        socketProperties.setProperties(serverSock.socket());</span><br><span class="line">        InetSocketAddress addr = <span class="keyword">new</span> InetSocketAddress(getAddress(), getPortWithOffset());</span><br><span class="line">        serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Retrieve the channel provided by the OS</span></span><br><span class="line">        Channel ic = System.inheritedChannel();</span><br><span class="line">        <span class="keyword">if</span> (ic <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">            serverSock = (ServerSocketChannel) ic;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (serverSock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">"endpoint.init.bind.inherited"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其最后一句，为什么tomcat这个不设置非阻塞？这会儿是刚初始化的时候，设定为阻塞状态，阻塞也只是阻塞在这个线程上，即<code>Acceptor</code>在一条线程内执行其run方法的时候，会调用<code>endpoint.serverSocketAccept()</code>来创建一个<code>socketChannel</code>，接收下一个从服务器进来的连接。当成功接收到，重新对此<code>socket</code>进行配置，即会调用<code>endpoint.setSocketOptions(socket)</code>，在这个方法内，会调用 <code>socket.configureBlocking(false);</code>，此时，会开启<code>SocketChannel</code>在非阻塞模式，具体代码请回顾本文前面细节。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Reactor Rxjava">
    <span class="tag-code">Reactor Rxjava</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2018/11/02/Java编程方法论-响应式 之 Rxjava篇 源码解读系列/">
        <span class="nav-arrow">← </span>
        
          Java编程方法论-响应式 之 Rxjava篇 视频解读
        
      </a>
    
    
      <a class="nav-right" href="/2019/01/02/BIO到NIO源码的一些事儿之BIO/">
        
          BIO到NIO源码的一些事儿之BIO
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#tomcat从启动到接轨Servlet二三事"><span class="toc-nav-text">tomcat从启动到接轨Servlet二三事</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#缘由"><span class="toc-nav-text">缘由</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Tomcat的启动过程详解"><span class="toc-nav-text">Tomcat的启动过程详解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#启动过程Bootstrap详解"><span class="toc-nav-text">启动过程Bootstrap详解</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#启动过程Catalina详解"><span class="toc-nav-text">启动过程Catalina详解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Catalina中start解读"><span class="toc-nav-text">Catalina中start解读</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Catalina中load-解读"><span class="toc-nav-text">Catalina中load()解读</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#getServer-init"><span class="toc-nav-text">getServer().init()</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Catalina中start里的getServer-start-解读"><span class="toc-nav-text">Catalina中start里的getServer().start()解读</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Connector解读"><span class="toc-nav-text">Connector解读</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Connector构造器"><span class="toc-nav-text">Connector构造器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Connector初始化与启动"><span class="toc-nav-text">Connector初始化与启动</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Protocol的相关解读"><span class="toc-nav-text">Protocol的相关解读</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Endpoint相关解读"><span class="toc-nav-text">Endpoint相关解读</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Acceptor和Poller的工作方式"><span class="toc-nav-text">Acceptor和Poller的工作方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Acceptor工作方式"><span class="toc-nav-text">Acceptor工作方式</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Poller工作方式"><span class="toc-nav-text">Poller工作方式</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#SocketProcessor处理请求"><span class="toc-nav-text">SocketProcessor处理请求</span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://muyinchen.github.io/2018/12/26/tomcat从启动到接轨Servlet二三事/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "yanm1ng";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "tomcat从启动到接轨Servlet二三事",
        owner: "yanm1ng",
        repo: "yanm1ng.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

<script>
  var disqus_shortname = '';
  
  var disqus_url = 'https://muyinchen.github.io/2018/12/26/tomcat从启动到接轨Servlet二三事/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2019 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>