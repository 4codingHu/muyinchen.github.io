<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Spring Data Commons" />





  <link rel="alternate" href="/atom.xml" title="一叶知秋" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="Spring Data Commons - 中文参考文档Oliver GierkeThomas DarimontChristoph StroblMark PollackThomas Risberg版本1.13.4.RELEASE，2017-06-08
©2008-2015原作者.">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Data Commons - 中文参考文档">
<meta property="og:url" content="https://muyinchen.github.io/2017/06/09/Spring Data Commons - 参考文档/index.html">
<meta property="og:site_name" content="一叶知秋">
<meta property="og:description" content="Spring Data Commons - 中文参考文档Oliver GierkeThomas DarimontChristoph StroblMark PollackThomas Risberg版本1.13.4.RELEASE，2017-06-08
©2008-2015原作者.">
<meta property="og:updated_time" content="2017-06-12T03:19:50.596Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring Data Commons - 中文参考文档">
<meta name="twitter:description" content="Spring Data Commons - 中文参考文档Oliver GierkeThomas DarimontChristoph StroblMark PollackThomas Risberg版本1.13.4.RELEASE，2017-06-08
©2008-2015原作者.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://muyinchen.github.io/2017/06/09/Spring Data Commons - 参考文档/"/>


  <title> Spring Data Commons - 中文参考文档 | 一叶知秋 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=UA-83014983-1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一叶知秋</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            日程
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Spring Data Commons - 中文参考文档
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-06-09T22:11:55+08:00" content="2017-06-09">
              2017-06-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring-Data-Commons/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Data Commons</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/09/Spring Data Commons - 参考文档/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/09/Spring Data Commons - 参考文档/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-user"> 本站访客数 </i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>人次
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Spring-Data-Commons-中文参考文档"><a href="#Spring-Data-Commons-中文参考文档" class="headerlink" title="Spring Data Commons - 中文参考文档"></a>Spring Data Commons - 中文参考文档</h1><p>Oliver GierkeThomas DarimontChristoph StroblMark PollackThomas Risberg版本1.13.4.RELEASE，2017-06-08</p>
<p>©2008-2015原作者.<br><a id="more"></a><br>| <strong>注</strong>注<strong>注</strong> | 只要您不对这些副本收取任何费用，并且进一步规定，每个副本都包含本版权声明，无论是以印刷版还是电子版分发，本文档的副本可供您自己使用并分发给他人. |<br>| ———– | —————————————- |<br>|             |                                          |</p>
<p>目录</p>
<ul>
<li>前言<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#project" target="_blank" rel="external">项目元数据</a></li>
</ul>
</li>
<li>参考文献<ul>
<li>依赖关系<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#dependencies.spring-boot" target="_blank" rel="external">2.1.使用Spring Boot进行依赖管理</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#dependencies.spring-framework" target="_blank" rel="external">2.2.Spring框架</a></li>
</ul>
</li>
<li>3.使用Spring数据存储库<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.core-concepts" target="_blank" rel="external">3.1.核心概念</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods" target="_blank" rel="external">3.2.查询方式</a></li>
<li>3.3.定义存储库接口<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.definition-tuning" target="_blank" rel="external">3.3.1.微调存储库定义</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.multiple-modules" target="_blank" rel="external">3.3.2.使用多个Spring数据模块的存储库</a></li>
</ul>
</li>
<li>3.4.定义查询方法<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-lookup-strategies" target="_blank" rel="external">3.4.1.查询查询策略</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation" target="_blank" rel="external">3.4.2.查询创建</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-property-expressions" target="_blank" rel="external">3.4.3.属性表达式</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.special-parameters" target="_blank" rel="external">3.4.4.特殊参数处理</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.limit-query-result" target="_blank" rel="external">3.4.5.限制查询结果</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-streaming" target="_blank" rel="external">3.4.6.流式查询结果</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-async" target="_blank" rel="external">3.4.7.异步查询结果</a></li>
</ul>
</li>
<li>3.5.创建存储库实例<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.create-instances.spring" target="_blank" rel="external">3.5.1.XML配置</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.create-instances.java-config" target="_blank" rel="external">3.5.2.JavaConfig</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.create-instances.standalone" target="_blank" rel="external">3.5.3.独立使用</a></li>
</ul>
</li>
<li>3.6.Spring数据存储库的自定义实现<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.single-repository-behaviour" target="_blank" rel="external">3.6.1.将自定义行为添加到单个存储库</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.custom-behaviour-for-all-repositories" target="_blank" rel="external">3.6.2.将自定义行为添加到所有存储库</a></li>
</ul>
</li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#core.domain-events" target="_blank" rel="external">3.7.从集合根发布事件</a></li>
<li>3.8.Spring数据扩展<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#core.extensions.querydsl" target="_blank" rel="external">3.8.1.Querydsl扩展</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#core.web" target="_blank" rel="external">3.8.2.网络支持</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#core.repository-populators" target="_blank" rel="external">3.8.3.存储库populator</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#web.legacy" target="_blank" rel="external">3.8.4.传统网络支持</a></li>
</ul>
</li>
</ul>
</li>
<li>4.按示例查询<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#query-by-example.introduction" target="_blank" rel="external">4.1.介绍</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#query-by-example.usage" target="_blank" rel="external">4.2.用法</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#query-by-example.matchers" target="_blank" rel="external">4.3.示例匹配器</a></li>
</ul>
</li>
<li>5.审计<ul>
<li>5.1.基本<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#auditing.annotations" target="_blank" rel="external">5.1.1.基于注解的审计元数据</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#auditing.interfaces" target="_blank" rel="external">5.1.2.基于接口的审计元数据</a></li>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#auditing.auditor-aware" target="_blank" rel="external">5.1.3.AuditorAware</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>附录<ul>
<li>附录A：命名空间参考<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#populator.namespace-dao-config" target="_blank" rel="external">元素</a></li>
</ul>
</li>
<li>附录B：Populators命名空间参考<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#namespace-dao-config" target="_blank" rel="external">元素</a></li>
</ul>
</li>
<li>附录C：存储库查询关键字<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#_supported_query_keywords" target="_blank" rel="external">支持的查询关键字</a></li>
</ul>
</li>
<li>附录D：存储库查询返回类型<ul>
<li><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#_supported_query_return_types" target="_blank" rel="external">支持的查询返回类型</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Data Commons项目将核心Spring概念应用到使用许多关系和非关系数据存储的解决方案的开发中.</p>
<h2 id="项目元数据"><a href="#项目元数据" class="headerlink" title="项目元数据"></a>项目元数据</h2><ul>
<li>版本控制 - <a href="https://github.com/spring-projects/spring-data-commons" target="_blank" rel="external">http://github.com/spring-projects/spring-data-commons</a></li>
<li>Bugtracker - <a href="https://jira.spring.io/browse/DATACMNS" target="_blank" rel="external">https://jira.spring.io/browse/DATACMNS</a></li>
<li>版本库 - <a href="https://repo.spring.io/libs-release" target="_blank" rel="external">https://repo.spring.io/libs-release</a></li>
<li>里程碑存储库 - <a href="https://repo.spring.io/libs-milestone" target="_blank" rel="external">https://repo.spring.io/libs-milestone</a></li>
<li>快照库 - <a href="https://repo.spring.io/libs-snapshot" target="_blank" rel="external">https://repo.spring.io/libs-snapshot</a></li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>由于个别Spring数据模块的初始日期不同，其中大多数都带有不同的主要和次要版本号.找到兼容版本的最简单的方法是依靠我们随附的兼容版本定义的Spring Data Release Train BOM.在Maven项目<code>&lt;dependencyManagement /&gt;</code>中，您可以在POM部分中声明此依赖关系：</p>
<p>示例1.使用Spring数据发布列表BOM</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-releasetrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;release-train&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div></pre></td></tr></table></figure>
<p>目前的发布火车版本是<code>Ingalls-SR4</code>.火车名称按字母顺序升序，目前可用的火车名称列<a href="https://github.com/spring-projects/spring-data-commons/wiki/Release-planning" target="_blank" rel="external">在这里</a>.版本名称遵循以下模式：<code>${name}-${release}</code>其中release可以是以下之一：</p>
<ul>
<li><code>BUILD-SNAPSHOT</code> - 当前快照</li>
<li><code>M1</code>，<code>M2</code>等等-里程碑</li>
<li><code>RC1</code>，<code>RC2</code>等等-候选发布版</li>
<li><code>RELEASE</code> - GA发布</li>
<li><code>SR1</code>，<code>SR2</code>等等-服务版本</li>
</ul>
<p>使用BOM的一个工作示例可以在我们的<a href="https://github.com/spring-projects/spring-data-examples/tree/master/bom" target="_blank" rel="external">Spring Data示例存储库中找到</a>.如果这样就可以声明要在<code>&lt;dependencies /&gt;</code>块中使用没有版本的Spring数据模块.</p>
<p>示例2.声明对Spring数据模块的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="2-1-使用Spring-Boot进行依赖管理"><a href="#2-1-使用Spring-Boot进行依赖管理" class="headerlink" title="2.1.使用Spring Boot进行依赖管理"></a>2.1.使用Spring Boot进行依赖管理</h3><p>Spring Boot已经为您选择了最新版本的Spring数据模块.如果您想要升级到较新版本，只需将该属性配置<code>spring-data-releasetrain.version</code>为您要使用的<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#dependencies.train-names" target="_blank" rel="external">列车名称和迭代</a>.</p>
<h3 id="2-2-Spring框架"><a href="#2-2-Spring框架" class="headerlink" title="2.2.Spring框架"></a>2.2.Spring框架</h3><p>当前版本的Spring Data模块需要Spring Framework在4.3.9.RELEASE或更好的版本中.这些模块也可能会使用该较小版本的旧版本错误版本.但是，强烈建议您使用该版本中的最新版本.</p>
<h2 id="3-使用Spring数据存储库"><a href="#3-使用Spring数据存储库" class="headerlink" title="3.使用Spring数据存储库"></a>3.使用Spring数据存储库</h2><p>Spring数据库抽象的目标是大大减少为各种持久性存储实现数据访问层所需的样板代码量.</p>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th><em>Spring数据存储库文档和您的模块</em>本章介绍了Spring Data存储库的核心概念和接口.本章中的信息是从Spring Data Commons模块中获取的.它使用Java Persistence API（JPA）模块的配置和代码示例.将XML命名空间声明和要扩展的类型调整为您正在使用的特定模块的等效项.<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.namespace-reference" target="_blank" rel="external">命名空间参考</a>涵盖支持存储库API的所有Spring数据模块支持的XML配置，<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repository-query-keywords" target="_blank" rel="external">Repository查询关键字</a>涵盖了一般由存储库抽象支持的查询方法关键字.有关模块特定功能的详细信息，请参阅本文档该模块的一章.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h3 id="3-1-核心概念"><a href="#3-1-核心概念" class="headerlink" title="3.1.核心概念"></a>3.1.核心概念</h3><p>Spring数据库抽象中的中央接口<code>Repository</code>（可能不是什么惊喜）.管理域类以及域类的id类型作为类型参数.此接口主要作为标记接口捕获要使用的类型，并帮助您发现扩展此接口的接口.该<code>CrudRepository</code>规定对于正在管理的实体类复杂的CRUD功能.</p>
<p>示例3. CrudRepository接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; &#123;</div><div class="line"></div><div class="line">    &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>; *<span class="number">1</span>*</div><div class="line"></div><div class="line">    <span class="function">T <span class="title">findOne</span><span class="params">(ID primaryKey)</span></span>;    *<span class="number">2</span>*   </div><div class="line"></div><div class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;        *<span class="number">3</span>*  </div><div class="line"></div><div class="line">    <span class="function">Long <span class="title">count</span><span class="params">()</span></span>;               *<span class="number">4</span>*   </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(T entity)</span></span>;        *<span class="number">5</span>*  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(ID primaryKey)</span></span>;  *<span class="number">6</span>*</div><div class="line"></div><div class="line">    <span class="comment">// … more functionality omitted.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><em>1</em></th>
<th>保存给定的实体.</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>2</em></td>
<td>返回由给定的ID标识的实体.</td>
</tr>
<tr>
<td><em>3</em></td>
<td>返回所有实体.</td>
</tr>
<tr>
<td><em>4</em></td>
<td>返回实体数.</td>
</tr>
<tr>
<td><em>5</em></td>
<td>删除给定的实体.</td>
</tr>
<tr>
<td><em>6</em></td>
<td>指示是否存在具有给定id的实体.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>我们还提供持久性技术特定的抽象，例如<code>JpaRepository</code>或<code>MongoRepository</code>.<code>CrudRepository</code>除了相当通用的持久化技术不可知的接口，例如CrudRepository，这些接口还扩展和暴露了底层持久性技术的功能.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>除此之外，<code>CrudRepository</code>还有一个<code>PagingAndSortingRepository</code>抽象方法可以添加其他方法来简化对实体的分页访问：</p>
<p>示例4. PagingAndSortingRepository</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt;</span></div><div class="line">  <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; &#123;</div><div class="line"></div><div class="line">  <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort sort)</span></span>;</div><div class="line"></div><div class="line">  <span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>访问第二页的<code>User</code>页面大小为20，你可以简单地做这样的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PagingAndSortingRepository&lt;User, Long&gt; repository = <span class="comment">// … get access to a bean</span></div><div class="line">Page&lt;User&gt; users = repository.findAll(<span class="keyword">new</span> PageRequest(<span class="number">1</span>, <span class="number">20</span>));</div></pre></td></tr></table></figure>
<p>除了查询方法之外，还可以查询计数和删除查询的推导.</p>
<p>示例5.派生计数查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="function">Long <span class="title">countByLastname</span><span class="params">(String lastname)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>派生删除查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="function">Long <span class="title">deleteByLastname</span><span class="params">(String lastname)</span></span>;</div><div class="line"></div><div class="line">  <span class="function">List&lt;User&gt; <span class="title">removeByLastname</span><span class="params">(String lastname)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-查询方式"><a href="#3-2-查询方式" class="headerlink" title="3.2.查询方式"></a>3.2.查询方式</h3><p>标准CRUD功能库通常在基础数据存储上有查询.使用Spring数据，声明这些查询将成为四个步骤：</p>
<ol>
<li><p>声明扩展Repository或其一个子接口的接口，并将其键入将要处理的域类和ID类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在接口上声明查询方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>设置Spring为这些接口创建代理实例.通过<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.create-instances.java-config" target="_blank" rel="external">JavaConfig</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</div><div class="line"></div><div class="line"><span class="meta">@EnableJpaRepositories</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>或通过<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.create-instances" target="_blank" rel="external">XML配置</a>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">   <span class="attr">xmlns:jpa</span>=<span class="string">"http://www.springframework.org/schema/data/jpa"</span></div><div class="line">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">     http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">     http://www.springframework.org/schema/data/jpa</div><div class="line">     http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;</div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">"com.acme.repositories"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在这个例子中使用JPA命名空间.如果您正在为任何其他商店使用存储库抽象，则需要将其更改为商店模块的相应命名空间声明，该名称空间声明应该进行交换<code>jpa</code>，例如<code>mongodb</code>.</p>
<p>另外，请注意，JavaConfig变体不会明确地配置程序包，因为默认情况下使用注解类的程序包.要自定义要扫描的软件包，请使用<code>basePackage…</code>数据存储特定存储库-annotation的<code>@Enable…</code>属性之一.</p>
</li>
<li><p>获取注册表实例并使用它.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClient</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> PersonRepository repository;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Person&gt; persons = repository.findByLastname(<span class="string">"Matthews"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>下面的部分详细说明每一步.</p>
<h3 id="3-3-定义存储库接口"><a href="#3-3-定义存储库接口" class="headerlink" title="3.3.定义存储库接口"></a>3.3.定义存储库接口</h3><p>作为第一步，您定义一个域类别的存储库接口.该接口必须扩展Repository并输入到域类和ID类型.如果要公开该域类型的CRUD方法，则扩展<code>CrudRepository</code>而不是<code>Repository</code>.</p>
<h4 id="3-3-1-微调存储库定义"><a href="#3-3-1-微调存储库定义" class="headerlink" title="3.3.1.微调存储库定义"></a>3.3.1.微调存储库定义</h4><p>通常情况下，你的资料库接口将延长<code>Repository</code>，<code>CrudRepository</code>或<code>PagingAndSortingRepository</code>.或者，如果您不想扩展Spring数据接口，还可以使用它来注解存储库接口<code>@RepositoryDefinition</code>.扩展<code>CrudRepository</code>公开了一套完整的方法来操纵您的实体.如果您希望对所暴露的方法有选择性，只需将要暴露的方法复制<code>CrudRepository</code>到您的域库中即可.</p>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>这允许您在提供的Spring数据存储库功能之上定义自己的抽象.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>示例7.选择性地暴露CRUD方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NoRepositoryBean</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="function">T <span class="title">findOne</span><span class="params">(ID id)</span></span>;</div><div class="line"></div><div class="line">  <span class="function">T <span class="title">save</span><span class="params">(T entity)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在此第一步中，您为所有域存储库定义了一个公共基础接口，并将其暴露出来<code>findOne(…)</code>.<code>save(…)</code>这些方法将被路由到由Spring Data提供的您选择的存储库的基本存储库实现中，例如在JPA的情况下<code>SimpleJpaRepository</code>，因为他们正在匹配方法签名<code>CrudRepository</code>.所以<code>UserRepository</code>现在将能够保存用户，并通过id查找单个，以及触发查询以<code>Users</code>通过其电子邮件地址查找.</p>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>请注意，中间版本库接口被注解为<code>@NoRepositoryBean</code>.确保将该注解添加到Spring Data不应在运行时创建实例的所有存储库接口.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="3-3-2-使用多个Spring数据模块的存储库"><a href="#3-3-2-使用多个Spring数据模块的存储库" class="headerlink" title="3.3.2.使用多个Spring数据模块的存储库"></a>3.3.2.使用多个Spring数据模块的存储库</h4><p>在应用程序中使用唯一的Spring数据模块使事情变得简单，因此定义范围内的所有存储库接口都绑定到Spring数据模块.有时应用程序需要使用多个Spring数据模块.在这种情况下，存储库定义需要区分持久性技术.Spring Data进入严格的存储库配置模式，因为它在类路径上检测到多个存储库工厂.严格的配置需要有关存储库或域类的详细信息来决定用于存储库定义的Spring数据模块绑定：</p>
<ol>
<li>如果存储库定义<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.multiple-modules.types" target="_blank" rel="external">扩展了模块特定的存储库</a>，那么它是<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.multiple-modules.types" target="_blank" rel="external">特定</a> Spring数据模块的有效候选者.</li>
<li>如果域类<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.multiple-modules.annotations" target="_blank" rel="external">使用模块特定类型注解进行注解</a>，那么它是特定Spring数据模块的有效候选项.Spring数据模块接受第三方注解（如JPA <code>@Entity</code>）或提供自己的注解，例如<code>@Document</code>Spring Data MongoDB / Spring Data Elasticsearch.</li>
</ol>
<p>示例8.使用模块特定接口的存储库定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="meta">@NoRepositoryBean</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</div><div class="line">  …</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line">  …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MyRepository</code>并<code>UserRepository</code>延长<code>JpaRepository</code>他们的类型层次.它们是Spring Data JPA模块的有效候选.</p>
<p>示例9.使用通用接口的存储库定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AmbiguousRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line"> …</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@NoRepositoryBean</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</div><div class="line">  …</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AmbiguousUserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line">  …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AmbiguousRepository</code>和<code>AmbiguousUserRepository</code>仅延伸<code>Repository</code>，并<code>CrudRepository</code>在他们的类型层次.虽然使用独特的Spring数据模块是非常好的，但是多个模块无法区分哪些特定的Spring Data这些存储库应该绑定.</p>
<p>示例10.使用带有注解的域类的存储库定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line"> …</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  …</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line"> …</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Document</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">  …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PersonRepository</code>引用<code>Person</code>用JPA注解注解<code>@Entity</code>，因此这个存储库显然属于Spring Data JPA.<code>UserRepository</code>使用<code>User</code>注解与Spring数据MongoDB的<code>@Document</code>注解.</p>
<p>示例11.使用具有混合注解的域类的存储库定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JpaPersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line"> …</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MongoDBPersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line"> …</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="meta">@Document</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此示例显示使用JPA和Spring Data MongoDB注解的域类.它定义了两个仓库，<code>JpaPersonRepository</code>和<code>MongoDBPersonRepository</code>.一个用于JPA，另一个用于MongoDB使用.Spring数据不再能够分辨出存储库导致未定义的行为.</p>
<p><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.multiple-modules.types" target="_blank" rel="external">存储库类型详细信息</a>和<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.multiple-modules.annotations" target="_blank" rel="external">标识域类注解</a>用于严格的存储库配置，以识别特定Spring数据模块的存储库候选.在同一个域类型上使用多个持久性技术特定的注解可能会跨多个持久性技术重用域类型，但是Spring Data不再能够确定绑定存储库的唯一模块.</p>
<p>区分资源库的最后一个方法是定义库基础包.基本包定义了扫描存储库接口定义的起点，这意味着存储库定义位于相应的包中.默认情况下，注解驱动的配置使用配置类的包.<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.create-instances.spring" target="_blank" rel="external">基于XML的配置</a>中的<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.create-instances.spring" target="_blank" rel="external">基本包</a>是强制性的.</p>
<p>示例12.基本包的注解驱动配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableJpaRepositories</span>(basePackages = <span class="string">"com.acme.repositories.jpa"</span>)</div><div class="line"><span class="meta">@EnableMongoRepositories</span>(basePackages = <span class="string">"com.acme.repositories.mongo"</span>)</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Configuration</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-定义查询方法"><a href="#3-4-定义查询方法" class="headerlink" title="3.4.定义查询方法"></a>3.4.定义查询方法</h3><p>存储库代理有两种方法从方法名称中导出特定于存储的查询.它可以直接从方法名称导出查询，或通过使用手动定义的查询.可用选项取决于实际存储.但是，必须有一个策略来决定创建什么实际的查询.我们来看看可用的选项.</p>
<h4 id="3-4-1-查询查询策略"><a href="#3-4-1-查询查询策略" class="headerlink" title="3.4.1.查询查询策略"></a>3.4.1.查询查询策略</h4><p>以下策略可用于存储库基础架构来解决查询.在配置<code>query-lookup-strategy</code>XML的情况下，您可以通过属性配置命名空间中的策略，也可以通过<code>queryLookupStrategy</code>Java配置中启用$ {store}存储库注解的属性来配置策略.特定数据存储可能不支持某些策略.</p>
<ul>
<li><code>CREATE</code>尝试从查询方法名称构造特定于商店的查询.一般的方法是从方法名称中删除一组已知的前缀，并解析该方法的其余部分.详细了解查询<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation" target="_blank" rel="external">创建中的</a>查询构造.</li>
<li><code>USE_DECLARED_QUERY</code>尝试找到一个声明的查询，并将抛出一个异常，以防万一找不到它.查询可以由某处的注解定义，也可以通过其他方式声明.请参阅特定商店的文档以查找该商店的可用选项.如果存储库基础架构在引导时没有找到方法的声明查询，则它将失败.</li>
<li><code>CREATE_IF_NOT_FOUND</code>（默认）组合<code>CREATE</code>和<code>USE_DECLARED_QUERY</code>.它首先查找声明的查询，如果没有找到声明的查询，它将创建一个基于名称的自定义查询.这是默认的查找策略，因此如果您没有明确配置任何内容.它允许通过方法名称快速查询定义，但也可以根据需要引入声明的查询来定制这些查询.</li>
</ul>
<h4 id="3-4-2-查询创建"><a href="#3-4-2-查询创建" class="headerlink" title="3.4.2.查询创建"></a>3.4.2.查询创建</h4><p>构建在Spring数据存储库基础架构中的查询生成器机制对于在存储库的实体上构建约束查询很有用.该机制条前缀<code>find…By</code>，<code>read…By</code>，<code>query…By</code>，<code>count…By</code>，和<code>get…By</code>从所述方法和开始分析它的其余部分.引入子句可以包含其他表达式，例如在<code>Distinct</code>要创建的查询上设置不同的标志.然而，第一个<code>By</code>作为分隔符来指示实际标准的开始.在一个非常基本的水平，你可以定义实体性条件，并与它们串联<code>And</code>和<code>Or</code>.</p>
<p>示例13.从方法名称创建查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Enables the distinct flag for the query</span></div><div class="line">  <span class="function">List&lt;Person&gt; <span class="title">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</div><div class="line">  <span class="function">List&lt;Person&gt; <span class="title">findPeopleDistinctByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Enabling ignoring case for an individual property</span></div><div class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span></span>;</div><div class="line">  <span class="comment">// Enabling ignoring case for all suitable properties</span></div><div class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Enabling static ORDER BY for a query</span></div><div class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span></span>;</div><div class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析方法的实际结果取决于创建查询的持久性存储.但是，有一些一般的事情要注意.</p>
<ul>
<li>表达式通常是可以连接的运算符的属性遍历.您可以使用组合属性表达式<code>AND</code>和<code>OR</code>.您还可以得到这样的运营商为支撑<code>Between</code>，<code>LessThan</code>，<code>GreaterThan</code>，<code>Like</code>为属性表达式.受支持的操作员可能因数据存储而异，因此请参阅参考文档的相应部分.</li>
<li>该方法解析器支持设置一个<code>IgnoreCase</code>标志个别特性（例如，<code>findByLastnameIgnoreCase(…)</code>）或对于支持忽略大小写（通常是一个类型的所有属性<code>String</code>情况下，例如，<code>findByLastnameAndFirstnameAllIgnoreCase(…)</code>）.是否支持忽略案例可能会因存储而异，因此请参阅参考文档中相关章节，了解特定于商店的查询方法.</li>
<li>您可以通过<code>OrderBy</code>在引用属性和提供排序方向（<code>Asc</code>或<code>Desc</code>）的查询方法中附加一个子句来应用静态排序.要创建支持动态排序的查询方法，请参阅<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.special-parameters" target="_blank" rel="external">特殊参数处理</a>.</li>
</ul>
<h4 id="3-4-3-属性表达式"><a href="#3-4-3-属性表达式" class="headerlink" title="3.4.3.属性表达式"></a>3.4.3.属性表达式</h4><p>属性表达式只能引用被管实体的直接属性，如前面的例子所示.在查询创建时，您已经确保已解析属性是受管域类的属性.但是，您还可以通过遍历嵌套属性来定义约束.假设一个<code>Person</code>有<code>Address</code>一个<code>ZipCode</code>.在这种情况下，方法名称为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddressZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</div></pre></td></tr></table></figure>
<p>创建属性遍历<code>x.address.zipCode</code>.解析算法首先将整个part（<code>AddressZipCode</code>）解释为属性，并使用该名称（uncapitalized）检查域类的属性.如果算法成功，则使用该属性.如果不是，则算法拆分了从右侧的驼峰部分的信号源到头部和尾部，并试图找出相应的属性，在我们的例子，<code>AddressZip</code>和<code>Code</code>.如果算法找到一个具有该头部的属性，那么它需要尾部，并从那里继续构建树，然后按照刚刚描述的方式将尾部分割.如果第一个分割不匹配，则算法将分割点移动到左（<code>Address</code>，<code>ZipCode</code>），然后继续.</p>
<p>虽然这在大多数情况下应该起作用，但算法可能会选择错误的属性.假设<code>Person</code>该类也有一个<code>addressZip</code>属性.该算法将在第一个分割轮中匹配，并且基本上选择错误的属性，最后失败（因为该类型<code>addressZip</code>可能没有<code>code</code>属性）.</p>
<p>要解决这个歧义，您可以<code>_</code>在方法名称中使用手动定义遍历点.所以我们的方法名称最终会如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddress_ZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</div></pre></td></tr></table></figure>
<p>当我们将下划线视为保留字符时，我们强烈建议遵循标准Java命名约定（即<strong>注</strong>不**使用属性名称中的下划线，而是使用骆驼案例）.</p>
<h4 id="3-4-4-特殊参数处理"><a href="#3-4-4-特殊参数处理" class="headerlink" title="3.4.4.特殊参数处理"></a>3.4.4.特殊参数处理</h4><p>要处理查询中的参数，您只需定义方法参数，如上述示例中所示.此外，基础设施将会识别某些特定类型，<code>Pageable</code>并动态<code>Sort</code>地将分页和排序应用于查询.</p>
<p>示例14.在查询方法中使用Pageable，Slice和Sort</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Slice&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</div><div class="line"></div><div class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</div><div class="line"></div><div class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>
<p>第一种方法允许您将<code>org.springframework.data.domain.Pageable</code>实例传递给查询方法，以动态地将分页添加到静态定义的查询中.A <code>Page</code>知道可用的元素和页面的总数.它通过基础设施触发计数查询来计算总数.由于这可能是昂贵的，这取决于所使用的商店，<code>Slice</code>可以用作返回.A <code>Slice</code>只知道是否有下一个<code>Slice</code>可用的，当走过较大的结果集时可能只是足够的.</p>
<p>排序选项也通过<code>Pageable</code>实例处理.如果只需要排序，只需在<code>org.springframework.data.domain.Sort</code>参数中添加一个参数即可.正如你也可以看到的，只需返回一个<code>List</code>也是可能的.在这种情况下，<code>Page</code>将不会创建构建实际实例所需的附加元数据（这反过来意味着必须不被发布的附加计数查询），而仅仅是限制查询仅查找给定范围的实体.</p>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>要查找完整查询的页面数量，您必须触发额外的计数查询.默认情况下，此查询将从您实际触发的查询派生.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="3-4-5-限制查询结果"><a href="#3-4-5-限制查询结果" class="headerlink" title="3.4.5.限制查询结果"></a>3.4.5.限制查询结果</h4><p>的查询方法的结果可以通过关键字来限制<code>first</code>或<code>top</code>，其可以被可互换地使用.可选的数值可以追加到顶部/第一个以指定要返回的最大结果大小.如果数字被省略，则假设结果大小为1.</p>
<p>示例15.使用<code>Top</code>和限制查询的结果大小<code>First</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">User <span class="title">findFirstByOrderByLastnameAsc</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function">User <span class="title">findTopByOrderByAgeDesc</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function">Page&lt;User&gt; <span class="title">queryFirst10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Slice&lt;User&gt; <span class="title">findTop3ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</div><div class="line"></div><div class="line"><span class="function">List&lt;User&gt; <span class="title">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</div><div class="line"></div><div class="line"><span class="function">List&lt;User&gt; <span class="title">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>
<p>限制表达式也支持<code>Distinct</code>关键字.此外，对于将结果集限制为一个实例的查询，支持将结果包装到一个实例中<code>Optional</code>.</p>
<p>如果将分页或切片应用于限制查询分页（以及可用页数的计算），则在限制结果中应用.</p>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>请注意，通过参数将结果限制为动态排序，<code>Sort</code>可以表示最小的“K”以及“K”最大元素的查询方法.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="3-4-6-流式查询结果"><a href="#3-4-6-流式查询结果" class="headerlink" title="3.4.6.流式查询结果"></a>3.4.6.流式查询结果</h4><p>可以通过使用Java 8 <code>Stream&lt;T&gt;</code>作为返回类型来逐步处理查询方法的结果.而不是简单地将查询结果包装在<code>Stream</code>数据存储中，特定的方法用于执行流.</p>
<p>示例16.使用Java 8流式传输查询的结果 <code>Stream&lt;T&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Query</span>(<span class="string">"select u from User u"</span>)</div><div class="line"><span class="function">Stream&lt;User&gt; <span class="title">findAllByCustomQueryAndStream</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function">Stream&lt;User&gt; <span class="title">readAllByFirstnameNotNull</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="meta">@Query</span>(<span class="string">"select u from User u"</span>)</div><div class="line"><span class="function">Stream&lt;User&gt; <span class="title">streamAllPaged</span><span class="params">(Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>在<code>Stream</code>潜在封装底层数据存储特定资源和使用后必须因此被关闭.您可以手动关闭<code>Stream</code>使用该<code>close()</code>方法或使用Java 7 try-with-resources块.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>示例17. <code>Stream&lt;T&gt;</code>在try-with-resources块中使用结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</div><div class="line">  stream.forEach(…);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>目前并不是所有的Spring数据模块都支持<code>Stream&lt;T&gt;</code>返回类型.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="3-4-7-异步查询结果"><a href="#3-4-7-异步查询结果" class="headerlink" title="3.4.7.异步查询结果"></a>3.4.7.异步查询结果</h4><p>可以使用<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html#scheduling" target="_blank" rel="external">Spring的异步方法</a>执行功能异步执行存储库查询.这意味着方法将在调用时立即返回，并且实际的查询执行将发生在已提交给Spring TaskExecutor的任务中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Async</span></div><div class="line"><span class="function">Future&lt;User&gt; <span class="title">findByFirstname</span><span class="params">(String firstname)</span></span>;       *<span class="number">1</span>*        </div><div class="line"></div><div class="line"><span class="meta">@Async</span></div><div class="line"><span class="function">CompletableFuture&lt;User&gt; <span class="title">findOneByFirstname</span><span class="params">(String firstname)</span></span>; *<span class="number">2</span>*</div><div class="line"></div><div class="line"><span class="meta">@Async</span></div><div class="line"><span class="function">ListenableFuture&lt;User&gt; <span class="title">findOneByLastname</span><span class="params">(String lastname)</span></span>;    *<span class="number">3</span>*</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><em>1</em></th>
<th>使用<code>java.util.concurrent.Future</code>的返回类型.</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>2</em></td>
<td>使用Java 8 <code>java.util.concurrent.CompletableFuture</code>作为返回类型.</td>
</tr>
<tr>
<td><em>3</em></td>
<td>使用a <code>org.springframework.util.concurrent.ListenableFuture</code>作为返回类型.</td>
</tr>
</tbody>
</table>
<h3 id="3-5-创建存储库实例"><a href="#3-5-创建存储库实例" class="headerlink" title="3.5.创建存储库实例"></a>3.5.创建存储库实例</h3><p>在本节中，您将为定义的存储库接口创建实例和bean定义.一种方法是使用支持存储库机制的每个Spring数据模块附带的Spring命名空间，尽管我们通常建议使用Java-Config样式配置.</p>
<h4 id="3-5-1-XML配置"><a href="#3-5-1-XML配置" class="headerlink" title="3.5.1.XML配置"></a>3.5.1.XML配置</h4><p>每个Spring Data模块都包含一个存储库元素，它允许您简单地定义Spring为您扫描的基础包.</p>
<p>示例18.通过XML启用Spring数据存储库</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans:beans</span> <span class="attr">xmlns:beans</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">  <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/data/jpa"</span></div><div class="line">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">    http://www.springframework.org/schema/data/jpa</div><div class="line">    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">"com.acme.repositories"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans:beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在上述示例中，指示Spring扫描<code>com.acme.repositories</code>其所有接口扩展的子包<code>Repository</code>或其子接口之一.对于发现的每个接口，基础架构注册特定<code>FactoryBean</code>于持久性技术，以创建处理查询方法调用的适当代理.每个bean都是从接口名称导出的bean名称下注册的，所以接口<code>UserRepository</code>将被注册<code>userRepository</code>.该<code>base-package</code>属性允许通配符，以便您可以定义扫描包的模式.</p>
<h5 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a>使用过滤器</h5><p>默认情况下，基础设施拾取每个接口<code>Repository</code>，扩展位于配置的基础包下面的持久性技术特定子接口，并为其创建一个bean实例.但是，您可能需要对要为其创建哪些接口bean实例进行更细粒度的控制.要做到这一点你使用<code>&lt;include-filter /&gt;</code>和<code>&lt;exclude-filter /&gt;</code>元素里面<code>&lt;repositories /&gt;</code>.语义与Spring的上下文命名空间中的元素完全相同.有关详细信息，请参阅有关这些元素的<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-scanning-filters" target="_blank" rel="external">Spring参考文档</a>.</p>
<p>例如，要将某些接口从实例化中排除为存储库，可以使用以下配置：</p>
<p>示例19.使用exclude-filter元素</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">"com.acme.repositories"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"regex"</span> <span class="attr">expression</span>=<span class="string">".*SomeRepository"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div></pre></td></tr></table></figure>
<p>此示例排除所有<code>SomeRepository</code>从实例化开始的接口.</p>
<h4 id="3-5-2-JavaConfig"><a href="#3-5-2-JavaConfig" class="headerlink" title="3.5.2.JavaConfig"></a>3.5.2.JavaConfig</h4><p>也可以使用<code>@Enable${store}Repositories</code>JavaConfig类上的特定于商店的注解触发存储库基础架构.有关Spring容器的基于Java的配置的介绍，请参阅参考文档.[ <a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#_footnote_1" target="_blank" rel="external">1</a> ]</p>
<p>启用Spring Data存储库的示例配置看起来像这样.</p>
<p>示例20.基于样本注解的存储库配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableJpaRepositories</span>(<span class="string">"com.acme.repositories"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> EntityManagerFactory <span class="title">entityManagerFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// …</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>该示例使用JPA特定的注解，您可以根据实际使用的存储模块进行更改.这同样适用于<code>EntityManagerFactory</code>bean的定义.请参阅涵盖商店特定配置的部分.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="3-5-3-独立使用"><a href="#3-5-3-独立使用" class="headerlink" title="3.5.3.独立使用"></a>3.5.3.独立使用</h4><p>您还可以使用Spring容器外部的存储库基础架构，例如在CDI环境中.您在类路径中仍然需要一些Spring库，但通常可以通过编程方式设置存储库.提供存储库支持的Spring数据模块提供了一个持久性技术特定的RepositoryFactory，可以使用如下所示的RepositoryFactory.</p>
<p>示例21.存储库工厂的独立使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RepositoryFactorySupport factory = … <span class="comment">// Instantiate factory here</span></div><div class="line">UserRepository repository = factory.getRepository(UserRepository.class);</div></pre></td></tr></table></figure>
<h3 id="3-6-Spring数据存储库的自定义实现"><a href="#3-6-Spring数据存储库的自定义实现" class="headerlink" title="3.6.Spring数据存储库的自定义实现"></a>3.6.Spring数据存储库的自定义实现</h3><p>通常有必要为几个存储库方法提供自定义实现.Spring数据存储库可以轻松地允许您提供自定义存储库代码，并将其与通用CRUD抽象和查询方法功能集成.</p>
<h4 id="3-6-1-将自定义行为添加到单个存储库"><a href="#3-6-1-将自定义行为添加到单个存储库" class="headerlink" title="3.6.1.将自定义行为添加到单个存储库"></a>3.6.1.将自定义行为添加到单个存储库</h4><p>要使用自定义功能丰富资源库，首先要定义一个接口和自定义功能的实现.使用您提供的存储库接口来扩展自定义接口.</p>
<p>示例22.自定义存储库功能的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepositoryCustom</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例23.自定义存储库功能的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepositoryCustom</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">    <span class="comment">// Your custom implementation</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>找到的类的最重要的一点是<code>Impl</code>与核心存储库接口相比的名称的后缀（见下文）.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>实现本身并不依赖于Spring Data，而且可以是一个常规的Spring bean.因此，您可以使用标准依赖注入行为来注入其他bean的引用，如a <code>JdbcTemplate</code>，参与方面等等.</p>
<p>示例24.更改您的基本存储库接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">UserRepositoryCustom</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Declare query methods here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让您的标准存储库接口扩展自定义库.这样做结合了CRUD和自定义功能，并将其提供给客户端.</p>
<h5 id="组态"><a href="#组态" class="headerlink" title="组态"></a>组态</h5><p>如果使用命名空间配置，存储库基础设施会尝试通过扫描我们找到存储库的包下的类来自动检测自定义实现.这些类需要遵循将命名空间元素的属性附加<code>repository-impl-postfix</code>到找到的存储库接口名称的命名约定.此后缀默认为<code>Impl</code>.</p>
<p>示例25.配置示例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">"com.acme.repository"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">"com.acme.repository"</span> <span class="attr">repository-impl-postfix</span>=<span class="string">"FooBar"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>第一个配置示例将尝试查找一个类<code>com.acme.repository.UserRepositoryImpl</code>作为自定义存储库实现，而第二个示例将尝试查找<code>com.acme.repository.UserRepositoryFooBar</code>.</p>
<h6 id="手动接线"><a href="#手动接线" class="headerlink" title="手动接线"></a>手动接线</h6><p>如果您的自定义实现仅使用基于注解的配置和自动布线，那么刚才显示的方法效果很好，因为它将被视为任何其他Spring bean.如果您的自定义实现bean需要特殊布线，那么您只需简单地声明该bean并将其命名为刚刚描述的约定.然后，基础设施将通过名称引用手动定义的bean定义，而不是创建一个本身.</p>
<p>示例26.自定义实现的手动接线</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">"com.acme.repository"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">id</span>=<span class="string">"userRepositoryImpl"</span> <span class="attr">class</span>=<span class="string">"…"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- further configuration --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="3-6-2-将自定义行为添加到所有存储库"><a href="#3-6-2-将自定义行为添加到所有存储库" class="headerlink" title="3.6.2.将自定义行为添加到所有存储库"></a>3.6.2.将自定义行为添加到所有存储库</h4><p>当您想将一个方法添加到所有的存储库接口时，上述方法是不可行的.要将自定义行为添加到所有存储库，您首先添加一个中间接口来声明共享行为.</p>
<p>示例27.声明定制共享行为的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NoRepositoryBean</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt;</span></div><div class="line">  <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; &#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sharedCustomMethod</span><span class="params">(ID id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，您的各个存储库接口将扩展此中间接口，而不是扩展<code>Repository</code>接口以包含声明的功能.接下来，创建扩展了持久性技术特定的存储库基类的中间接口的实现.然后，该类将用作存储库代理的自定义基类.</p>
<p>自定义库基础类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRepositoryImpl</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt;</span></div><div class="line">  <span class="keyword">extends</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">implements</span> <span class="title">MyRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; &#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EntityManager entityManager;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyRepositoryImpl</span><span class="params">(JpaEntityInformation entityInformation,</span></span></div><div class="line">                          EntityManager entityManager) &#123;</div><div class="line">    <span class="keyword">super</span>(entityInformation, entityManager);</div><div class="line"></div><div class="line">    <span class="comment">// Keep the EntityManager around to used from the newly introduced methods.</span></div><div class="line">    <span class="keyword">this</span>.entityManager = entityManager;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sharedCustomMethod</span><span class="params">(ID id)</span> </span>&#123;</div><div class="line">    <span class="comment">// implementation goes here</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>该类需要具有专门的存储库工厂实现使用的超级类的构造函数.如果存储库基类有多个构造函数，则覆盖一个<code>EntityInformation</code>加上特定于存储的基础架构对象（例如，一个<code>EntityManager</code>或一个模板类）.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Spring <code>&lt;repositories /&gt;</code>命名空间的默认行为是为所有接下来的接口提供一个实现<code>base-package</code>.这意味着如果保持当前状态，<code>MyRepository</code>Spring将创建一个实现实例.这当然是不希望的，因为它只是作为一个中介，<code>Repository</code>以及您想为每个实体定义的实际存储库接口.要排除<code>Repository</code>从被实例化为存储库实例的接口，您可以使用<code>@NoRepositoryBean</code>（如上所示）注解它，或将其移动到已配置的外部<code>base-package</code>.</p>
<p>最后一步是使Spring数据基础架构了解定制的库基类.在JavaConfig中，这是通过使用<code>repositoryBaseClass</code>注解的<code>@Enable…Repositories</code>属性来实现的：</p>
<p>示例29.使用JavaConfig配置自定义存储库基类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableJpaRepositories</span>(repositoryBaseClass = MyRepositoryImpl.class)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> </span>&#123; … &#125;</div></pre></td></tr></table></figure>
<p>相应的属性在XML命名空间中可用.</p>
<p>示例30.使用XML配置自定义存储库基类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">"com.acme.repository"</span></span></div><div class="line">     <span class="attr">base-class</span>=<span class="string">"….MyRepositoryImpl"</span> /&gt;</div></pre></td></tr></table></figure>
<h3 id="3-7-从集合根发布事件"><a href="#3-7-从集合根发布事件" class="headerlink" title="3.7.从集合根发布事件"></a>3.7.从集合根发布事件</h3><p>存储库管理的实体是聚合根.在域驱动设计应用程序中，这些聚合根通常会发布域事件.Spring Data提供了一个注解，<code>@DomainEvents</code>您可以使用聚合根的方法来使该发布尽可能简单.</p>
<p>示例31.从聚合根中暴露域事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnAggregateRoot</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@DomainEvents</span> 		*<span class="number">1</span>*</div><div class="line">    <span class="function">Collection&lt;Object&gt; <span class="title">domainEvents</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// … return events you want to get published here</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@AfterDomainEventsPublication</span>  *<span class="number">2</span>*</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callbackMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// … potentially clean up domain events list</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><em>1</em></th>
<th>使用的方法<code>@DomainEvents</code>可以返回单个事件实例或事件集合.它不能采取任何论据.</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>2</em></td>
<td>在所有事件发布之后，注解了一个方法<code>@AfterDomainEventsPublication</code>.它可以用于潜在地清理要发布的事件列表.</td>
</tr>
</tbody>
</table>
<p>每次调用Spring数据存储库的<code>save(…)</code>方法之一时，都会调用这些方法.</p>
<h3 id="3-8-Spring数据扩展"><a href="#3-8-Spring数据扩展" class="headerlink" title="3.8.Spring数据扩展"></a>3.8.Spring数据扩展</h3><p>本节介绍一组Spring数据扩展，可以在各种上下文中启用Spring数据使用.目前大部分的集成针对Spring MVC.</p>
<h4 id="3-8-1-Querydsl扩展"><a href="#3-8-1-Querydsl扩展" class="headerlink" title="3.8.1.Querydsl扩展"></a>3.8.1.Querydsl扩展</h4><p><a href="http://www.querydsl.com/" target="_blank" rel="external">Querydsl</a>是一个框架，可以通过流畅的API构建静态类型的类SQL查询.</p>
<p>几个Spring数据模块提供与Querydsl的集成<code>QueryDslPredicateExecutor</code>.</p>
<p>示例32. QueryDslPredicateExecutor接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QueryDslPredicateExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">T <span class="title">findOne</span><span class="params">(Predicate predicate)</span></span>;             *<span class="number">1</span>*</div><div class="line"></div><div class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Predicate predicate)</span></span>;   *<span class="number">2</span>*</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(Predicate predicate)</span></span>;            *<span class="number">3</span>*</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(Predicate predicate)</span></span>;        *<span class="number">4</span>*</div><div class="line"></div><div class="line">    <span class="comment">// … more functionality omitted.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><em>1</em></th>
<th>查找并返回一个匹配的实体<code>Predicate</code>.</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>2</em></td>
<td>查找并返回匹配的所有实体<code>Predicate</code>.</td>
</tr>
<tr>
<td><em>3</em></td>
<td>返回匹配的实体数<code>Predicate</code>.</td>
</tr>
<tr>
<td><em>4</em></td>
<td>如果匹配的实体<code>Predicate</code>存在则返回.</td>
</tr>
</tbody>
</table>
<p>要使用Querydsl支持，只需<code>QueryDslPredicateExecutor</code>在您的存储库接口上扩展.</p>
<p>实例33.在存储库上进行Querydsl整合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">QueryDslPredicateExecutor</span>&lt;<span class="title">User</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上使用Querydsl可以编写类型安全的查询<code>Predicate</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Predicate predicate = user.firstname.equalsIgnoreCase(<span class="string">"dave"</span>)</div><div class="line">	.and(user.lastname.startsWithIgnoreCase(<span class="string">"mathews"</span>));</div><div class="line"></div><div class="line">userRepository.findAll(predicate);</div></pre></td></tr></table></figure>
<h4 id="3-8-2-网络支持"><a href="#3-8-2-网络支持" class="headerlink" title="3.8.2.网络支持"></a>3.8.2.网络支持</h4><table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>本部分包含Spring数据Web支持的文档，因为它在1.6范围内与Spring Data Commons相同.由于新引入的支持更改了很多事情，因此我们保留了<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#web.legacy" target="_blank" rel="external">旧版Web支持中</a>前一行为的文档.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如果模块支持仓库编程模型，Spring数据模块将附带各种Web支持.Web相关的东西需要Spring MVC JAR在类路径上，其中一些甚至提供与Spring HATEOAS的集成[ <a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#_footnote_2" target="_blank" rel="external">2</a> ].通常，通过<code>@EnableSpringDataWebSupport</code>在JavaConfig配置类中使用注解来启用集成支持.</p>
<p>示例34.启用Spring Data Web支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableWebMvc</span></div><div class="line"><span class="meta">@EnableSpringDataWebSupport</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>该<code>@EnableSpringDataWebSupport</code>批注注册几个组件，我们将在一个位讨论.它还将在类路径上检测Spring HATEOAS，并注册集成组件（如果存在）.</p>
<p>或者，如果您使用XML配置，请注册<code>SpringDataWebSupport</code>或<code>HateoasAwareSpringDataWebSupport</code>作为Spring bean：</p>
<p>示例35.启用XML中的Spring Data Web支持</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.web.config.SpringDataWebConfiguration"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- If you're using Spring HATEOAS as well register this one *instead* of the former --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h5 id="基本网络支持"><a href="#基本网络支持" class="headerlink" title="基本网络支持"></a>基本网络支持</h5><p>上述配置设置将注册几个基本组件：</p>
<ul>
<li>A <code>DomainClassConverter</code>使Spring MVC能够从请求参数或路径变量解析存储库管理域类的实例.</li>
<li><code>HandlerMethodArgumentResolver</code> 实现让Spring MVC从请求参数中解析Pageable和Sort实例.</li>
</ul>
<h6 id="DomainClassConverter"><a href="#DomainClassConverter" class="headerlink" title="DomainClassConverter"></a>DomainClassConverter</h6><p>将<code>DomainClassConverter</code>让你在你的Spring MVC控制器方法签名直接使用域类型，这样就不必通过库手动查找实例：</p>
<p>示例36. Spring MVC控制器在方法签名中使用域类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">showUserForm</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> User user, Model model) </span>&#123;</div><div class="line"></div><div class="line">    model.addAttribute(<span class="string">"user"</span>, user);</div><div class="line">    <span class="keyword">return</span> <span class="string">"userForm"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>您可以看到该方法直接接收User实例，不需要进一步的查找.实例可以通过让Spring MVC首先将路径变量转换为域类型，最终通过调用<code>findOne(…)</code>注册为域类型的存储库实例来访问该实例来解决.</p>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>目前，资源库<code>CrudRepository</code>必须实施才能被发现以进行转换.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h6 id="HandlerMethodArgumentResolvers-for-Pageable和Sort"><a href="#HandlerMethodArgumentResolvers-for-Pageable和Sort" class="headerlink" title="HandlerMethodArgumentResolvers for Pageable和Sort"></a>HandlerMethodArgumentResolvers for Pageable和Sort</h6><p>上面的配置代码片段也注册了一个<code>PageableHandlerMethodArgumentResolver</code>以及一个实例<code>SortHandlerMethodArgumentResolver</code>.注册启用<code>Pageable</code>并<code>Sort</code>成为有效的控制器方法参数</p>
<p>使用Pageable作为控制器方法参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span> UserRepository repository;</div><div class="line"></div><div class="line">  <span class="meta">@RequestMapping</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">showUsers</span><span class="params">(Model model, Pageable pageable)</span> </span>&#123;</div><div class="line"></div><div class="line">    model.addAttribute(<span class="string">"users"</span>, repository.findAll(pageable));</div><div class="line">    <span class="keyword">return</span> <span class="string">"users"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此方法签名将导致Spring MVC尝试使用以下默认配置从请求参数派生一个Pageable实例：</p>
<table>
<thead>
<tr>
<th><code>page</code></th>
<th>您要检索的页面，0已编入索引并默认为0.</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size</code></td>
<td>您要检索的页面的大小，默认为20.</td>
</tr>
<tr>
<td><code>sort</code></td>
<td>应以格式排序的属性`property,property(,ASC</td>
<td>DESC)<code>.默认排序方向是上升.</code>sort<code>如果要切换路线，请使用多个参数，例如</code>?sort=firstname&amp;sort=lastname,asc`.</td>
</tr>
</tbody>
</table>
<p>要自定义此行为可扩展<code>SpringDataWebConfiguration</code>或启用HATEOAS启用的等效项，并覆盖<code>pageableResolver()</code>或<code>sortResolver()</code>方法并导入自定义配置文件，而不是使用<code>@Enable</code>-annotation.</p>
<p>如果您需要从请求中解析多个<code>Pageable</code>或<code>Sort</code>实例（例如，对于多个表），则可以使用Spring的<code>@Qualifier</code>注解来区分出来.然后请求参数必须加上前缀<code>${qualifier}_</code>.所以对于像这样的方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showUsers</span><span class="params">(Model model,</span></span></div><div class="line">      @Qualifier(<span class="string">"foo"</span>) Pageable first,</div><div class="line">      @<span class="title">Qualifier</span><span class="params">(<span class="string">"bar"</span>)</span> Pageable second) &#123; … &#125;</div></pre></td></tr></table></figure>
<p>你有填充<code>foo_page</code>和<code>bar_page</code>等.</p>
<p>该<code>Pageable</code>方法的默认值相当于一个，<code>new PageRequest(0, 20)</code>但可以使用<code>@PageableDefaults</code>参数上的<code>Pageable</code>注解进行自定义.</p>
<h5 id="超媒体支持页面"><a href="#超媒体支持页面" class="headerlink" title="超媒体支持页面"></a>超媒体支持页面</h5><p>Spring HATEOAS提供了一个表示模型类<code>PagedResources</code>，它允许<code>Page</code>使用必要的<code>Page</code>元数据丰富一个实例的内容，以及让客户端轻松浏览页面的链接.<code>PagedResources</code>通过Spring HATEOAS <code>ResourceAssembler</code>接口的实现来完成页面的转换<code>PagedResourcesAssembler</code>.</p>
<p>示例38.使用PagedResourcesAssembler作为控制器方法参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span> PersonRepository repository;</div><div class="line"></div><div class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/persons"</span>, method = RequestMethod.GET)</div><div class="line">  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,</div><div class="line">    PagedResourcesAssembler assembler) &#123;</div><div class="line"></div><div class="line">    Page&lt;Person&gt; persons = repository.findAll(pageable);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>启用如上所示的配置允许将<code>PagedResourcesAssembler</code>其用作控制器方法参数.打电话<code>toResources(…)</code>会导致以下情况：</p>
<ul>
<li>将内容的内容<code>Page</code>变成<code>PagedResources</code>实例的内容.</li>
<li>该<code>PagedResources</code>会得到一个<code>PageMetadata</code>附加填充信息形成的实例<code>Page</code>和基础<code>PageRequest</code>.</li>
<li>根据页面的状态<code>PagedResources</code>获取<code>prev</code>和<code>next</code>链接.链接将指向被调用的方法映射到的URI.添加到方法中的分页参数将匹配设置，<code>PageableHandlerMethodArgumentResolver</code>以确保以后可以解析链接.</li>
</ul>
<p>假设我们在数据库中有30个Person实例.您现在可以触发请求，您将看到类似的内容：<code>GET http://localhost:8080/persons</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123; "links" : [ &#123; "rel" : "next",</div><div class="line">                "href" : "http://localhost:8080/persons?page=1&amp;size=20 &#125;</div><div class="line">  ],</div><div class="line">  "content" : [</div><div class="line">     … // 20 Person instances rendered here</div><div class="line">  ],</div><div class="line">  "pageMetadata" : &#123;</div><div class="line">    "size" : 20,</div><div class="line">    "totalElements" : 30,</div><div class="line">    "totalPages" : 2,</div><div class="line">    "number" : 0</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>您会看到汇编程序产生了正确的URI，并且还提取了存在的默认配置，以将参数解析<code>Pageable</code>为即将到来的请求.这意味着，如果您更改该配置，链接将自动遵守更改.默认情况下，汇编程序指向被调用的控制器方法，但可以通过将自定义<code>Link</code>作为基础来定制，以构建<code>PagedResourcesAssembler.toResource(…)</code>方法重载的分页链接.</p>
<h5 id="Querydsl网络支持"><a href="#Querydsl网络支持" class="headerlink" title="Querydsl网络支持"></a>Querydsl网络支持</h5><p>对于具有<a href="http://www.querydsl.com/" target="_blank" rel="external">QueryDSL</a>集成的那些商店，可以从<code>Request</code>查询字符串中包含的属性中导出查询.</p>
<p>这意味着给定<code>User</code>前一个样本的对象一个查询字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?firstname=Dave&amp;lastname=Matthews</div></pre></td></tr></table></figure>
<p>可以解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QUser.user.firstname.eq(<span class="string">"Dave"</span>).and(QUser.user.lastname.eq(<span class="string">"Matthews"</span>))</div></pre></td></tr></table></figure>
<p>使用<code>QuerydslPredicateArgumentResolver</code>.</p>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th><code>@EnableSpringDataWebSupport</code>当类路径上找到 Querydsl时，该功能将自动启用.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>添加<code>@QuerydslPredicate</code>到方法签名将提供一个可以使用的<code>Predicate</code>，可以通过执行<code>QueryDslPredicateExecutor</code>.</p>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>类型信息通常从方法返回类型中解析出来.由于这些信息不一定与域类型相匹配，所以使用<code>root</code>属性可能是一个好主意<code>QuerydslPredicate</code>.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span> UserRepository repository;</div><div class="line"></div><div class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>, method = RequestMethod.GET)</div><div class="line">  <span class="function">String <span class="title">index</span><span class="params">(Model model, @QuerydslPredicate(root = User.class)</span> Predicate predicate,    *1*</span></div><div class="line">          Pageable pageable, @RequestParam MultiValueMap&lt;String, String&gt; parameters) &#123;</div><div class="line"></div><div class="line">    model.addAttribute(<span class="string">"users"</span>, repository.findAll(predicate, pageable));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="string">"index"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><em>1</em></th>
<th>解析查询字符串参数匹配<code>Predicate</code>的<code>User</code>.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>默认绑定如下：</p>
<ul>
<li><code>Object</code>简单的属性为<code>eq</code>.</li>
<li><code>Object</code>收集像属性一样<code>contains</code>.</li>
<li><code>Collection</code>简单的属性为<code>in</code>.</li>
</ul>
<p>这些绑定可以通过<code>bindings</code>属性<code>@QuerydslPredicate</code>或通过使用Java 8 <code>default methods</code>添加<code>QuerydslBinderCustomizer</code>到存储库接口进行定制.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt;,</span></div><div class="line">                                 <span class="title">QueryDslPredicateExecutor</span>&lt;<span class="title">User</span>&gt;,           *1*     </div><div class="line">                                 <span class="title">QuerydslBinderCustomizer</span>&lt;<span class="title">QUser</span>&gt; &#123;           *<span class="number">2</span>*    </div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(QuerydslBindings bindings, QUser user)</span> </span>&#123;</div><div class="line"></div><div class="line">    bindings.bind(user.username).first((path, value) -&gt; path.contains(value))    *<span class="number">3</span>*</div><div class="line">    bindings.bind(String.class)</div><div class="line">      .first((StringPath path, String value) -&gt; path.containsIgnoreCase(value)); *<span class="number">4</span>*</div><div class="line">    bindings.excluding(user.password);                                           *<span class="number">5</span>*</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><em>1</em></th>
<th><code>QueryDslPredicateExecutor</code>提供对特定查找器方法的访问<code>Predicate</code>.</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>2</em></td>
<td><code>QuerydslBinderCustomizer</code>在存储库接口上定义将自动拾取和快捷方式<code>@QuerydslPredicate(bindings=…)</code>.</td>
</tr>
<tr>
<td><em>3</em></td>
<td>将<code>username</code>属性的绑定定义为简单的包含绑定.</td>
</tr>
<tr>
<td><em>4</em></td>
<td>将属性的默认绑定定义<code>String</code>为不区分大小写的包含匹配.</td>
</tr>
<tr>
<td><em>5</em></td>
<td>从解决方案中排除<em>密码</em>属性<code>Predicate</code>.</td>
</tr>
</tbody>
</table>
<h4 id="3-8-3-存储库populator"><a href="#3-8-3-存储库populator" class="headerlink" title="3.8.3.存储库populator"></a>3.8.3.存储库populator</h4><p>如果您使用Spring JDBC模块，您可能熟悉<code>DataSource</code>使用SQL脚本填充的支持.尽管它不使用SQL作为数据定义语言，但存储库级别可以使用类似的抽象，因为它必须与存储无关.因此，populator支持XML（通过Spring的OXM抽象）和JSON（通过Jackson）来定义用于填充存储库的数据.</p>
<p>假设你有一个<code>data.json</code>包含以下内容的文件：</p>
<p>示例39. JSON中定义的数据</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[ &#123; <span class="attr">"_class"</span> : <span class="string">"com.acme.Person"</span>,</div><div class="line"> <span class="attr">"firstname"</span> : <span class="string">"Dave"</span>,</div><div class="line">  <span class="attr">"lastname"</span> : <span class="string">"Matthews"</span> &#125;,</div><div class="line">  &#123; <span class="attr">"_class"</span> : <span class="string">"com.acme.Person"</span>,</div><div class="line"> <span class="attr">"firstname"</span> : <span class="string">"Carter"</span>,</div><div class="line">  <span class="attr">"lastname"</span> : <span class="string">"Beauford"</span> &#125; ]</div></pre></td></tr></table></figure>
<p>您可以使用Spring Data Commons中提供的存储库命名空间的populator元素轻松填充您的存储库.要将上述数据填充到您的PersonRepository，请执行以下操作：</p>
<p>示例40.声明Jackson存储库填充程序</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">  <span class="attr">xmlns:repository</span>=<span class="string">"http://www.springframework.org/schema/data/repository"</span></div><div class="line">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">    http://www.springframework.org/schema/data/repository</div><div class="line">    http://www.springframework.org/schema/data/repository/spring-repository.xsd"&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">repository:jackson2-populator</span> <span class="attr">locations</span>=<span class="string">"classpath:data.json"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>该声明导致该<code>data.json</code>文件通过Jackson读取和反序列化<code>ObjectMapper</code>.</p>
<p>JSON对象将被解组的类型将通过检查<code>_class</code>JSON文档的属性来确定.基础设施将最终选择适当的存储库来处理刚被反序列化的对象.</p>
<p>要使用XML来定义数据库，应该使用这些<code>unmarshaller-populator</code>元素来填充这些数据库.您可以将其配置为使用Spring OXM为您提供的一种XML编组器选项.有关详细信息，请参阅<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/oxm.html" target="_blank" rel="external">Spring参考文档</a>.</p>
<p>示例41.声明一个解组的存储库填充程序（使用JAXB）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">  <span class="attr">xmlns:repository</span>=<span class="string">"http://www.springframework.org/schema/data/repository"</span></div><div class="line">  <span class="attr">xmlns:oxm</span>=<span class="string">"http://www.springframework.org/schema/oxm"</span></div><div class="line">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">    http://www.springframework.org/schema/data/repository</div><div class="line">    http://www.springframework.org/schema/data/repository/spring-repository.xsd</div><div class="line">    http://www.springframework.org/schema/oxm</div><div class="line">    http://www.springframework.org/schema/oxm/spring-oxm.xsd"&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">repository:unmarshaller-populator</span> <span class="attr">locations</span>=<span class="string">"classpath:data.json"</span></span></div><div class="line">    <span class="attr">unmarshaller-ref</span>=<span class="string">"unmarshaller"</span> /&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">oxm:jaxb2-marshaller</span> <span class="attr">contextPath</span>=<span class="string">"com.acme"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="3-8-4-传统网络支持"><a href="#3-8-4-传统网络支持" class="headerlink" title="3.8.4.传统网络支持"></a>3.8.4.传统网络支持</h4><h5 id="Spring-MVC的域类Web绑定"><a href="#Spring-MVC的域类Web绑定" class="headerlink" title="Spring MVC的域类Web绑定"></a>Spring MVC的域类Web绑定</h5><p>鉴于您正在开发Spring MVC Web应用程序，您通常必须从URL解析域类ID.默认情况下，您的任务是将请求参数或URL部分转换为域类，将其转交到下面的层，然后直接对实体执行业务逻辑.这看起来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</div><div class="line">    Assert.notNull(repository, <span class="string">"Repository must not be null!"</span>);</div><div class="line">    <span class="keyword">this</span>.userRepository = userRepository;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">showUserForm</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id, Model model) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Do null check for id</span></div><div class="line">    User user = userRepository.findOne(id);</div><div class="line">    <span class="comment">// Do null check for user</span></div><div class="line"></div><div class="line">    model.addAttribute(<span class="string">"user"</span>, user);</div><div class="line">    <span class="keyword">return</span> <span class="string">"user"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，您声明每个控制器的存储库依赖关系，以分别查找由控制器或存储库管理的实体.查看实体也是样板，因为它总是<code>findOne(…)</code>打电话.幸运的是，Spring提供了注册自定义组件的方法，允许在<code>String</code>值与任意类型之间进行转换.</p>
<h6 id="属性编辑器"><a href="#属性编辑器" class="headerlink" title="属性编辑器"></a>属性编辑器</h6><p>对于3.0之前的Spring版本<code>PropertyEditors</code>，必须使用简单的Java .要与之进行集成，Spring Data提供了一个<code>DomainClassPropertyEditorRegistrar</code>查找所有在其中注册的Spring数据存储库<code>ApplicationContext</code>并注册<code>PropertyEditor</code>管理域类的自定义.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webBindingInitializer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"….web.bind.support.ConfigurableWebBindingInitializer"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"propertyEditorRegistrars"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar"</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果您已经配置了上述示例中的Spring MVC，则可以按如下方式配置控制器，从而减少了大量杂乱和样板.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">showUserForm</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> User user, Model model) </span>&#123;</div><div class="line"></div><div class="line">    model.addAttribute(<span class="string">"user"</span>, user);</div><div class="line">    <span class="keyword">return</span> <span class="string">"userForm"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-按示例查询"><a href="#4-按示例查询" class="headerlink" title="4.按示例查询"></a>4.按示例查询</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1.介绍"></a>4.1.介绍</h3><p>本章将为您提供“按示例查询”的介绍，并说明如何使用示例.</p>
<p>示例查询（QBE）是一种用户友好的查询技术，具有简单的接口.它允许动态查询创建，并且不需要编写包含字段名称的查询.实际上，按示例查询，根本不需要使用商店特定的查询语言编写查询.</p>
<h3 id="4-2-用法"><a href="#4-2-用法" class="headerlink" title="4.2.用法"></a>4.2.用法</h3><p>由示例API查询由三部分组成：</p>
<ul>
<li>Probe：这是具有填充字段的域对象的实际示例.</li>
<li><code>ExampleMatcher</code>：<code>ExampleMatcher</code>载有关于如何匹配特定字段的详细信息.它可以重复使用在多个示例.</li>
<li><code>Example</code>：<code>Example</code>由探针和<code>ExampleMatcher</code>.它用于创建查询.</li>
</ul>
<p>按示例查询适用于多个用例，但也有限制：</p>
<p><strong>何时使用</strong></p>
<ul>
<li>使用一组静态或动态约束来查询数据存储</li>
<li>频繁重构域对象，而不用担心破坏现有查询</li>
<li>独立于底层数据存储API</li>
</ul>
<p><strong>限制</strong></p>
<ul>
<li>不支持嵌套/分组的属性约束，如 <code>firstname = ?0 or (firstname = ?1 and lastname = ?2)</code></li>
<li>只支持对字符串进行启动/包含/结束/正则表达式匹配以及其他属性类型的精确匹配</li>
</ul>
<p>在开始使用按示例查询之前，您需要有一个域对象.要开始，只需为您的存储库创建一个接口：</p>
<p>示例42. Sample Person对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Id</span></div><div class="line">  <span class="keyword">private</span> String id;</div><div class="line">  <span class="keyword">private</span> String firstname;</div><div class="line">  <span class="keyword">private</span> String lastname;</div><div class="line">  <span class="keyword">private</span> Address address;</div><div class="line"></div><div class="line">  <span class="comment">// … getters and setters omitted</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个简单的域对象.你可以用它创建一个<code>Example</code>.默认情况下，具有<code>null</code>值的字段将被忽略，字符串将使用存储特定的默认值进行匹配.示例可以通过使用<code>of</code>工厂方法或使用来构建<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#query-by-example.matcher" target="_blank" rel="external"><code>ExampleMatcher</code></a>.<code>Example</code>是不可变的</p>
<p>示例43.简单示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person person = <span class="keyword">new</span> Person();                     *<span class="number">1</span>*    </div><div class="line">person.setFirstname(<span class="string">"Dave"</span>);                      *<span class="number">2</span>*    </div><div class="line"></div><div class="line">Example&lt;Person&gt; example = Example.of(person);      *<span class="number">3</span>*</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><em>1</em></th>
<th>创建域对象的新实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>2</em></td>
<td>设置要查询的属性</td>
</tr>
<tr>
<td><em>3</em></td>
<td>创建 <code>Example</code></td>
</tr>
</tbody>
</table>
<p>理想情况下，使用存储库执行示例.为此，让您的存储库接口扩展<code>QueryByExampleExecutor&lt;T&gt;</code>.以下是该<code>QueryByExampleExecutor</code>接口的摘录：</p>
<p>例44 <code>QueryByExampleExecutor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QueryByExampleExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">findOne</span><span class="params">(Example&lt;S&gt; example)</span></span>;</div><div class="line"></div><div class="line">  &lt;S extends T&gt; <span class="function">Iterable&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// … more functionality omitted.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>您可以在下面阅读更多关于<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#query-by-example.execution" target="_blank" rel="external">按示例执行</a>查询.</p>
<h3 id="4-3-示例匹配器"><a href="#4-3-示例匹配器" class="headerlink" title="4.3.示例匹配器"></a>4.3.示例匹配器</h3><p>示例不限于默认设置.您可以使用以下命令为字符串匹配，空处理和特定于属性的设置指定自己的默认值<code>ExampleMatcher</code>.</p>
<p>示例45.具有自定义匹配的示例匹配器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Person person = <span class="keyword">new</span> Person();                  *<span class="number">1</span>*        </div><div class="line">person.setFirstname(<span class="string">"Dave"</span>);                    *<span class="number">2</span>*       </div><div class="line"></div><div class="line">ExampleMatcher matcher = ExampleMatcher.matching()     *<span class="number">3</span>*</div><div class="line">  .withIgnorePaths(<span class="string">"lastname"</span>)                       *<span class="number">4</span>*  </div><div class="line">  .withIncludeNullValues()                             *<span class="number">5</span>*</div><div class="line">  .withStringMatcherEnding();                          *<span class="number">6</span>*</div><div class="line"></div><div class="line">Example&lt;Person&gt; example = Example.of(person, matcher); *<span class="number">7</span>*</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><em>1</em></th>
<th>创建域对象的新实例.</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>2</em></td>
<td>设置属性.</td>
</tr>
<tr>
<td><em>3</em></td>
<td>创建一个<code>ExampleMatcher</code>期望所有值匹配.即使没有进一步的配置，在这个阶段也可以使用.</td>
</tr>
<tr>
<td><em>4</em></td>
<td>构造一个新的<code>ExampleMatcher</code>来忽略属性路径<code>lastname</code>.</td>
</tr>
<tr>
<td><em>5</em></td>
<td>构造一个新的<code>ExampleMatcher</code>来忽略属性路径<code>lastname</code>并包含空值.</td>
</tr>
<tr>
<td><em>6</em></td>
<td>构造一个新<code>ExampleMatcher</code>的忽略属性路径<code>lastname</code>，包含空值，并使用perform suffix字符串匹配.</td>
</tr>
<tr>
<td><em>7</em></td>
<td><code>Example</code>根据域对象和配置创建新的<code>ExampleMatcher</code>.</td>
</tr>
</tbody>
</table>
<p>默认情况下，<code>ExampleMatcher</code>将期望探针上设置的所有值都匹配.如果要获取匹配任何隐含定义的谓词的结果，请使用<code>ExampleMatcher.matchingAny()</code>.</p>
<p>您可以为各个属性指定行为（例如嵌套属性的“firstname”和“lastname”，“address.city”）.您可以使用匹配的选项和区分大小写来调整它.</p>
<p>示例46.配置匹配器选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ExampleMatcher matcher = ExampleMatcher.matching()</div><div class="line">  .withMatcher(<span class="string">"firstname"</span>, endsWith())</div><div class="line">  .withMatcher(<span class="string">"lastname"</span>, startsWith().ignoreCase());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置匹配器选项的另一种风格是使用Java 8 lambdas.这种方法是一个回调，要求实现者修改匹配器.由于配置选项保持在匹配器实例中，因此不需要返回匹配器.</p>
<p>示例47.使用lambdas配置匹配器选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ExampleMatcher matcher = ExampleMatcher.matching()</div><div class="line">  .withMatcher(<span class="string">"firstname"</span>, match -&gt; match.endsWith())</div><div class="line">  .withMatcher(<span class="string">"firstname"</span>, match -&gt; match.startsWith());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>Example</code>使用合并的配置视图创建的查询.默认匹配设置可以在<code>ExampleMatcher</code>级别设置，而个别设置可以应用于特定的属性路径.设置的设置<code>ExampleMatcher</code>由属性路径设置继承，除非它们被明确定义.属性修补程序上的设置的优先级高于默认设置.</p>
<table>
<thead>
<tr>
<th>设置</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>空操作</td>
<td><code>ExampleMatcher</code></td>
</tr>
<tr>
<td>字符串匹配</td>
<td><code>ExampleMatcher</code> 和物业路径</td>
</tr>
<tr>
<td>忽略属性</td>
<td>物业路径</td>
</tr>
<tr>
<td>区分大小写</td>
<td><code>ExampleMatcher</code> 和物业路径</td>
</tr>
<tr>
<td>价值转型</td>
<td>物业路径</td>
</tr>
</tbody>
</table>
<h2 id="5-审计"><a href="#5-审计" class="headerlink" title="5.审计"></a>5.审计</h2><h3 id="5-1-基本"><a href="#5-1-基本" class="headerlink" title="5.1.基本"></a>5.1.基本</h3><p>Spring Data提供了复杂的支持，以透明地跟踪创建或更改实体的人员以及发生的时间点.为了从该功能中受益，您必须为实体类配备审计元数据，该元数据可以使用注解或实现一个接口进行定义.</p>
<h4 id="5-1-1-基于注解的审计元数据"><a href="#5-1-1-基于注解的审计元数据" class="headerlink" title="5.1.1.基于注解的审计元数据"></a>5.1.1.基于注解的审计元数据</h4><p>我们提供<code>@CreatedBy</code>，<code>@LastModifiedBy</code>捕捉谁创建或修改的实体以及用户<code>@CreatedDate</code>和<code>@LastModifiedDate</code>捕捉一次发生这种情况的地步.</p>
<p>实例48.经审计的实体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@CreatedBy</span></div><div class="line">  <span class="keyword">private</span> User user;</div><div class="line"></div><div class="line">  <span class="meta">@CreatedDate</span></div><div class="line">  <span class="keyword">private</span> DateTime createdDate;</div><div class="line"></div><div class="line">  <span class="comment">// … further properties omitted</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>您可以看到，可以选择性地应用注解，具体取决于您要捕获的信息.对于捕获时间点的注解可以用于JodaTimes <code>DateTime</code>，旧Java <code>Date</code>和<code>Calendar</code>JDK8日期/时间类型以及<code>long</code>/的类型的属性<code>Long</code>.</p>
<h4 id="5-1-2-基于接口的审计元数据"><a href="#5-1-2-基于接口的审计元数据" class="headerlink" title="5.1.2.基于接口的审计元数据"></a>5.1.2.基于接口的审计元数据</h4><p>如果您不想使用注解来定义审核元数据，则可以让您的域类实现该<code>Auditable</code>接口.它暴露了所有审核属性的setter方法.</p>
<p>还有一个方便的基类<code>AbstractAuditable</code>，您可以扩展，以避免手动实现接口方法的需要.请注意，这增加了您的域类与Spring数据的耦合，这可能是您想要避免的.通常，基于注解的定义审计元数据的方式是首选的，因为它具有较少的侵入性和更灵活性.</p>
<h4 id="5-1-3-AuditorAware"><a href="#5-1-3-AuditorAware" class="headerlink" title="5.1.3.AuditorAware"></a>5.1.3.AuditorAware</h4><p>如果您使用任何一个<code>@CreatedBy</code>或者<code>@LastModifiedBy</code>，审计基础设施需要了解当前的主体.为此，我们提供了一个<code>AuditorAware&lt;T&gt;</code>SPI接口，您必须实现该接口来告知基础架构当前用户或系统与应用程序交互的情况.通用类型<code>T</code>定义了使用<code>@CreatedBy</code>或<code>@LastModifiedBy</code>必须注解的属性类型.</p>
<p>以下是使用Spring Security <code>Authentication</code>对象的接口示例实现：</p>
<p>示例49.基于Spring Security的AuditorAware的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringSecurityAuditorAware</span> <span class="keyword">implements</span> <span class="title">AuditorAware</span>&lt;<span class="title">User</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getCurrentAuditor</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (authentication == <span class="keyword">null</span> || !authentication.isAuthenticated()) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ((MyUserDetails) authentication.getPrincipal()).getUser();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该实现是访问<code>Authentication</code>Spring Security提供的对象，并查找<code>UserDetails</code>您在实现中创建的自定义实例<code>UserDetailsService</code>.我们在这里假设您通过该<code>UserDetails</code>实现暴露域用户，但您也可以根据<code>Authentication</code>发现从任何地方查找.</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="附录A：命名空间参考"><a href="#附录A：命名空间参考" class="headerlink" title="附录A：命名空间参考"></a>附录A：命名空间参考</h2><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a><repositories>元素</repositories></h3><p>该<code>&lt;repositories /&gt;</code>元素触发了Spring Data存储库基础结构的设置.最重要的属性是<code>base-package</code>定义要扫描Spring数据存储库接口的包.[ <a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#_footnote_3" target="_blank" rel="external">3</a> ]</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>base-package</code></td>
<td>定义用于在自动检测模式下扩展*存储库（实际接口由特定的Spring数据模块确定）的存储库接口进行扫描的软件包.所配置的软件包以下的所有软件包也将被扫描.通配符是允许的.</td>
</tr>
<tr>
<td><code>repository-impl-postfix</code></td>
<td>定义后缀自动检测自定义存储库实现.其名称以配置的后缀结尾的类将被视为候选.默认为<code>Impl</code>.</td>
</tr>
<tr>
<td><code>query-lookup-strategy</code></td>
<td>确定用于创建查找器查询的策略.有关详细信息，请参阅<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-lookup-strategies" target="_blank" rel="external">查询查询策略</a>.默认为<code>create-if-not-found</code>.</td>
</tr>
<tr>
<td><code>named-queries-location</code></td>
<td>定义查找包含外部定义查询的“属性”文件的位置.</td>
</tr>
<tr>
<td><code>consider-nested-repositories</code></td>
<td>控制是否应考虑嵌套的存储库接口定义.默认为<code>false</code>.</td>
</tr>
</tbody>
</table>
<h2 id="附录B：Populators命名空间参考"><a href="#附录B：Populators命名空间参考" class="headerlink" title="附录B：Populators命名空间参考"></a>附录B：Populators命名空间参考</h2><h3 id="元素-1"><a href="#元素-1" class="headerlink" title="元素"></a><populator>元素</populator></h3><p>该<code>&lt;populator /&gt;</code>元素允许通过Spring数据库基础架构填充数据存储.[ <a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#_footnote_4" target="_blank" rel="external">4</a> ]</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>locations</code></td>
<td>在哪里可以找到从存储库读取对象的文件.</td>
</tr>
</tbody>
</table>
<h2 id="附录C：存储库查询关键字"><a href="#附录C：存储库查询关键字" class="headerlink" title="附录C：存储库查询关键字"></a>附录C：存储库查询关键字</h2><h3 id="支持的查询关键字"><a href="#支持的查询关键字" class="headerlink" title="支持的查询关键字"></a>支持的查询关键字</h3><p>下表列出了Spring数据库查询推导机制通常支持的关键字.但是，请查阅特定于商店的文档，了解支持的关键字的确切列表，因为某些商店中可能不支持这些列表.</p>
<table>
<thead>
<tr>
<th>逻辑关键字</th>
<th>关键词表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AND</code></td>
<td><code>And</code></td>
</tr>
<tr>
<td><code>OR</code></td>
<td><code>Or</code></td>
</tr>
<tr>
<td><code>AFTER</code></td>
<td><code>After</code>， <code>IsAfter</code></td>
</tr>
<tr>
<td><code>BEFORE</code></td>
<td><code>Before</code>， <code>IsBefore</code></td>
</tr>
<tr>
<td><code>CONTAINING</code></td>
<td><code>Containing</code>，<code>IsContaining</code>，<code>Contains</code></td>
</tr>
<tr>
<td><code>BETWEEN</code></td>
<td><code>Between</code>， <code>IsBetween</code></td>
</tr>
<tr>
<td><code>ENDING_WITH</code></td>
<td><code>EndingWith</code>，<code>IsEndingWith</code>，<code>EndsWith</code></td>
</tr>
<tr>
<td><code>EXISTS</code></td>
<td><code>Exists</code></td>
</tr>
<tr>
<td><code>FALSE</code></td>
<td><code>False</code>， <code>IsFalse</code></td>
</tr>
<tr>
<td><code>GREATER_THAN</code></td>
<td><code>GreaterThan</code>， <code>IsGreaterThan</code></td>
</tr>
<tr>
<td><code>GREATER_THAN_EQUALS</code></td>
<td><code>GreaterThanEqual</code>， <code>IsGreaterThanEqual</code></td>
</tr>
<tr>
<td><code>IN</code></td>
<td><code>In</code>， <code>IsIn</code></td>
</tr>
<tr>
<td><code>IS</code></td>
<td><code>Is</code>，<code>Equals</code>（或没有关键词）</td>
</tr>
<tr>
<td><code>IS_NOT_NULL</code></td>
<td><code>NotNull</code>， <code>IsNotNull</code></td>
</tr>
<tr>
<td><code>IS_NULL</code></td>
<td><code>Null</code>， <code>IsNull</code></td>
</tr>
<tr>
<td><code>LESS_THAN</code></td>
<td><code>LessThan</code>， <code>IsLessThan</code></td>
</tr>
<tr>
<td><code>LESS_THAN_EQUAL</code></td>
<td><code>LessThanEqual</code>， <code>IsLessThanEqual</code></td>
</tr>
<tr>
<td><code>LIKE</code></td>
<td><code>Like</code>， <code>IsLike</code></td>
</tr>
<tr>
<td><code>NEAR</code></td>
<td><code>Near</code>， <code>IsNear</code></td>
</tr>
<tr>
<td><code>NOT</code></td>
<td><code>Not</code>， <code>IsNot</code></td>
</tr>
<tr>
<td><code>NOT_IN</code></td>
<td><code>NotIn</code>， <code>IsNotIn</code></td>
</tr>
<tr>
<td><code>NOT_LIKE</code></td>
<td><code>NotLike</code>， <code>IsNotLike</code></td>
</tr>
<tr>
<td><code>REGEX</code></td>
<td><code>Regex</code>，<code>MatchesRegex</code>，<code>Matches</code></td>
</tr>
<tr>
<td><code>STARTING_WITH</code></td>
<td><code>StartingWith</code>，<code>IsStartingWith</code>，<code>StartsWith</code></td>
</tr>
<tr>
<td><code>TRUE</code></td>
<td><code>True</code>， <code>IsTrue</code></td>
</tr>
<tr>
<td><code>WITHIN</code></td>
<td><code>Within</code>， <code>IsWithin</code></td>
</tr>
</tbody>
</table>
<h2 id="附录D：存储库查询返回类型"><a href="#附录D：存储库查询返回类型" class="headerlink" title="附录D：存储库查询返回类型"></a>附录D：存储库查询返回类型</h2><h3 id="支持的查询返回类型"><a href="#支持的查询返回类型" class="headerlink" title="支持的查询返回类型"></a>支持的查询返回类型</h3><p>下表列出了Spring Data仓库通常支持的返回类型.但是，请查阅特定于商店的文档，以获取支持的返回类型的确切列表，因为某些商店中可能不支持这些列表.</p>
<table>
<thead>
<tr>
<th><strong>注</strong></th>
<th>地理空间类型，如（<code>GeoResult</code>，<code>GeoResults</code>，<code>GeoPage</code>）只适用于支持地理空间查询的数据存储.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td>不表示返回值.</td>
</tr>
<tr>
<td>基元</td>
<td>Java原语.</td>
</tr>
<tr>
<td>包装类型</td>
<td>Java包装器类型.</td>
</tr>
<tr>
<td><code>T</code></td>
<td>一个独特的实体.期望查询方法最多返回一个结果.如果没有找到结果<code>null</code>返回.多个结果将触发<code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td><code>Iterator&lt;T&gt;</code></td>
<td>的<code>Iterator</code>.</td>
</tr>
<tr>
<td><code>Collection&lt;T&gt;</code></td>
<td>一<code>Collection</code>.</td>
</tr>
<tr>
<td><code>List&lt;T&gt;</code></td>
<td>一<code>List</code>.</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt;</code></td>
<td>Java 8或Guava <code>Optional</code>.期望查询方法最多返回一个结果.如果没有找到<code>Optional.empty()</code>/ <code>Optional.absent()</code>返回结果.多个结果将触发<code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td><code>Option&lt;T&gt;</code></td>
<td>Scala或JavaSlang <code>Option</code>类型.与<code>Optional</code>上述Java 8相似的行为.</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td>Java 8 <code>Stream</code>.</td>
</tr>
<tr>
<td><code>Future&lt;T&gt;</code></td>
<td>一<code>Future</code>.期待使用<code>@Async</code>注解的方法，并且需要启用Spring的异步方法执行功能.</td>
</tr>
<tr>
<td><code>CompletableFuture&lt;T&gt;</code></td>
<td>Java 8 <code>CompletableFuture</code>.期待使用<code>@Async</code>注解的方法，并且需要启用Spring的异步方法执行功能.</td>
</tr>
<tr>
<td><code>ListenableFuture</code></td>
<td>一<code>org.springframework.util.concurrent.ListenableFuture</code>.期待使用<code>@Async</code>注解的方法，并且需要启用Spring的异步方法执行功能.</td>
</tr>
<tr>
<td><code>Slice</code></td>
<td>大小的数据块与信息是否有更多的数据可用.需要一个<code>Pageable</code>方法参数.</td>
</tr>
<tr>
<td><code>Page&lt;T&gt;</code></td>
<td>A <code>Slice</code>附加信息，例如总结果数.需要一个<code>Pageable</code>方法参数.</td>
</tr>
<tr>
<td><code>GeoResult&lt;T&gt;</code></td>
<td>带有附加信息的结果条目，例如到参考位置的距离.</td>
</tr>
<tr>
<td><code>GeoResults&lt;T&gt;</code></td>
<td>的列表<code>GeoResult&lt;T&gt;</code>与其他信息，到参考位置例如平均距离.</td>
</tr>
<tr>
<td><code>GeoPage&lt;T&gt;</code></td>
<td>甲<code>Page</code>带<code>GeoResult&lt;T&gt;</code>，例如平均距离的参考位置.</td>
</tr>
</tbody>
</table>
<hr>
<p><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#_footnoteref_1" target="_blank" rel="external">1</a>.<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-java" target="_blank" rel="external">JavaConfig在Spring参考文档中</a></p>
<p><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#_footnoteref_2" target="_blank" rel="external">2</a>.SPRINGHATEOAS - <a href="https://github.com/SpringSource/spring-hateoas" target="_blank" rel="external">https://github.com/SpringSource/spring-hateoas</a></p>
<p><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#_footnoteref_3" target="_blank" rel="external">3</a>.请参阅<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.create-instances.spring" target="_blank" rel="external">XML配置</a></p>
<p><a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#_footnoteref_4" target="_blank" rel="external">4</a>.请参阅<a href="http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.create-instances.spring" target="_blank" rel="external">XML配置</a></p>
<p>版本1.13.4.RELEASE<br>最后更新2017-06-08 10:35:34 MESZ</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://og0sybnix.bkt.clouddn.com/wechat-qcode.png" alt="知秋 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring-Data-Commons/" rel="tag">#Spring Data Commons</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/27/一个轻量级分布式 RPC 框架 下/" rel="next" title="一个轻量级分布式 RPC 框架  下">
                <i class="fa fa-chevron-left"></i> 一个轻量级分布式 RPC 框架  下
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/14/谷歌开发工具文档/" rel="prev" title="谷歌开发工具文档">
                谷歌开发工具文档 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/06/09/Spring Data Commons - 参考文档/"
           data-title="Spring Data Commons - 中文参考文档" data-url="https://muyinchen.github.io/2017/06/09/Spring Data Commons - 参考文档/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://og0sybnix.bkt.clouddn.com/18213496.jpg"
               alt="知秋" />
          <p class="site-author-name" itemprop="name">知秋</p>
          <p class="site-description motion-element" itemprop="description">只记空山，只念新雨</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">70</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/lsgqjh" title="小舒哥" target="_blank">小舒哥</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Data-Commons-中文参考文档"><span class="nav-number">1.</span> <span class="nav-text">Spring Data Commons - 中文参考文档</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">2.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#项目元数据"><span class="nav-number">2.1.</span> <span class="nav-text">项目元数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文献"><span class="nav-number">3.</span> <span class="nav-text">参考文献</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#依赖关系"><span class="nav-number">3.1.</span> <span class="nav-text">依赖关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-使用Spring-Boot进行依赖管理"><span class="nav-number">3.1.1.</span> <span class="nav-text">2.1.使用Spring Boot进行依赖管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Spring框架"><span class="nav-number">3.1.2.</span> <span class="nav-text">2.2.Spring框架</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-使用Spring数据存储库"><span class="nav-number">3.2.</span> <span class="nav-text">3.使用Spring数据存储库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-核心概念"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.1.核心概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-查询方式"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.查询方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-定义存储库接口"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.3.定义存储库接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-微调存储库定义"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">3.3.1.微调存储库定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-使用多个Spring数据模块的存储库"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">3.3.2.使用多个Spring数据模块的存储库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-定义查询方法"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.4.定义查询方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-查询查询策略"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">3.4.1.查询查询策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-查询创建"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">3.4.2.查询创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-属性表达式"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">3.4.3.属性表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-特殊参数处理"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">3.4.4.特殊参数处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-限制查询结果"><span class="nav-number">3.2.4.5.</span> <span class="nav-text">3.4.5.限制查询结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-流式查询结果"><span class="nav-number">3.2.4.6.</span> <span class="nav-text">3.4.6.流式查询结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-异步查询结果"><span class="nav-number">3.2.4.7.</span> <span class="nav-text">3.4.7.异步查询结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-创建存储库实例"><span class="nav-number">3.2.5.</span> <span class="nav-text">3.5.创建存储库实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-XML配置"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">3.5.1.XML配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用过滤器"><span class="nav-number">3.2.5.1.1.</span> <span class="nav-text">使用过滤器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-JavaConfig"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">3.5.2.JavaConfig</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-独立使用"><span class="nav-number">3.2.5.3.</span> <span class="nav-text">3.5.3.独立使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Spring数据存储库的自定义实现"><span class="nav-number">3.2.6.</span> <span class="nav-text">3.6.Spring数据存储库的自定义实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-将自定义行为添加到单个存储库"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">3.6.1.将自定义行为添加到单个存储库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#组态"><span class="nav-number">3.2.6.1.1.</span> <span class="nav-text">组态</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#手动接线"><span class="nav-number">3.2.6.1.1.1.</span> <span class="nav-text">手动接线</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-将自定义行为添加到所有存储库"><span class="nav-number">3.2.6.2.</span> <span class="nav-text">3.6.2.将自定义行为添加到所有存储库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-从集合根发布事件"><span class="nav-number">3.2.7.</span> <span class="nav-text">3.7.从集合根发布事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-Spring数据扩展"><span class="nav-number">3.2.8.</span> <span class="nav-text">3.8.Spring数据扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-1-Querydsl扩展"><span class="nav-number">3.2.8.1.</span> <span class="nav-text">3.8.1.Querydsl扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-2-网络支持"><span class="nav-number">3.2.8.2.</span> <span class="nav-text">3.8.2.网络支持</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本网络支持"><span class="nav-number">3.2.8.2.1.</span> <span class="nav-text">基本网络支持</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#DomainClassConverter"><span class="nav-number">3.2.8.2.1.1.</span> <span class="nav-text">DomainClassConverter</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HandlerMethodArgumentResolvers-for-Pageable和Sort"><span class="nav-number">3.2.8.2.1.2.</span> <span class="nav-text">HandlerMethodArgumentResolvers for Pageable和Sort</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#超媒体支持页面"><span class="nav-number">3.2.8.2.2.</span> <span class="nav-text">超媒体支持页面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Querydsl网络支持"><span class="nav-number">3.2.8.2.3.</span> <span class="nav-text">Querydsl网络支持</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-3-存储库populator"><span class="nav-number">3.2.8.3.</span> <span class="nav-text">3.8.3.存储库populator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-4-传统网络支持"><span class="nav-number">3.2.8.4.</span> <span class="nav-text">3.8.4.传统网络支持</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-MVC的域类Web绑定"><span class="nav-number">3.2.8.4.1.</span> <span class="nav-text">Spring MVC的域类Web绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#属性编辑器"><span class="nav-number">3.2.8.4.1.1.</span> <span class="nav-text">属性编辑器</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-按示例查询"><span class="nav-number">3.3.</span> <span class="nav-text">4.按示例查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-介绍"><span class="nav-number">3.3.1.</span> <span class="nav-text">4.1.介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-用法"><span class="nav-number">3.3.2.</span> <span class="nav-text">4.2.用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-示例匹配器"><span class="nav-number">3.3.3.</span> <span class="nav-text">4.3.示例匹配器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-审计"><span class="nav-number">3.4.</span> <span class="nav-text">5.审计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-基本"><span class="nav-number">3.4.1.</span> <span class="nav-text">5.1.基本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-基于注解的审计元数据"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">5.1.1.基于注解的审计元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-基于接口的审计元数据"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">5.1.2.基于接口的审计元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-AuditorAware"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">5.1.3.AuditorAware</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录"><span class="nav-number">4.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#附录A：命名空间参考"><span class="nav-number">4.1.</span> <span class="nav-text">附录A：命名空间参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#元素"><span class="nav-number">4.1.1.</span> <span class="nav-text">元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录B：Populators命名空间参考"><span class="nav-number">4.2.</span> <span class="nav-text">附录B：Populators命名空间参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#元素-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录C：存储库查询关键字"><span class="nav-number">4.3.</span> <span class="nav-text">附录C：存储库查询关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#支持的查询关键字"><span class="nav-number">4.3.1.</span> <span class="nav-text">支持的查询关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录D：存储库查询返回类型"><span class="nav-number">4.4.</span> <span class="nav-text">附录D：存储库查询返回类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#支持的查询返回类型"><span class="nav-number">4.4.1.</span> <span class="nav-text">支持的查询返回类型</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">知秋</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhiqiuyy"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

  


</body>
</html>
