<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一叶知秋</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muyinchen.github.io/"/>
  <updated>2019-06-24T17:18:35.899Z</updated>
  <id>https://muyinchen.github.io/</id>
  
  <author>
    <name>知秋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RxJava调度选择</title>
    <link href="https://muyinchen.github.io/2019/06/25/RxJava%E8%B0%83%E5%BA%A6%E9%80%89%E6%8B%A9/"/>
    <id>https://muyinchen.github.io/2019/06/25/RxJava调度选择/</id>
    <published>2019-06-24T16:00:00.000Z</published>
    <updated>2019-06-24T17:18:35.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RxJava调度选择"><a href="#RxJava调度选择" class="headerlink" title="RxJava调度选择"></a>RxJava调度选择</h1><h2 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h2><p>在RxJava中有<a href="http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html" target="_blank" rel="noopener">5种不同的调度程序</a>可供选择：</p><blockquote><ol><li><strong>immediate()</strong>：创建并返回一个在当前线程上立即执行工作的Scheduler。</li><li><strong>trampoline()</strong>：创建并返回一个Scheduler ，该Scheduler 所在线程并不会立即工作，而是要等待我们所设定的等待时间结束后才可以执行（默认为0），当然，这个延时设置是要设定在Runnable实现内部。还有一点就是所有任务要添加到一个队列中，然后依次执行即可。</li><li><strong>newThread()</strong>：创建并返回一个Scheduler，为每个任务创建一个新的Thread。</li><li><strong>computation()</strong>：创建并返回用于计算工作的Scheduler。它可以用于事件循环，处理回调和其他计算工作。注意不要使用该Scheduler执行IO类型的工作，对此，我们可以使用<strong>io()</strong> 代替。</li><li><strong>io()</strong> ：创建并返回一个用于IO类型工作的Scheduler。该实现维护了一个Executor线程池，该线程池可根据需要增长。该Scheduler可用于异步执行阻塞IO。不要使用该Scheduler执行计算任务。</li></ol></blockquote><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>前3个Scheduler解释的非常到位，对<strong>computation()</strong> 和 <strong>io()</strong> 有点困惑。</p><ol><li>究竟什么是“IO-bound work”？它适用于处理streams(<code>java.io</code>)和files(<code>java.nio.files</code>)吗？适用于数据库查询吗？适用于下载文件还是访问REST API？</li><li><strong>computation()</strong>与<strong>newThread()</strong> 有什么不同之处？</li><li>为什么在进行IO任务时调用<strong>computation()</strong> 会很糟糕？</li><li>为什么在进行计算任务时调用<strong>io()</strong> 会很糟糕？<a id="more"></a><h2 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h2></li></ol><p>很棒的问题，我认为文档可以提供更多细节。</p><ol><li><code>io()</code>由无限制线程数量的线程池支持，用于执行非计算密集型任务，这些任务不会对CPU造成太大负担（比如主板上的南北桥芯片，南桥芯片主要负责软驱、硬盘、键盘以及附加卡的数据交换）。因此，与文件系统的交互，与不同主机上的数据库或服务的交互就是很好的适用场景。</li><li><code>computation()</code>由有限数量的线程池支持，其大小等于可用处理器的数量。如果你试图在可用处理器之外并行安排cpu密集型工作（比如使用<code>newThread()</code>），那么当线程争夺处理器时，你就会面临线程创建开销和上下文切换开销，并且它可能会受到很大的性能影响。</li><li>最好只留下<code>computation()</code>CPU密集型工作，否则你将无法获得良好的CPU利用率。</li><li><code>io()</code>根据<strong>2</strong>中所讲，在进行计算任务时使用<code>io()</code>是很不好的，如果你<code>io()</code>并行安排了一千个计算任务，那么这千个任务中的每一个都将拥有自己的线程并争夺CPU产生的上下文切换成本。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RxJava调度选择&quot;&gt;&lt;a href=&quot;#RxJava调度选择&quot; class=&quot;headerlink&quot; title=&quot;RxJava调度选择&quot;&gt;&lt;/a&gt;RxJava调度选择&lt;/h1&gt;&lt;h2 id=&quot;前提：&quot;&gt;&lt;a href=&quot;#前提：&quot; class=&quot;headerlink&quot; title=&quot;前提：&quot;&gt;&lt;/a&gt;前提：&lt;/h2&gt;&lt;p&gt;在RxJava中有&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;5种不同的调度程序&lt;/a&gt;可供选择：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;immediate()&lt;/strong&gt;：创建并返回一个在当前线程上立即执行工作的Scheduler。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;trampoline()&lt;/strong&gt;：创建并返回一个Scheduler ，该Scheduler 所在线程并不会立即工作，而是要等待我们所设定的等待时间结束后才可以执行（默认为0），当然，这个延时设置是要设定在Runnable实现内部。还有一点就是所有任务要添加到一个队列中，然后依次执行即可。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;newThread()&lt;/strong&gt;：创建并返回一个Scheduler，为每个任务创建一个新的Thread。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;computation()&lt;/strong&gt;：创建并返回用于计算工作的Scheduler。它可以用于事件循环，处理回调和其他计算工作。注意不要使用该Scheduler执行IO类型的工作，对此，我们可以使用&lt;strong&gt;io()&lt;/strong&gt; 代替。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;io()&lt;/strong&gt; ：创建并返回一个用于IO类型工作的Scheduler。该实现维护了一个Executor线程池，该线程池可根据需要增长。该Scheduler可用于异步执行阻塞IO。不要使用该Scheduler执行计算任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h2&gt;&lt;p&gt;前3个Scheduler解释的非常到位，对&lt;strong&gt;computation()&lt;/strong&gt; 和 &lt;strong&gt;io()&lt;/strong&gt; 有点困惑。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;究竟什么是“IO-bound work”？它适用于处理streams(&lt;code&gt;java.io&lt;/code&gt;)和files(&lt;code&gt;java.nio.files&lt;/code&gt;)吗？适用于数据库查询吗？适用于下载文件还是访问REST API？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;computation()&lt;/strong&gt;与&lt;strong&gt;newThread()&lt;/strong&gt; 有什么不同之处？&lt;/li&gt;
&lt;li&gt;为什么在进行IO任务时调用&lt;strong&gt;computation()&lt;/strong&gt; 会很糟糕？&lt;/li&gt;
&lt;li&gt;为什么在进行计算任务时调用&lt;strong&gt;io()&lt;/strong&gt; 会很糟糕？
    
    </summary>
    
      <category term="响应式" scheme="https://muyinchen.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
      <category term="Reactor Rxjava  NIO" scheme="https://muyinchen.github.io/tags/Reactor-Rxjava-NIO/"/>
    
  </entry>
  
  <entry>
    <title>知秋源码解读分享系列</title>
    <link href="https://muyinchen.github.io/2019/06/10/%E7%9F%A5%E7%A7%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97/"/>
    <id>https://muyinchen.github.io/2019/06/10/知秋源码解读分享系列/</id>
    <published>2019-06-09T16:00:00.000Z</published>
    <updated>2019-06-10T15:24:48.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知秋源码解读分享系列"><a href="#知秋源码解读分享系列" class="headerlink" title="知秋源码解读分享系列"></a>知秋源码解读分享系列</h1><p>作为一个乐于分享的人，我希望通过一些成熟优秀的代码库，来向大家展示读源码思路以及阐述编程方面的技巧，也希望大家从中思考并得到属于自己的一套编程方法论。</p><p>半年以来，已进行72小时时长的源码解读分享视频录制，额外分享时间未计，虽有诸多不足，依然欢迎进行技术交流，也希望可以影响到更多人参与到分享中来，通过分享交到更多朋友，获取快乐，共同成长。</p><h4 id="Java编程方法论-响应式篇-RxJava-分享视频-已完结"><a href="#Java编程方法论-响应式篇-RxJava-分享视频-已完结" class="headerlink" title="Java编程方法论-响应式篇-RxJava 分享视频 已完结"></a>Java编程方法论-响应式篇-RxJava 分享视频 已完结</h4><p>相关书籍已出版：<a href="https://item.m.jd.com/product/12615848.html" target="_blank" rel="noopener">https://item.m.jd.com/product/12615848.html</a></p><p>书籍封面：</p><p><img src="http://img12.360buyimg.com/n1/jfs/t29893/209/1623524567/136902/e6a20ae4/5ce6355bN6b15cb5d.jpg" alt=""></p><p><strong>bilibili</strong>：<a href="https://www.bilibili.com/video/av34537840" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840</a></p><p><strong>油管</strong>:<a href="https://www.youtube.com/playlist?list=PL95Ey4rht798MMCusPzIW7VYD1xaKJVjc" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PL95Ey4rht798MMCusPzIW7VYD1xaKJVjc</a><br><a id="more"></a></p><h4 id="Java编程方法论-响应式篇-Spring-Reactor-分享视频-已完结"><a href="#Java编程方法论-响应式篇-Spring-Reactor-分享视频-已完结" class="headerlink" title="Java编程方法论-响应式篇-Spring Reactor 分享视频 已完结"></a>Java编程方法论-响应式篇-Spring Reactor 分享视频 已完结</h4><p>相关文章待书出版</p><p><strong>B站</strong>：<a href="https://www.bilibili.com/video/av35326911" target="_blank" rel="noopener">https://www.bilibili.com/video/av35326911</a></p><p><strong>油管</strong>：<a href="https://www.youtube.com/playlist?list=PL95Ey4rht7980EH8yr7SLBvj9XSE1ggdy" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PL95Ey4rht7980EH8yr7SLBvj9XSE1ggdy</a></p><h4 id="Java编程方法论-响应式篇-Reactor-Netty-分享视频-在分享"><a href="#Java编程方法论-响应式篇-Reactor-Netty-分享视频-在分享" class="headerlink" title="Java编程方法论-响应式篇-Reactor-Netty 分享视频  在分享"></a>Java编程方法论-响应式篇-Reactor-Netty 分享视频  在分享</h4><p><strong>备注</strong>：相关博文与视频会和Spring Webflux一起进行分享</p><p>视频分享（本系列视频以<strong>0.8.5+</strong> 版本为主）：</p><p><strong>B站</strong>：<a href="https://www.bilibili.com/video/av45556406/" target="_blank" rel="noopener">https://www.bilibili.com/video/av45556406/</a></p><p><strong>油管</strong>：<a href="https://www.youtube.com/watch?v=6qLh2L75KdM&amp;list=PL95Ey4rht79-ISlb_Yr9ToaEI0K8ARmH6" target="_blank" rel="noopener">https://www.youtube.com/watch?v=6qLh2L75KdM&amp;list=PL95Ey4rht79-ISlb_Yr9ToaEI0K8ARmH6</a></p><p><strong>0.7.x</strong>版本相关博文（<strong>0.8.5+</strong> 版本相关文章待书出版）：</p><p><a href="https://juejin.im/post/5c6fe823e51d455b8c18d8aa" target="_blank" rel="noopener">Java编程方法论-Spring WebFlux篇 01 为什么需要Spring WebFlux 上</a></p><p><a href="https://juejin.im/post/5c743cc751882562621751c0" target="_blank" rel="noopener">Java编程方法论-Spring WebFlux篇 01 为什么需要Spring WebFlux 下</a></p><p><a href="https://juejin.im/post/5c76cea45188251fd46ee923" target="_blank" rel="noopener">Java编程方法论-Spring WebFlux篇 Reactor-Netty下HttpServer 的封装</a></p><p><a href="https://juejin.im/post/5c7d7697e51d457c042d50b4" target="_blank" rel="noopener">Java编程方法论-Spring WebFlux篇 Reactor-Netty下TcpServer的功能实现 1</a></p><h4 id="Java编程方法论-JDK-篇-之-NIO-分享视频-（基于JDK11版本解读）-在分享"><a href="#Java编程方法论-JDK-篇-之-NIO-分享视频-（基于JDK11版本解读）-在分享" class="headerlink" title="Java编程方法论-JDK 篇 之 NIO 分享视频 （基于JDK11版本解读） 在分享"></a>Java编程方法论-JDK 篇 之 NIO 分享视频 （基于JDK11版本解读） 在分享</h4><p><strong>B站</strong>：<a href="https://www.bilibili.com/video/av43230997" target="_blank" rel="noopener">https://www.bilibili.com/video/av43230997</a></p><p><strong>油管</strong>：<a href="https://www.youtube.com/watch?v=ZZnCI8xaTRo&amp;list=PL95Ey4rht799NVLgQiSV9skTqY6VuspIk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ZZnCI8xaTRo&amp;list=PL95Ey4rht799NVLgQiSV9skTqY6VuspIk</a></p><p><strong>相关博文</strong>：</p><p><a href="https://juejin.im/post/5c2cc075f265da611037298e" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之BIO</a></p><p><a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a></p><p><a href="https://juejin.im/post/5c34d1dd6fb9a049c84fa2ce" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 中</a></p><p><a href="https://juejin.im/post/5c3a01d851882525c55fad36" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 下 之 Selector</a></p><p><a href="https://juejin.im/post/5c4738c151882525c638144e" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 下 Buffer解读 上</a></p><p><a href="https://juejin.im/post/5c653140518825625e4abfc6" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 下 Buffer解读 下</a></p><h4 id="Java编程方法论-Netty-分享视频"><a href="#Java编程方法论-Netty-分享视频" class="headerlink" title="Java编程方法论-Netty 分享视频"></a>Java编程方法论-Netty 分享视频</h4><p><strong>bilibili</strong> ：<a href="https://www.bilibili.com/video/av50169264" target="_blank" rel="noopener">https://www.bilibili.com/video/av50169264</a></p><p><strong>youtube</strong> : <a href="https://www.youtube.com/watch?v=AHNW9YCF9aI&amp;list=PL95Ey4rht798WiqkvGYChWdUtHie0j-IU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=AHNW9YCF9aI&amp;list=PL95Ey4rht798WiqkvGYChWdUtHie0j-IU</a></p><h4 id="Java编程方法论-JDK-篇-之-JUC-分享视频-（基于JDK11版本解读）"><a href="#Java编程方法论-JDK-篇-之-JUC-分享视频-（基于JDK11版本解读）" class="headerlink" title="Java编程方法论-JDK 篇 之 JUC 分享视频 （基于JDK11版本解读）"></a>Java编程方法论-JDK 篇 之 JUC 分享视频 （基于JDK11版本解读）</h4><p><strong>bilibili</strong> ：<a href="https://www.bilibili.com/video/av51324899" target="_blank" rel="noopener">https://www.bilibili.com/video/av51324899</a></p><p><strong>youtube</strong> : 待上传</p><h4 id="Spring-源码解读博客文章："><a href="#Spring-源码解读博客文章：" class="headerlink" title="Spring 源码解读博客文章："></a>Spring 源码解读博客文章：</h4><p><a href="https://muyinchen.github.io/tags/Spring/">https://muyinchen.github.io/tags/Spring/</a></p><p><strong>其中Spring Reactor 分享视频获得了Spring 开发者的认可并被Spring官方推特转发：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/4/23/16a4998719a49ac2?w=613&amp;h=338&amp;f=webp&amp;s=20530" alt=""></p><p><img src="https://github.com/muyinchen/simviso-Source-code-interpretation-sharing/blob/master/assets/4BD05E6C02038F7E17EBD29BA705FE5F.png?raw=true" alt=""></p><h4 id="个人博客："><a href="#个人博客：" class="headerlink" title="个人博客："></a>个人博客：</h4><p><a href="https://muyinchen.github.io">https://muyinchen.github.io</a>  </p><p><a href="https://juejin.im/user/59c7640851882578e00ddf90" target="_blank" rel="noopener">https://juejin.im/user/59c7640851882578e00ddf90</a></p><p>交流QQ群： 523409180</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;知秋源码解读分享系列&quot;&gt;&lt;a href=&quot;#知秋源码解读分享系列&quot; class=&quot;headerlink&quot; title=&quot;知秋源码解读分享系列&quot;&gt;&lt;/a&gt;知秋源码解读分享系列&lt;/h1&gt;&lt;p&gt;作为一个乐于分享的人，我希望通过一些成熟优秀的代码库，来向大家展示读源码思路以及阐述编程方面的技巧，也希望大家从中思考并得到属于自己的一套编程方法论。&lt;/p&gt;
&lt;p&gt;半年以来，已进行72小时时长的源码解读分享视频录制，额外分享时间未计，虽有诸多不足，依然欢迎进行技术交流，也希望可以影响到更多人参与到分享中来，通过分享交到更多朋友，获取快乐，共同成长。&lt;/p&gt;
&lt;h4 id=&quot;Java编程方法论-响应式篇-RxJava-分享视频-已完结&quot;&gt;&lt;a href=&quot;#Java编程方法论-响应式篇-RxJava-分享视频-已完结&quot; class=&quot;headerlink&quot; title=&quot;Java编程方法论-响应式篇-RxJava 分享视频 已完结&quot;&gt;&lt;/a&gt;Java编程方法论-响应式篇-RxJava 分享视频 已完结&lt;/h4&gt;&lt;p&gt;相关书籍已出版：&lt;a href=&quot;https://item.m.jd.com/product/12615848.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://item.m.jd.com/product/12615848.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;书籍封面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img12.360buyimg.com/n1/jfs/t29893/209/1623524567/136902/e6a20ae4/5ce6355bN6b15cb5d.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bilibili&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av34537840&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av34537840&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;油管&lt;/strong&gt;:&lt;a href=&quot;https://www.youtube.com/playlist?list=PL95Ey4rht798MMCusPzIW7VYD1xaKJVjc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.youtube.com/playlist?list=PL95Ey4rht798MMCusPzIW7VYD1xaKJVjc&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="响应式" scheme="https://muyinchen.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
      <category term="Reactor Rxjava  NIO" scheme="https://muyinchen.github.io/tags/Reactor-Rxjava-NIO/"/>
    
  </entry>
  
  <entry>
    <title>BIO到NIO源码的一些事儿之NIO 下 Buffer解读 上</title>
    <link href="https://muyinchen.github.io/2019/02/22/BIO%E5%88%B0NIO%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF%E4%B9%8BNIO%20%E4%B8%8B%20Buffer%E8%A7%A3%E8%AF%BB%20%E4%B8%8A/"/>
    <id>https://muyinchen.github.io/2019/02/22/BIO到NIO源码的一些事儿之NIO 下 Buffer解读 上/</id>
    <published>2019-02-21T16:00:00.000Z</published>
    <updated>2019-02-15T10:12:29.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。</p><p>关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:</p><p>Rxjava源码解读与分享：<a href="https://www.bilibili.com/video/av34537840" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840</a></p><p>Reactor源码解读与分享：<a href="https://www.bilibili.com/video/av35326911" target="_blank" rel="noopener">https://www.bilibili.com/video/av35326911</a></p><p>本系列源码解读基于JDK11 api细节可能与其他版本有所差别，请自行解决jdk版本问题。</p><p>本系列前几篇:</p><p><a href="https://juejin.im/post/5c2cc075f265da611037298e" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之BIO</a></p><p><a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a></p><p><a href="https://juejin.im/post/5c34d1dd6fb9a049c84fa2ce" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 中</a></p><p><a href="https://juejin.im/post/5c3a01d851882525c55fad36" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 下 之 Selector</a></p><a id="more"></a><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>在Java BIO中，通过<a href="">BIO到NIO源码的一些事儿之BIO</a>开篇的Demo可知，所有的读写API，都是直接使用byte数组作为缓冲区的，简单直接。我们来拿一个杯子做例子，我们不讲它的材质，只说它的使用属性，一个杯子在使用过程中会首先看其最大容量，然后加水，这里给一个限制，即加到杯子中的水量为杯子最大容量的一半，然后喝水，我们最多也只能喝杯子里所盛水量。由这个例子，我们思考下，杯子是不是可以看作是一个缓冲区，对于杯子倒水的节奏我们是不是可以轻易的控制，从而带来诸多方便，那是不是可以将之前<code>BIO</code>中的缓冲区也加入一些特性，使之变的和我们使用杯子一样便捷。<br>于是，我们给<code>buffer</code>添加几个属性，对比杯子的最大容量，我们设计添加一个<code>capacity</code>属性，对比加上的容量限制，我们设计添加一个<code>limit</code>属性，对于加水加到杯中的当前位置，我们设计添加一个<code>position</code>属性，有时候我们还想在杯子上自己做个标记，比如喝茶，我自己的习惯就是喝到杯里剩三分之一水的时候再加水加到一半，针对这个情况，设计添加一个<code>mark</code>属性。由此，我们来总结下这几个属性的关系，<code>limit</code>不可能比<code>capacity</code>大的，<code>position</code>又不会大于<code>limit</code>，<code>mark</code>可以理解为一个标签，其也不会大于<code>position</code>，也就是<code>mark &lt;= position &lt;= limit &lt;= capacity</code>。</p><p>结合以上概念，我们来对buffer中这几个属性使用时的行为进行下描述:</p><ul><li><p><strong>capacity</strong></p><blockquote><p>也就是缓冲区的容量大小。我们只能往里面写<code>capacity</code>个<code>byte</code>、<code>long</code>、<code>char</code>等类型。一旦<code>Buffer</code>满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p></blockquote></li><li><p><strong>position</strong></p><blockquote><p>（1）当我们写数据到<code>Buffer</code>中时，<code>position</code>表示当前的位置。初始的<code>position</code>值为0.当一个<code>byte</code>、<code>long</code>、<code>char</code>等数据写到<code>Buffer</code>后， <code>position</code>会向前移动到下一个可插入数据的<code>Buffer</code>位置。<code>position</code>最大可为<code>capacity – 1</code>。</p><p>（2）当读取数据时，也是从某个特定位置读。当将<code>Buffer</code>从写模式切换到读模式，<code>position</code>会被重置为<code>0</code>. 当从<code>Buffer</code>的<code>position</code>处读取数据时，<code>position</code>向前移动到下一个可读的位置。</p></blockquote></li><li><p><strong>limit</strong></p><blockquote><p>（1）在写模式下，<code>Buffer</code>的<code>limit</code>表示你最多能往<code>Buffer</code>里写多少数据。 写模式下，<code>limit</code>等于<code>Buffer</code>的<code>capacity</code>。</p><p>（2）读模式时，<code>limit</code>表示你最多能读到多少数据。因此，当切换<code>Buffer</code>到读模式时，<code>limit</code>会被设置成写模式下的<code>position</code>值。换句话说，你能读到之前写入的所有数据（<code>limit</code>被设置成已写数据的数量，这个值在写模式下就是<code>position</code>）</p></blockquote></li><li><p><strong>mark</strong></p><blockquote><p>类似于喝茶喝到剩余三分之一谁加水一样，当buffer调用它的reset方法时，当前的位置<code>position</code>会指向<code>mark</code>所在位置，同样，这个也根据个人喜好，有些人就喜欢将水喝完再添加的，所以<code>mark</code>不一定总会被设定，但当它被设定值之后，那设定的这个值不能为负数，同时也不能大于<code>position</code>。还有一种情况，就是我喝水喝不下了，在最后将水一口喝完，则对照的此处的话，即如果对<code>mark</code>设定了值（并非初始值-1），则在将<code>position</code>或<code>limit</code>调整为小于<code>mark</code>的值的时候将<code>mark</code>丢弃掉。如果并未对<code>mark</code>重新设定值（即还是初始值-1），那么在调用<code>reset</code>方法会抛出<code>InvalidMarkException</code>异常。</p></blockquote></li></ul><p>可见，经过包装的Buffer是Java NIO中对于缓冲区的抽象。在Java有8中基本类型：<code>byte、short、int、long、float、double、char、boolean</code>，除了<code>boolean</code>类型外，其他的类型都有对应的<code>Buffer</code>具体实现，可见，<code>Buffer</code>是一个用于存储特定基本数据类型的容器。再加上数据时有序存储的，而且<code>Buffer</code>有大小限制，所以，<code>Buffer</code>可以说是特定基本数据类型的线性存储有限的序列。</p><p>接着，我们通过下面这幅图来展示下上面几个属性的关系，方便大家更好理解:<br><img src="https://github.com/muyinchen/woker/blob/master/mypics/buffers-modes.png?raw=true" alt=""></p><h3 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a>Buffer的基本用法</h3><p>先来看一个Demo:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//create buffer with capacity of 48 bytes</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  buf.flip();  <span class="comment">//make buffer ready for read</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>) buf.get()); <span class="comment">// read 1 byte at a time</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf.clear(); <span class="comment">//make buffer ready for writing</span></span><br><span class="line">  bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure></p><p>我们抛去前两行，来总结下buffer的使用步骤：</p><ol><li>通过相应类型Buffer的allocate的静态方法来分配指定类型大小的缓冲数据区域（此处为buf）;</li><li>写入数据到Buffer;</li><li>调用flip()方法：Buffer从写模式切换到读模式;</li><li>从buffer读取数据;</li><li>调用clear()方法或则compact()方法。<h4 id="Buffer分配"><a href="#Buffer分配" class="headerlink" title="Buffer分配"></a>Buffer分配</h4>那我们依据上面的步骤来一一看下其相应源码实现，这里我们使用ByteBuffer来解读。首先是Buffer分配。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.ByteBuffer#allocate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> createCapacityException(capacity);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.ByteBuffer#allocateDirect</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>ByteBuffer</code>是一个抽象类，具体的实现有<code>HeapByteBuffer</code>和<code>DirectByteBuffer</code>。分别对应<code>Java</code>堆缓冲区与堆外内存缓冲区。Java堆缓冲区本质上就是byte数组（由之前分析的，我们只是在字节数组上面加点属性，辅以逻辑，实现一些更复杂的功能），所以实现会比较简单。而堆外内存涉及到JNI代码实现，较为复杂，所以我们先来分析<code>HeapByteBuffer</code>的相关操作，随后再专门分析<code>DirectByteBuffer</code>。</p><p>我们来看<code>HeapByteBuffer</code>相关构造器源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.HeapByteBuffer#HeapByteBuffer(int, int)</span></span><br><span class="line">HeapByteBuffer(<span class="keyword">int</span> cap, <span class="keyword">int</span> lim) &#123;            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="keyword">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hb = new byte[cap];</span></span><br><span class="line"><span class="comment">    offset = 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">this</span>.address = ARRAY_BASE_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.ByteBuffer#ByteBuffer(int, int, int, int, byte[], int)</span></span><br><span class="line">ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,   </span><br><span class="line">                <span class="keyword">byte</span>[] hb, <span class="keyword">int</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    <span class="keyword">this</span>.hb = hb;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.Buffer#Buffer</span></span><br><span class="line">Buffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;       </span><br><span class="line">    <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> createCapacityException(cap);</span><br><span class="line">    <span class="keyword">this</span>.capacity = cap;</span><br><span class="line">    limit(lim);</span><br><span class="line">    position(pos);</span><br><span class="line">    <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; pos)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"mark &gt; position: ("</span></span><br><span class="line">                                                + mark + <span class="string">" &gt; "</span> + pos + <span class="string">")"</span>);</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由上，<code>HeapByteBuffer</code>通过初始化字节数组<code>hd</code>，在虚拟机堆上申请内存空间。<br>因在<code>ByteBuffer</code>中定义有<code>hb</code>这个字段，它是一个<code>byte[]</code>类型，为了获取这个字段相对于当前这个<code>ByteBuffer</code>对象所在内存地址，通过<code>private static final long ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset(byte[].class)</code>中这个<code>UNSAFE</code>操作来获取这个数组第一个元素位置与该对象所在地址的相对长度，这个对象的地址代表你的头所在的位置，将这个数组看作你的鼻子，而这里返回的是你的鼻子距离头位置的那个长度，即数组第一个位置距离这个对象开始地址所在位置，这个是在class字节码加载到jvm里的时候就已经确定了。<br>如果<code>ARRAY_INDEX_SCALE = UNSAFE.arrayIndexScale(byte[].class)</code>为返回非零值，则可以使用该比例因子以及此基本偏移量（ARRAY_BASE_OFFSET）来形成新的偏移量，以访问这个类的数组元素。知道这些，在<code>ByteBuffer</code>的<code>slice</code> <code>duplicate</code>之类的方法，就能理解其操作了，就是计算数组中每一个元素所占空间长度得到<code>ARRAY_INDEX_SCALE</code>，然后当我确定我从数组第5个位置作为该数组的开始位置操作时，我就可以使用<code>this.address = ARRAY_BASE_OFFSET + off * ARRAY_INDEX_SCALE</code>。<br>我们再通过下面的源码对上述内容对比消化下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.HeapByteBuffer</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">HeapByteBuffer</span><span class="params">(<span class="keyword">byte</span>[] buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap, buf, off);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hb = buf;</span></span><br><span class="line"><span class="comment">    offset = off;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">this</span>.address = ARRAY_BASE_OFFSET + off * ARRAY_INDEX_SCALE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb,</span><br><span class="line">                            -<span class="number">1</span>,</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                            <span class="keyword">this</span>.remaining(),</span><br><span class="line">                            <span class="keyword">this</span>.remaining(),</span><br><span class="line">                            <span class="keyword">this</span>.position() + offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ByteBuffer <span class="title">slice</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (pos &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="keyword">int</span> rem = lim - pos;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb,</span><br><span class="line">                            -<span class="number">1</span>,</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                            rem,</span><br><span class="line">                            rem,</span><br><span class="line">                            pos + offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb,</span><br><span class="line">                            <span class="keyword">this</span>.markValue(),</span><br><span class="line">                            <span class="keyword">this</span>.position(),</span><br><span class="line">                            <span class="keyword">this</span>.limit(),</span><br><span class="line">                            <span class="keyword">this</span>.capacity(),</span><br><span class="line">                            offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Buffer的读写"><a href="#Buffer的读写" class="headerlink" title="Buffer的读写"></a>Buffer的读写</h4><p>每个<code>buffer</code>都是可读的，但不是每个<code>buffer</code>都是可写的。这里，当<code>buffer</code>有内容变动的时候，会首先调用<code>buffer</code>的<code>isReadOnly</code>判断此<code>buffer</code>是否只读，只读<code>buffer</code>是不允许更改其内容的，但<code>mark</code>、<code>position</code> 和 <code>limit</code>的值是可变的，这是我们人为给其额外的定义，方便我们增加功能逻辑的。当在只读<code>buffer</code>上调用修改时，则会抛出<code>ReadOnlyBufferException</code>异常。我们来看<code>buffer</code>的<code>put</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.ByteBuffer#put(java.nio.ByteBuffer)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> createSameBufferException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">int</span> n = src.remaining();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        put(src.get());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.Buffer#remaining</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> limit - position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面<code>remaining</code>方法表示还剩多少数据未读，上面的源码讲的是，如果<code>src</code>这个<code>ByteBuffer</code>的<code>src.remaining()</code>的数量大于要存放的目标<code>Buffer</code>的还剩的空间，直接抛溢出的异常。然后通过一个for循环，将<code>src</code>剩余的数据，依次写入目标<code>Buffer</code>中。接下来，我们通过<code>src.get()</code>来探索下<code>Buffer</code>的读操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.HeapByteBuffer#get()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(checkIndex(i))];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.HeapByteBuffer#ix</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.Buffer#nextGetIndex()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;                          </span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，为了依次读取数组中的数据，这里使用<code>nextGetIndex()</code>来获取要读位置，即先返回当前要获取的位置值，然后position自己再加1。以此在前面<code>ByteBuffer#put(java.nio.ByteBuffer)</code>所示源码中的<code>for</code>循环中依次对剩余数据的读取。上述<code>get(int i)</code>不过是从指定位置获取数据，实现也比较简单<code>HeapByteBuffer#ix</code>也只是确定所要获取此数组对象指定位置数据，其中的<code>offset</code>表示第一个<strong>可读</strong>字节在该字节数组中的位置（就好比我喝茶杯底三分之一水是不喝的，每次都从三分之一水量开始位置计算喝了多少或者加入多少水）。<br>接下来看下单个字节存储到指定字节数组的操作，与获取字节数组单个位置数据相对应，代码比较简单:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.HeapByteBuffer#put(byte)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    hb[ix(nextPutIndex())] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    hb[ix(checkIndex(i))] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.Buffer#nextPutIndex()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面的都是单个字节的，下面来讲下批量操作字节数组是如何进行的，因过程知识点重复，这里只讲get,先看源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.ByteBuffer#get(byte[])</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(dst, <span class="number">0</span>, dst.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.ByteBuffer#get(byte[], int, int)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数是否越界</span></span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line">     <span class="comment">// 检查要获取的长度是否大于Buffer中剩余的数据长度</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        dst[i] = get();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.Buffer#checkBounds</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBounds</span><span class="params">(<span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> ((off | len | (off + len) | (size - (off + len))) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这个方法将这个buffer中的字节数据读到我们给定的目标数组dst中，由checkBounds可知，当要写入目标字节数组的可写长度小于将要写入数据的长度的时候，会产生边界异常。当要获取的长度是大于Buffer中剩余的数据长度时抛出<code>BufferUnderflowException</code>异常，当验证通过后，接着就从目标数组的<code>offset</code>位置开始，从<code>buffer</code>获取并写入<code>offset + length</code>长度的数据。<br>可以看出，<code>HeapByteBuffer</code>是封装了对byte数组的简单操作。对缓冲区的写入和读取本质上是对数组的写入和读取。使用<code>HeapByteBuffer</code>的好处是我们不用做各种参数校验，也不需要另外维护数组当前读写位置的变量了。<br>同时我们可以看到，<code>Buffer</code>中对<code>position</code>的操作没有使用锁保护，所以<code>Buffer</code>不是线程安全的。如果我们操作的这个<code>buffer</code>会有多个线程使用，则针对该<code>buffer</code>的访问应通过适当的同步控制机制来进行保护。</p><h4 id="ByteBuffer的模式"><a href="#ByteBuffer的模式" class="headerlink" title="ByteBuffer的模式"></a>ByteBuffer的模式</h4><p>jdk本身是没这个说法的，只是按照我们自己的操作习惯，我们将<code>Buffer</code>分为两种工作模式，一种是接收数据模式，一种是输出数据模式。我们可以通过<code>Buffer</code>提供的<code>flip</code>等操作来切换<code>Buffer</code>的工作模式。</p><p>我们来新建一个容量为10的<code>ByteBuffer</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer.allocate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>由前面所学的<code>HeapByteBuffer</code>的构造器中的相关代码可知，这里的<code>position</code>被设置为0，而且 <code>capacity</code>和<code>limit</code>设置为 10，<code>mark</code>设置为-1，<code>offset</code>设定为0。<br>可参考下图展示:</p><p><img src="https://github.com/muyinchen/woker/blob/master/mypics/ByteBuffer%E5%88%9D%E5%A7%8B%E5%8C%96.png?raw=true" alt="HeapByteBuffer初始化"></p><p>新建的<code>Buffer</code>处于接收数据的模式，可以向<code>Buffer</code>放入数据，在放入一个对应基本类型的数据后（此处假如放入一个char类型数据），position加一，参考我们上面所示源码，如果position已经等于limit了还进行<code>put</code>操作，则会抛出<code>BufferOverflowException</code>异常。<br>我们向所操作的buffer中put 5个char类型的数据进去:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.put((<span class="keyword">byte</span>)<span class="string">'a'</span>).put((<span class="keyword">byte</span>)<span class="string">'b'</span>).put((<span class="keyword">byte</span>)<span class="string">'c'</span>).put((<span class="keyword">byte</span>)<span class="string">'d'</span>).put((<span class="keyword">byte</span>)<span class="string">'e'</span>);</span><br></pre></td></tr></table></figure></p><p>会得到如下结果视图:</p><p><img src="https://github.com/muyinchen/woker/blob/master/mypics/ByteBuffer%20%E9%80%BB%E8%BE%91%E8%A7%86%E5%9B%BE.png?raw=true" alt=""></p><p>由之前源码分析可知，Buffer的读写的位置变量都是基于<code>position</code>来做的，其他的变量都是围绕着它进行辅助管理的，所以如果从<code>Buffer</code>中读取数据，要将<code>Buffer</code>切换到输出数据模式（也就是读模式）。此时，我们就可以使用<code>Buffer</code>提供了flip方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.Buffer#flip</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们知道，在put的时候，会进行<code>java.nio.Buffer#nextPutIndex()</code>的调用，里面会进行<code>position &gt;= limit</code>，所以，此时再进行写操作的话，会从第0个位置开始进行覆盖，而且只能写到<code>flip</code>操作之后<code>limit</code>的位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.Buffer#nextPutIndex()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在做完<code>put</code>操作后，<code>position</code>会自增一下，所以，<code>flip</code>操作示意图如下：</p><p><img src="https://github.com/muyinchen/woker/blob/master/mypics/flip.png?raw=true" alt=""></p><p>也是因为<code>position</code>为0了，所以我们可以很方便的从Buffer中第0个位置开始读取数据，不需要别的附加操作。由之前解读可知，每次读取一个元素，<code>position</code>就会加一，如果<code>position</code>已经等于<code>limit</code>还进行读取，则会抛出<code>BufferUnderflowException</code>异常。</p><p>我们通过<code>flip</code>方法把<code>Buffer</code>从接收写模式切换到输出读模式，如果要从输出模式切换到接收模式，可以使用<code>compact</code>或者<code>clear</code>方法，如果数据已经读取完毕或者数据不要了，使用<code>clear</code>方法，如果只想从缓冲区中释放一部分数据，而不是全部（即释放已读数据，保留未读数据），然后重新填充，使用<code>compact</code>方法。</p><p>对于<code>clear</code>方法，我们先来看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.Buffer#clear</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到，它的<code>clear</code>方法内并没有做清理工作，只是修改位置变量，重置为初始化时的状态，等待下一次将数据写入缓冲数组。<br>接着，来看<code>compact</code>操作的源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.HeapByteBuffer#compact</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">    position(remaining());</span><br><span class="line">    limit(capacity());</span><br><span class="line">    discardMark();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.ByteBuffer#position</span></span><br><span class="line"><span class="function">ByteBuffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.position(newPosition);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.Buffer#position(int)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newPosition &gt; limit | newPosition &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> createPositionException(newPosition);</span><br><span class="line">    position = newPosition;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.ByteBuffer#limit</span></span><br><span class="line"><span class="function">ByteBuffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.limit(newLimit);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.Buffer#limit(int)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newLimit &gt; capacity | newLimit &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> createLimitException(newLimit);</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.Buffer#discardMark</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">discardMark</span><span class="params">()</span> </span>&#123;                          </span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里使用了数组的拷贝操作，将未读元素转移到该字节数组从<strong>0</strong>开始的位置，由于<code>remaining()</code>返回的是<code>limit - position</code>，假如在<code>flip</code>操作的时候填入的元素有<strong>5</strong>个，那么<code>limit</code>为<strong>5</strong>，此时读到了第三个元素，也就是在调用<code>compact</code>时<code>position</code>的数值为<strong>2</strong>，那<code>remaining()</code>的值就为<strong>3</strong>，也就是此时<code>position</code>为<strong>3</strong>，<code>compact</code>操作后，<code>limit</code>会回归到和初始化数组容量大小一样，并将<strong>mark</strong>值置为 <strong>-1</strong>。</p><p>我们来看示意图，在进行<code>buffer.compact()</code>调用前:</p><p><img src="https://github.com/muyinchen/woker/blob/master/mypics/buffer.compact(" alt="">%E8%B0%83%E7%94%A8%E5%89%8D.png?raw=true)</p><p><code>buffer.compact()</code>调用后:</p><p><img src="https://github.com/muyinchen/woker/blob/master/mypics/buffer.compact(" alt="">%E8%B0%83%E7%94%A8%E5%90%8E.png?raw=true)</p><h4 id="ByteBuffer的其他方法"><a href="#ByteBuffer的其他方法" class="headerlink" title="ByteBuffer的其他方法"></a>ByteBuffer的其他方法</h4><p>接下来，我们再接触一些<code>ByteBuffer</code>的其他方法，方便在适当的条件下进行使用。</p><h5 id="rewind方法"><a href="#rewind方法" class="headerlink" title="rewind方法"></a>rewind方法</h5><p>首先来看它的源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.Buffer#rewind</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就是将<code>position</code>设定为0，<code>mark</code>设定为-1，其他设定的管理属性（<code>capacity</code>，<code>limit</code>）不变。结合前面的知识，在字节数组写入数据后，它的<code>clear</code>方法也只是重置我们在<code>Buffer</code>中设定的那几个增强管理属性（<code>capacity</code>、<code>position</code>、<code>limit</code>、<code>mark</code>），此处的英文表达的意思也很明显：<strong>倒带</strong>，也就是可以回头重新写，或者重新读。但是我们要注意一个前提，我们要确保已经恰当的设置了<code>limit</code>。这个方法可以在<code>Channel</code>的读或者写之前调用，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out.write(buf);    <span class="comment">// Write remaining data</span></span><br><span class="line">buf.rewind();      <span class="comment">// Rewind buffer</span></span><br><span class="line">buf.get(array);    <span class="comment">// Copy data into array</span></span><br></pre></td></tr></table></figure></p><p>我们通过下图来进行展示执行<code>rewind</code>操作后的结果：</p><p><img src="https://github.com/muyinchen/woker/blob/master/mypics/buffer.rewind.png?raw=true" alt=""></p><h5 id="duplicate-方法"><a href="#duplicate-方法" class="headerlink" title="duplicate 方法"></a>duplicate 方法</h5><p>在JDK9版本中，新增了这个方法。用来创建一个与原始<code>Buffer</code>一样的新<code>Buffer</code>。新<code>Buffer</code>的内容和原始<code>Buffer</code>一样。改变新<code>Buffer</code>内的数据，同样会体现在原始<code>Buffer</code>上，反之亦然。两个<code>Buffer</code>都拥有自己独立的 <code>position</code>，<code>limit</code> 和<code>mark</code> 属性。<br>刚创建的新<code>Buffer</code>的<code>position</code>，<code>limit</code> 和<code>mark</code> 属性与原始<code>Buffer</code>对应属性的值相同。<br>还有一点需要注意的是，如果原始<code>Buffer</code>是只读的（即<code>HeapByteBufferR</code>），那么新<code>Buffer</code>也是只读的。如果原始<code>Buffer</code>是<code>DirectByteBuffer</code>，那新<code>Buffer</code>也是<code>DirectByteBuffer</code>。<br>我们来看相关源码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.HeapByteBuffer#duplicate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb,</span><br><span class="line">                                <span class="keyword">this</span>.markValue(),</span><br><span class="line">                                <span class="keyword">this</span>.position(),</span><br><span class="line">                                <span class="keyword">this</span>.limit(),</span><br><span class="line">                                <span class="keyword">this</span>.capacity(),</span><br><span class="line">                                offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.HeapByteBufferR#duplicate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBufferR(hb,</span><br><span class="line">                                <span class="keyword">this</span>.markValue(),</span><br><span class="line">                                <span class="keyword">this</span>.position(),</span><br><span class="line">                                <span class="keyword">this</span>.limit(),</span><br><span class="line">                                <span class="keyword">this</span>.capacity(),</span><br><span class="line">                                offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.DirectByteBuffer#duplicate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>,</span><br><span class="line">                                    <span class="keyword">this</span>.markValue(),</span><br><span class="line">                                    <span class="keyword">this</span>.position(),</span><br><span class="line">                                    <span class="keyword">this</span>.limit(),</span><br><span class="line">                                    <span class="keyword">this</span>.capacity(),</span><br><span class="line">                                    <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基本类型的参数传递都是值传递，所以由上面源码可知每个新缓冲区都拥有自己的 <code>position</code>、<code>limit</code> 和 <code>mark</code> 属性，而且他们的初始值使用了原始<code>Buffer</code>此时的值。<br>但是，从<code>HeapByteBuffer</code>角度来说，对于<strong>hb</strong> 作为一个数组对象，属于对象引用传递，即新老<code>Buffer</code>共用了同一个字节数组对象。无论谁操作，都会改变另一个。<br>从<code>DirectByteBuffer</code>角度来说，直接内存看重的是地址操作，所以，其在创建这个新<code>Buffer</code>的时候传入的是原始<code>Buffer</code>的引用，进而可以获取到相关地址。</p><h5 id="asReadOnlyBuffer"><a href="#asReadOnlyBuffer" class="headerlink" title="asReadOnlyBuffer"></a>asReadOnlyBuffer</h5><p>可以使用 <code>asReadOnlyBuffer()</code> 方法来生成一个只读的缓冲区。这与<br><code>duplicate()</code>实现有些相同，除了这个新的缓冲区不允许使用<code>put()</code>，并且其<code>isReadOnly()</code>函数<br>将会返回true 。 对这一只读缓冲区调用<code>put()</code>操作，会导致<code>ReadOnlyBufferException</code>异常。<br>我们来看相关源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.ByteBuffer#put(java.nio.ByteBuffer)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> createSameBufferException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">int</span> n = src.remaining();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        put(src.get());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.HeapByteBuffer#asReadOnlyBuffer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBufferR(hb,</span><br><span class="line">                                    <span class="keyword">this</span>.markValue(),</span><br><span class="line">                                    <span class="keyword">this</span>.position(),</span><br><span class="line">                                    <span class="keyword">this</span>.limit(),</span><br><span class="line">                                    <span class="keyword">this</span>.capacity(),</span><br><span class="line">                                    offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.HeapByteBufferR#asReadOnlyBuffer</span></span><br><span class="line"><span class="comment">//HeapByteBufferR下直接调用其duplicate方法即可，其本来就是只读的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> duplicate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.DirectByteBuffer#asReadOnlyBuffer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBufferR(<span class="keyword">this</span>,</span><br><span class="line">                                        <span class="keyword">this</span>.markValue(),</span><br><span class="line">                                        <span class="keyword">this</span>.position(),</span><br><span class="line">                                        <span class="keyword">this</span>.limit(),</span><br><span class="line">                                        <span class="keyword">this</span>.capacity(),</span><br><span class="line">                                        <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.DirectByteBufferR#asReadOnlyBuffer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> duplicate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.nio.HeapByteBufferR#HeapByteBufferR</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">HeapByteBufferR</span><span class="params">(<span class="keyword">byte</span>[] buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(buf, mark, pos, lim, cap, off);</span><br><span class="line">    <span class="keyword">this</span>.isReadOnly = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.DirectByteBufferR#DirectByteBufferR</span></span><br><span class="line">DirectByteBufferR(DirectBuffer db,       </span><br><span class="line">                <span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,</span><br><span class="line">                <span class="keyword">int</span> off)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(db, mark, pos, lim, cap, off);</span><br><span class="line">    <span class="keyword">this</span>.isReadOnly = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>ByteBuffer</code>的只读实现，在构造器里首先将<code>isReadOnly</code>属性设定为<code>true</code>。接着，<code>HeapByteBufferR</code>继承了<code>HeapByteBuffer</code> 类（<code>DirectByteBufferR</code>也是类似实现，就不重复了），并重写了所有可对buffer修改的方法。把所有能修改<code>buffer</code>的方法都直接抛出ReadOnlyBufferException来保证只读。来看<code>DirectByteBufferR</code>相关源码，其他对应实现一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.DirectByteBufferR#put(byte)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="slice-方法"><a href="#slice-方法" class="headerlink" title="slice 方法"></a>slice 方法</h5><p><code>slice</code>从字面意思来看，就是<strong>切片</strong>，用在这里，就是分割<code>ByteBuffer</code>。即创建一个从原始<code>ByteBuffer</code>的当前位置（<code>position</code>）开始的新<code>ByteBuffer</code>，并且其容量是原始<code>ByteBuffer</code>的剩余消费元素数量（ <code>limit-position</code>）。这个新<code>ByteBuffer</code>与原始<code>ByteBuffer</code>共享一段数据元素子序列，也就是设定一个offset值，这样就可以将一个相对数组第三个位置的元素看作是起点元素，此时新<code>ByteBuffer</code>的<code>position</code>就是0，读取的还是所传入这个<code>offset</code>的所在值。分割出来的<code>ByteBuffer</code>也会继承只读和直接属性。<br>我们来看相关源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.HeapByteBuffer#slice()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb,</span><br><span class="line">                                -<span class="number">1</span>,</span><br><span class="line">                                <span class="number">0</span>,</span><br><span class="line">                                <span class="keyword">this</span>.remaining(),</span><br><span class="line">                                <span class="keyword">this</span>.remaining(),</span><br><span class="line">                                <span class="keyword">this</span>.position() + offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">HeapByteBuffer</span><span class="params">(<span class="keyword">byte</span>[] buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap, buf, off);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hb = buf;</span></span><br><span class="line"><span class="comment">    offset = off;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">this</span>.address = ARRAY_BASE_OFFSET + off * ARRAY_INDEX_SCALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由源码可知，新<code>ByteBuffer</code>和原始<code>ByteBuffer</code>共有了一个数组，新<code>ByteBuffer</code>的<code>mark</code>值为-1，<code>position</code>值为0，<code>limit</code>和<code>capacity</code>都为原始<code>Buffer</code>中<code>limit-position</code>的值。<br>于是，我们可以通过下面两幅图来展示<code>slice</code>方法前后的对比。</p><p>原始<code>ByteBuffer</code>：</p><p><img src="https://github.com/muyinchen/woker/blob/master/mypics/%E5%8E%9F%E5%A7%8BByteBuffer.png?raw=true" alt=""></p><p>调用<code>slice</code>方法分割后得到的新<code>ByteBuffer</code>：</p><p><img src="https://github.com/muyinchen/woker/blob/master/mypics/slice%E6%96%B0bytebuffer.png?raw=true" alt=""></p><p>本篇到此为止，在下一篇中，我会着重讲下<code>DirectByteBuffer</code>的实现细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。&lt;/p&gt;
&lt;p&gt;关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:&lt;/p&gt;
&lt;p&gt;Rxjava源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av34537840&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av34537840&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Reactor源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av35326911&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av35326911&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列源码解读基于JDK11 api细节可能与其他版本有所差别，请自行解决jdk版本问题。&lt;/p&gt;
&lt;p&gt;本系列前几篇:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c2cc075f265da611037298e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BIO到NIO源码的一些事儿之BIO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c2e23156fb9a049ff4e4009&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BIO到NIO源码的一些事儿之NIO 上&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c34d1dd6fb9a049c84fa2ce&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BIO到NIO源码的一些事儿之NIO 中&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c3a01d851882525c55fad36&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BIO到NIO源码的一些事儿之NIO 下 之 Selector&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="响应式" scheme="https://muyinchen.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
      <category term="Reactor Rxjava  NIO" scheme="https://muyinchen.github.io/tags/Reactor-Rxjava-NIO/"/>
    
  </entry>
  
  <entry>
    <title>BIO到NIO源码的一些事儿之NIO 下 之 Selector</title>
    <link href="https://muyinchen.github.io/2019/01/12/BIO%E5%88%B0NIO%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF%E4%B9%8BNIO%20%E4%B8%8B%20%E4%B9%8B%20Selector/"/>
    <id>https://muyinchen.github.io/2019/01/12/BIO到NIO源码的一些事儿之NIO 下 之 Selector/</id>
    <published>2019-01-12T15:40:25.000Z</published>
    <updated>2019-01-12T15:48:02.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。</p><p>关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:</p><p>Rxjava源码解读与分享：<a href="https://www.bilibili.com/video/av34537840" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840</a></p><p>Reactor源码解读与分享：<a href="https://www.bilibili.com/video/av35326911" target="_blank" rel="noopener">https://www.bilibili.com/video/av35326911</a></p><p>本系列源码解读基于JDK11 api细节可能与其他版本有所差别，请自行解决jdk版本问题。</p><p>本系列前几篇:</p><p><a href="https://juejin.im/post/5c2cc075f265da611037298e" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之BIO</a></p><p><a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a></p><p><a href="https://juejin.im/post/5c34d1dd6fb9a049c84fa2ce" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 中</a></p><a id="more"></a><h2 id="SelectionKey的引入"><a href="#SelectionKey的引入" class="headerlink" title="SelectionKey的引入"></a>SelectionKey的引入</h2><p>如我们在前面内容所讲，在学生确定之后，我们就要对其状态进行设定，然后再交由<code>Selector</code>进行管理，其状态的设定我们就通过<code>SelectionKey</code>来进行。</p><p>那这里我们先通过之前在<code>Channel</code>中并未仔细讲解的<code>SelectableChannel</code>下的<code>register</code>方法。我们前面有提到过， <code>SelectableChannel</code>将<code>channel</code>打造成可以通过<code>Selector</code>来进行多路复用。作为管理者，<code>channel</code>想要实现复用，就必须在管理者这里进行注册登记。所以，<code>SelectableChannel</code>下的<code>register</code>方法也就是我们值得二次关注的核心了，也是对接我们接下来内容的切入点，对于<code>register</code>方法的解读，请看我们之前的文章<a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a> 中<strong>赋予Channel可被多路复用的能力</strong>这一节的内容。</p><p>这里要记住的是<code>SelectableChannel</code>是对接<code>channel</code>特征(即<code>SelectionKey</code>)的关键所在，这有点类似于表设计，原本可以将特征什么的设定在一张表内，但为了操作更加具有针对性，即为了让代码功能更易于管理，就进行抽取并设计了第二张表，这个就有点像人体器官，整体上大家共同协作完成一件事，但器官内部自己专注于自己的主要特定功能，偶尔也具备其他器官的一些小功能。</p><p>由此，我们也就可以知道，<code>SelectionKey</code>表示一个<code>SelectableChannel</code>与<code>Selector</code>关联的标记，可以简单理解为一个<code>token</code>。就好比是我们做权限管理系统用户登录后前台会从后台拿到的一个<code>token</code>一样，用户可以凭借此<code>token</code>来访问操作相应的资源信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#register</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function"></span>&#123;       ...</span><br><span class="line">    <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">           ...</span><br><span class="line">            SelectionKey k = findKey(sel);</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                k.attach(att);</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// New registration</span></span><br><span class="line">                k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">                addKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结合上下两段源码，在每次<code>Selector</code>使用<code>register</code>方法注册<code>channel</code>时，都会创建并返回一个<code>SelectionKey</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#register</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel ch,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object attachment)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(ch <span class="keyword">instanceof</span> SelChImpl))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalSelectorException();</span><br><span class="line">    SelectionKeyImpl k = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)ch, <span class="keyword">this</span>);</span><br><span class="line">    k.attach(attachment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register (if needed) before adding to key set</span></span><br><span class="line">    implRegister(k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add to the selector's key set, removing it immediately if the selector</span></span><br><span class="line">    <span class="comment">// is closed. The key is not in the channel's key set at this point but</span></span><br><span class="line">    <span class="comment">// it may be observed by a thread iterating over the selector's key set.</span></span><br><span class="line">    keys.add(k);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        k.interestOps(ops);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClosedSelectorException e) &#123;</span><br><span class="line">        <span class="keyword">assert</span> ch.keyFor(<span class="keyword">this</span>) == <span class="keyword">null</span>;</span><br><span class="line">        keys.remove(k);</span><br><span class="line">        k.cancel();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在<a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a> 中<strong>赋予Channel可被多路复用的能力</strong>这一节的内容知道，一旦注册到<code>Selector</code>上，<code>Channel</code>将一直保持注册直到其被解除注册。在解除注册的时候会解除<code>Selector</code>分配给<code>Channel</code>的所有资源。<br>也就是<code>SelectionKey</code>在其调用<code>SelectionKey#channel</code>方法，或这个key所代表的<code>channel</code> 关闭，抑或此key所关联的<code>Selector</code>关闭之前，都是有效。我们在前面的文章分析中也知道，取消一个<code>SelectionKey</code>，不会立刻从<code>Selector</code>移除，它将被添加到<code>Selector</code>的<code>cancelledKeys</code>这个<code>Set</code>集合中，以便在下一次选择操作期间删除，我们可以通过<code>java.nio.channels.SelectionKey#isValid</code>判断一个<code>SelectionKey</code>是否有效。 </p><p>SelectionKey包含四个操作集，每个操作集用一个Int来表示，int值中的低四位的bit 用于表示<code>channel</code>支持的可选操作种类。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Operation-set bit for read operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Operation-set bit for write operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Operation-set bit for socket-connect operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Operation-set bit for socket-accept operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p><h3 id="interestOps"><a href="#interestOps" class="headerlink" title="interestOps"></a>interestOps</h3><p>通过<code>interestOps</code>来确定了<code>selector</code>在下一个选择操作的过程中将测试哪些操作类别的准备情况，操作事件是否是<code>channel</code>关注的。<code>interestOps</code> 在<code>SelectionKey</code>创建时，初始化为注册<code>Selector</code>时的ops值，这个值可通过<code>sun.nio.ch.SelectionKeyImpl#interestOps(int)</code>来改变，这点我们在<code>SelectorImpl#register</code>可以清楚的看到。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//sun.nio.ch.SelectionKeyImpl</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionKeyImpl</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSelectionKey</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle INTERESTOPS =</span><br><span class="line">            ConstantBootstraps.fieldVarHandle(</span><br><span class="line">                    MethodHandles.lookup(),</span><br><span class="line">                    <span class="string">"interestOps"</span>,</span><br><span class="line">                    VarHandle.class,</span><br><span class="line">                    SelectionKeyImpl.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelChImpl channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectorImpl selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> interestOps;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> readyOps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// registered events in kernel, used by some Selector implementations</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> registeredEvents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index of key in pollfd array, used by some Selector implementations</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    SelectionKeyImpl(SelChImpl ch, SelectorImpl sel) &#123;</span><br><span class="line">        channel = ch;</span><br><span class="line">        selector = sel;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="readyOps"><a href="#readyOps" class="headerlink" title="readyOps"></a>readyOps</h3><p><code>readyOps</code>表示通过<code>Selector</code>检测到<code>channel</code>已经准备就绪的操作事件。在<code>SelectionKey</code>创建时（即上面源码所示），<code>readyOps</code>值为0，在<code>Selector</code>的<code>select</code>操作中可能会更新，但是需要注意的是我们不能直接调用来更新。</p><p><code>SelectionKey</code>的<code>readyOps</code>表示一个<code>channel</code>已经为某些操作准备就绪，但不能保证在针对这个就绪事件类型的操作过程中不会发生阻塞，即该操作所在线程有可能会发生阻塞。在完成<code>select</code>操作后，大部分情况下会立即对<code>readyOps</code>更新，此时<code>readyOps</code>值最准确，如果外部的事件或在该<code>channel</code>有IO操作，<code>readyOps</code>可能不准确。所以，我们有看到其是<code>volatile</code>类型。</p><p><code>SelectionKey</code>定义了所有的操作事件，但是具体<code>channel</code>支持的操作事件依赖于具体的<code>channel</code>，即具体问题具体分析。<br>所有可选择的<code>channel</code>（即<code>SelectableChannel</code>的子类）都可以通过<code>SelectableChannel#validOps</code>方法，判断一个操作事件是否被<code>channel</code>所支持，即每个子类都会有对<code>validOps</code>的实现，返回一个数字，仅标识<code>channel</code>支持的哪些操作。尝试设置或测试一个不被<code>channel</code>所支持的操作设定，将会抛出相关的运行时异常。<br>不同应用场景下，其所支持的<code>Ops</code>是不同的，摘取部分如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.SocketChannel#validOps</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//即1|4|8  1101</span></span><br><span class="line">    <span class="keyword">return</span> (SelectionKey.OP_READ</span><br><span class="line">            | SelectionKey.OP_WRITE</span><br><span class="line">            | SelectionKey.OP_CONNECT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.channels.ServerSocketChannel#validOps</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">return</span> SelectionKey.OP_ACCEPT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.channels.DatagramChannel#validOps</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1|4</span></span><br><span class="line">    <span class="keyword">return</span> (SelectionKey.OP_READ</span><br><span class="line">            | SelectionKey.OP_WRITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果需要经常关联一些我们程序中指定数据到<code>SelectionKey</code>，比如一个我们使用一个object表示上层的一种高级协议的状态，object用于通知实现协议处理器。所以，SelectionKey支持通过<code>attach</code>方法将一个对象附加到<code>SelectionKey</code>的<code>attachment</code>上。<code>attachment</code>可以通过<code>java.nio.channels.SelectionKey#attachment</code>方法进行访问。如果要取消该对象，则可以通过该种方式:<code>selectionKey.attach(null)</code>。</p><p>需要注意的是如果附加的对象不再使用，一定要人为清除，如果没有，假如此<code>SelectionKey</code>一直存在，由于此处属于强引用，那么垃圾回收器不会回收该对象，若不清除的话会成内存泄漏。</p><p>SelectionKey在由多线程并发使用时，是线程安全的。我们只需要知道，<code>Selector</code>的<code>select</code>操作会一直使用在调用该操作开始时当前的<code>interestOps</code>所设定的值。</p><h2 id="Selector探究"><a href="#Selector探究" class="headerlink" title="Selector探究"></a>Selector探究</h2><p>到现在为止，我们已经多多少少接触了<code>Selector</code>，其是一个什么样的角色，想必都很清楚了，那我们就在我们已经接触到的来进一步深入探究<code>Selector</code>的设计运行机制。</p><h3 id="Selector的open方法"><a href="#Selector的open方法" class="headerlink" title="Selector的open方法"></a>Selector的open方法</h3><p>从命名上就可以知道 <code>SelectableChannel</code>对象是依靠<code>Selector</code>来实现多路复用的。<br>我们可以通过调用<code>java.nio.channels.Selector#open</code>来创建一个<code>selector</code>对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.Selector#open</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于这个<code>SelectorProvider.provider()</code>，其使用了根据所在系统的默认实现，我这里是windows系统，那么其默认实现为<code>sun.nio.ch.WindowsSelectorProvider</code>，这样，就可以调用基于相应系统的具体实现了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.SelectorProvider#provider</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.DefaultSelectorProvider</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prevent instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectorProvider</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the default SelectorProvider.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.WindowsSelectorProvider();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基于windows来讲，selector这里最终会使用<code>sun.nio.ch.WindowsSelectorImpl</code>来做一些核心的逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsSelectorProvider</span> <span class="keyword">extends</span> <span class="title">SelectorProviderImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractSelector <span class="title">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowsSelectorImpl(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，我们需要来看一下<code>WindowsSelectorImpl</code>的构造函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#WindowsSelectorImpl</span></span><br><span class="line">WindowsSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    pollWrapper = <span class="keyword">new</span> PollArrayWrapper(INIT_CAP);</span><br><span class="line">    wakeupPipe = Pipe.open();</span><br><span class="line">    wakeupSourceFd = ((SelChImpl)wakeupPipe.source()).getFDVal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable the Nagle algorithm so that the wakeup is more immediate</span></span><br><span class="line">    SinkChannelImpl sink = (SinkChannelImpl)wakeupPipe.sink();</span><br><span class="line">    (sink.sc).socket().setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">    wakeupSinkFd = ((SelChImpl)sink).getFDVal();</span><br><span class="line"></span><br><span class="line">    pollWrapper.addWakeupSocket(wakeupSourceFd, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们由<code>Pipe.open()</code>就可知道<code>selector</code>会保持打开的状态，直到其调用它的<code>close</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelector#close</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> open = selectorOpen.getAndSet(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!open)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    implCloseSelector();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#implCloseSelector</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">implCloseSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    wakeup();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        implClose();</span><br><span class="line">        <span class="keyword">synchronized</span> (publicSelectedKeys) &#123;</span><br><span class="line">            <span class="comment">// Deregister channels</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; i = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                SelectionKeyImpl ski = (SelectionKeyImpl)i.next();</span><br><span class="line">                deregister(ski);</span><br><span class="line">                SelectableChannel selch = ski.channel();</span><br><span class="line">                <span class="keyword">if</span> (!selch.isOpen() &amp;&amp; !selch.isRegistered())</span><br><span class="line">                    ((SelChImpl)selch).kill();</span><br><span class="line">                selectedKeys.remove(ski);</span><br><span class="line">                i.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> selectedKeys.isEmpty() &amp;&amp; keys.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#implClose</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implClose</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> !isOpen();</span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prevent further wakeup</span></span><br><span class="line">    <span class="keyword">synchronized</span> (interruptLock) &#123;</span><br><span class="line">        interruptTriggered = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wakeupPipe.sink().close();</span><br><span class="line">    wakeupPipe.source().close();</span><br><span class="line">    pollWrapper.free();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make all remaining helper threads exit</span></span><br><span class="line">    <span class="keyword">for</span> (SelectThread t: threads)</span><br><span class="line">            t.makeZombie();</span><br><span class="line">    startLock.startThreads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，前面的<code>wakeupPipe</code>在close方法中关闭掉了。这里的close方法中又涉及了<code>wakeupPipe.sink()</code>与<code>wakeupPipe.source()</code>的关闭与<code>pollWrapper.free()</code>的释放，此处也是我们本篇的难点所在，这里，我们来看看它们到底是什么样的存在。<br>首先，我们对<code>WindowsSelectorImpl(SelectorProvider sp)</code>这个构造函数做下梳理:</p><ul><li>创建一个<code>PollArrayWrapper</code>对象（<code>pollWrapper</code>）；</li><li><code>Pipe.open()</code>打开一个管道；</li><li>拿到<code>wakeupSourceFd</code>和<code>wakeupSinkFd</code>两个文件描述符；</li><li>把pipe内Source端的文件描述符（<code>wakeupSourceFd</code>）放到<code>pollWrapper</code>里；<h4 id="Pipe-open-的解惑"><a href="#Pipe-open-的解惑" class="headerlink" title="Pipe.open()的解惑"></a>Pipe.open()的解惑</h4>这里我们会有疑惑，为什么要创建一个管道，它是用来做什么的。</li></ul><p>我们来看<code>Pipe.open()</code>源码实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.Pipe#open</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pipe <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openPipe();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorProviderImpl#openPipe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pipe <span class="title">openPipe</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PipeImpl(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.PipeImpl#PipeImpl</span></span><br><span class="line">PipeImpl(<span class="keyword">final</span> SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> Initializer(sp));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PrivilegedActionException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException)x.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Initializer</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">PrivilegedExceptionAction</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider sp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IOException ioe = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Initializer</span><span class="params">(SelectorProvider sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sp = sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    LoopbackConnector connector = <span class="keyword">new</span> LoopbackConnector();</span><br><span class="line">    connector.run();</span><br><span class="line">    <span class="keyword">if</span> (ioe <span class="keyword">instanceof</span> ClosedByInterruptException) &#123;</span><br><span class="line">        ioe = <span class="keyword">null</span>;</span><br><span class="line">        Thread connThread = <span class="keyword">new</span> Thread(connector) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        connThread.start();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connThread.join();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioe != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unable to establish loopback connection"</span>, ioe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述源码我们可以知道，创建了一个<code>PipeImpl</code>对象， 在<code>PipeImpl</code>的构造函数里会执行<code>AccessController.doPrivileged</code>，在它调用后紧接着会执行<code>Initializer</code>的<code>run</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.PipeImpl.Initializer.LoopbackConnector</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopbackConnector</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = <span class="keyword">null</span>;</span><br><span class="line">        SocketChannel sc1 = <span class="keyword">null</span>;</span><br><span class="line">        SocketChannel sc2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Create secret with a backing array.</span></span><br><span class="line">            ByteBuffer secret = ByteBuffer.allocate(NUM_SECRET_BYTES);</span><br><span class="line">            ByteBuffer bb = ByteBuffer.allocate(NUM_SECRET_BYTES);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Loopback address</span></span><br><span class="line">            InetAddress lb = InetAddress.getLoopbackAddress();</span><br><span class="line">            <span class="keyword">assert</span>(lb.isLoopbackAddress());</span><br><span class="line">            InetSocketAddress sa = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                <span class="comment">// Bind ServerSocketChannel to a port on the loopback</span></span><br><span class="line">                <span class="comment">// address</span></span><br><span class="line">                <span class="keyword">if</span> (ssc == <span class="keyword">null</span> || !ssc.isOpen()) &#123;</span><br><span class="line">                    ssc = ServerSocketChannel.open();</span><br><span class="line">                    ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(lb, <span class="number">0</span>));</span><br><span class="line">                    sa = <span class="keyword">new</span> InetSocketAddress(lb, ssc.socket().getLocalPort());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Establish connection (assume connections are eagerly</span></span><br><span class="line">                <span class="comment">// accepted)</span></span><br><span class="line">                sc1 = SocketChannel.open(sa);</span><br><span class="line">                RANDOM_NUMBER_GENERATOR.nextBytes(secret.array());</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    sc1.write(secret);</span><br><span class="line">                &#125; <span class="keyword">while</span> (secret.hasRemaining());</span><br><span class="line">                secret.rewind();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get a connection and verify it is legitimate</span></span><br><span class="line">                sc2 = ssc.accept();</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    sc2.read(bb);</span><br><span class="line">                &#125; <span class="keyword">while</span> (bb.hasRemaining());</span><br><span class="line">                bb.rewind();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bb.equals(secret))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                sc2.close();</span><br><span class="line">                sc1.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create source and sink channels</span></span><br><span class="line">            source = <span class="keyword">new</span> SourceChannelImpl(sp, sc1);</span><br><span class="line">            sink = <span class="keyword">new</span> SinkChannelImpl(sp, sc2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc1 != <span class="keyword">null</span>)</span><br><span class="line">                    sc1.close();</span><br><span class="line">                <span class="keyword">if</span> (sc2 != <span class="keyword">null</span>)</span><br><span class="line">                    sc2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;&#125;</span><br><span class="line">            ioe = e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ssc != <span class="keyword">null</span>)</span><br><span class="line">                    ssc.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里即为创建<code>pipe</code>的过程，<code>windows</code>下的实现是创建两个本地的<code>socketChannel</code>，然后连接（连接的过程通过写一个随机数据做两个socket的连接校验），两个<code>socketChannel</code>分别实现了管道<code>pipe</code>的<code>source</code>与<code>sink</code>端。<br>而我们依然不清楚这个<code>pipe</code>到底干什么用的，<br>假如大家熟悉系统调用的<code>C/C++</code>的话，就可以知道，一个阻塞在<code>select</code>上的线程有以下三种方式可以被唤醒：</p><ol><li>有数据可读/写，或出现异常。</li><li>阻塞时间到，即<code>time out</code>。</li><li>收到一个<code>non-block</code>的信号。可由<code>kill</code>或<code>pthread_kill</code>发出。</li></ol><p>所以，<code>Selector.wakeup()</code>要唤醒阻塞的<code>select</code>，那么也只能通过这三种方法，其中：</p><ul><li>第二种方法可以排除，因为<code>select</code>一旦阻塞，无法修改其<code>time out</code>时间。</li><li>而第三种看来只能在<code>Linux</code>上实现，<code>Windows</code>上没有这种信号通知的机制。</li></ul><p>看来只有第一种方法了。假如我们多次调用<code>Selector.open()</code>，那么在<code>Windows</code>上会每调用一次，就会建立一对自己和自己的<code>loopback</code>的<code>TCP</code>连接；在Linux上的话，每调用一次，会开一对<code>pipe</code>（pipe在Linux下一般都成对打开），到这里，估计我们能够猜得出来——那就是如果想要唤醒<code>select</code>，只需要朝着自己的这个<code>loopback</code>连接发点数据过去，于是，就可以唤醒阻塞在<code>select</code>上的线程了。</p><p>我们对上面所述做下总结:在<code>Windows</code>下，<code>Java</code>虚拟机在<code>Selector.open()</code>时会自己和自己建立<code>loopback</code>的<code>TCP</code>连接；在<code>Linux</code>下，<code>Selector</code>会创建<code>pipe</code>。这主要是为了<code>Selector.wakeup()</code>可以方便唤醒阻塞在<code>select()</code>系统调用上的线程（通过向自己所建立的<code>TCP</code>链接和管道上随便写点什么就可以唤醒阻塞线程）。</p><h3 id="PollArrayWrapper解读"><a href="#PollArrayWrapper解读" class="headerlink" title="PollArrayWrapper解读"></a>PollArrayWrapper解读</h3><p>在<code>WindowsSelectorImpl</code>构造器最后，我们看到这一句代码:<code>pollWrapper.addWakeupSocket(wakeupSourceFd, 0);</code>，即把pipe内Source端的文件描述符（<code>wakeupSourceFd</code>）放到<code>pollWrapper</code>里。<code>pollWrapper</code>作为<code>PollArrayWrapper</code>的实例，它到底是什么，这一节，我们就来对其探索一番。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PollArrayWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AllocatedNativeObject pollArray; <span class="comment">// The fd array</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> pollArrayAddress; <span class="comment">// pollArrayAddress</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> FD_OFFSET     = <span class="number">0</span>; <span class="comment">// fd offset in pollfd</span></span><br><span class="line">    <span class="meta">@Native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> EVENT_OFFSET  = <span class="number">4</span>; <span class="comment">// events offset in pollfd</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">short</span> SIZE_POLLFD = <span class="number">8</span>; <span class="comment">// sizeof pollfd struct</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// Size of the pollArray</span></span><br><span class="line"></span><br><span class="line">    PollArrayWrapper(<span class="keyword">int</span> newSize) &#123;</span><br><span class="line">        <span class="keyword">int</span> allocationSize = newSize * SIZE_POLLFD;</span><br><span class="line">        pollArray = <span class="keyword">new</span> AllocatedNativeObject(allocationSize, <span class="keyword">true</span>);</span><br><span class="line">        pollArrayAddress = pollArray.address();</span><br><span class="line">        <span class="keyword">this</span>.size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access methods for fd structures</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putDescriptor</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">        pollArray.putInt(SIZE_POLLFD * i + FD_OFFSET, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putEventOps</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">        pollArray.putShort(SIZE_POLLFD * i + EVENT_OFFSET, (<span class="keyword">short</span>)event);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">// Adds Windows wakeup socket at a given index.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWakeupSocket</span><span class="params">(<span class="keyword">int</span> fdVal, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        putDescriptor(index, fdVal);</span><br><span class="line">        putEventOps(index, Net.POLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里将<code>wakeupSourceFd</code>的<code>POLLIN</code>事件标识为<code>pollArray</code>的<code>EventOps</code>的对应的值，这里使用的是unsafe直接操作的内存，也就是相对于这个<code>pollArray</code>所在内存地址的偏移量<code>SIZE_POLLFD * i + EVENT_OFFSET</code>这个位置上写入<code>Net.POLLIN</code>所代表的值，即参考下面本地方法相关源码所展示的值。<code>putDescriptor</code>同样是这种类似操作。当<code>sink端</code>有数据写入时，<code>source</code>对应的文件描述符<code>wakeupSourceFd</code>就会处于就绪状态。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.base/windows/native/libnio/ch/nio_util.h</span></span><br><span class="line">    <span class="comment">/* WSAPoll()/WSAPOLLFD and the corresponding constants are only defined   */</span></span><br><span class="line">    <span class="comment">/* in Windows Vista / Windows Server 2008 and later. If we are on an      */</span></span><br><span class="line">    <span class="comment">/* older release we just use the Solaris constants as this was previously */</span></span><br><span class="line">    <span class="comment">/* done in PollArrayWrapper.java.                                         */</span></span><br><span class="line">    #define POLLIN       0x0001</span><br><span class="line">    #define POLLOUT      0x0004</span><br><span class="line">    #define POLLERR      0x0008</span><br><span class="line">    #define POLLHUP      0x0010</span><br><span class="line">    #define POLLNVAL     0x0020</span><br><span class="line">    #define POLLCONN     0x0002</span><br></pre></td></tr></table></figure></p><p><code>AllocatedNativeObject</code>这个类的父类有大量的<code>unsafe</code>类的操作，这些都是直接基于内存级别的操作。从其父类的构造器中，我们能也清楚的看到<code>pollArray</code>是通过<code>unsafe.allocateMemory(size + ps)</code>分配的一块系统内存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllocatedNativeObject</span>                             // <span class="title">package</span>-<span class="title">private</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">NativeObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allocates a memory area of at least &#123;<span class="doctag">@code</span> size&#125; bytes outside of the</span></span><br><span class="line"><span class="comment">     * Java heap and creates a native object for that area.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AllocatedNativeObject(<span class="keyword">int</span> size, <span class="keyword">boolean</span> pageAligned) &#123;</span><br><span class="line">        <span class="keyword">super</span>(size, pageAligned);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Frees the native memory area associated with this object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (allocationAddress != <span class="number">0</span>) &#123;</span><br><span class="line">            unsafe.freeMemory(allocationAddress);</span><br><span class="line">            allocationAddress = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.NativeObject#NativeObject(int, boolean)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">NativeObject</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">boolean</span> pageAligned)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pageAligned) &#123;</span><br><span class="line">            <span class="keyword">this</span>.allocationAddress = unsafe.allocateMemory(size);</span><br><span class="line">            <span class="keyword">this</span>.address = <span class="keyword">this</span>.allocationAddress;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ps = pageSize();</span><br><span class="line">            <span class="keyword">long</span> a = unsafe.allocateMemory(size + ps);</span><br><span class="line">            <span class="keyword">this</span>.allocationAddress = a;</span><br><span class="line">            <span class="keyword">this</span>.address = a + ps - (a &amp; (ps - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们算是完成了对<code>Selector.open()</code>的解读，其主要任务就是完成建立<code>Pipe</code>，并把<code>pipe</code> <code>source</code>端的<code>wakeupSourceFd</code>放入<code>pollArray</code>中，这个<code>pollArray</code>是<code>Selector</code>完成其角色任务的枢纽。本篇主要围绕Windows的实现来进行分析，即在windows下通过两个连接的<code>socketChannel</code>实现了<code>Pipe</code>，<code>linux</code>下则直接使用系统的<code>pipe</code>即可。</p><h3 id="SelectionKey在selector中的管理"><a href="#SelectionKey在selector中的管理" class="headerlink" title="SelectionKey在selector中的管理"></a>SelectionKey在selector中的管理</h3><h4 id="SelectionKey在selector中注册"><a href="#SelectionKey在selector中注册" class="headerlink" title="SelectionKey在selector中注册"></a>SelectionKey在selector中注册</h4><p>所谓的注册，其实就是将一个对象放到注册地对象内的一个容器字段上，这个字段可以是数组，队列，也可以是一个set集合，也可以是一个list。这里，同样是这样，只不过，其需要有个返回值，那么把这个要放入集合的对象返回即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#register</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel ch,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object attachment)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(ch <span class="keyword">instanceof</span> SelChImpl))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalSelectorException();</span><br><span class="line">    SelectionKeyImpl k = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)ch, <span class="keyword">this</span>);</span><br><span class="line">    k.attach(attachment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register (if needed) before adding to key set</span></span><br><span class="line">    implRegister(k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add to the selector's key set, removing it immediately if the selector</span></span><br><span class="line">    <span class="comment">// is closed. The key is not in the channel's key set at this point but</span></span><br><span class="line">    <span class="comment">// it may be observed by a thread iterating over the selector's key set.</span></span><br><span class="line">    keys.add(k);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        k.interestOps(ops);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClosedSelectorException e) &#123;</span><br><span class="line">        <span class="keyword">assert</span> ch.keyFor(<span class="keyword">this</span>) == <span class="keyword">null</span>;</span><br><span class="line">        keys.remove(k);</span><br><span class="line">        k.cancel();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#implRegister</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">synchronized</span> (updateLock) &#123;</span><br><span class="line">        newKeys.addLast(ski);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码我们之前已经有看过，这里我们再次温习下。<br>首先会新建一个<code>SelectionKeyImpl</code>对象，这个对象就是对<code>Channel</code>的包装，不仅如此，还顺带把当前这个<code>Selector</code>对象给收了进去，这样，我们也可以通过<code>SelectionKey</code>的对象来拿到其对应的<code>Selector</code>对象。</p><p>接着，基于<code>windows</code>平台实现的<code>implRegister</code>，先通过<code>ensureOpen()</code>来确保该<code>Selector</code>是打开的。接着将这个<code>SelectionKeyImpl</code>加入到<code>WindowsSelectorImpl</code>内针对于<strong>新注册</strong>SelectionKey进行管理的<code>newKeys</code>之中，<code>newKeys</code>是一个<code>ArrayDeque</code>对象。对于<code>ArrayDeque</code>有不懂的，可以参考<a href="https://github.com/muyinchen/woker/blob/master/JAVA8/jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Java%20%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20Deque%20%E4%B8%8E%20ArrayDeque.md" target="_blank" rel="noopener">Java 容器源码分析之 Deque 与 ArrayDeque</a>这篇文章。</p><p>然后再将此这个<code>SelectionKeyImpl</code>加入到<code>sun.nio.ch.SelectorImpl#keys</code>中去，这个<code>Set&lt;SelectionKey&gt;</code>集合代表那些已经注册到当前这个<code>Selector</code>对象上的<code>SelectionKey</code>集合。我们来看<code>sun.nio.ch.SelectorImpl</code>的构造函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#SelectorImpl</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    keys = ConcurrentHashMap.newKeySet();</span><br><span class="line">    selectedKeys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    publicKeys = Collections.unmodifiableSet(keys);</span><br><span class="line">    publicSelectedKeys = Util.ungrowableSet(selectedKeys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是说，这里的<code>publicKeys</code>就来源于<code>keys</code>，只是<code>publicKeys</code>属于只读的，我们想要知道当前<code>Selector</code>对象上所注册的<code>keys</code>，就可以调用<code>sun.nio.ch.SelectorImpl#keys</code>来得到:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#keys</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">return</span> publicKeys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再回到这个构造函数中，<code>selectedKeys</code>，顾名思义，其属于已选择Keys，即前一次操作期间，已经准备就绪的<code>Channel</code>所对应的<code>SelectionKey</code>。此集合为<code>keys</code>的子集。通过<code>selector.selectedKeys()</code>获取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#selectedKeys</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; <span class="title">selectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">return</span> publicSelectedKeys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到其返回的是<code>publicSelectedKeys</code>，针对这个字段里的元素操作可以做删除，但不能做增加。<br>在前面的内容中，我们有涉及到<code>SelectionKey</code>的取消，所以，我们在<code>java.nio.channels.spi.AbstractSelector</code>方法内，是有定义<code>cancelledKeys</code>的，也是一个<code>HashSet</code>对象。其代表已经被取消但尚未取消注册(deregister)的<code>SelectionKey</code>。此Set集合无法直接访问，同样，它也是keys()的子集。</p><p>对于新的<code>Selector</code>实例，上面几个集合均为空。由上面展示的源码可知，通过<code>channel.register</code>将<code>SelectionKey</code>添加<code>keys</code>中，此为key的来源。<br>如果某个<code>selectionKey.cancel()</code>被调用,那么此key将会被添加到<code>cancelledKeys</code>这个集合中，然后在下一次调用selector <code>select</code>方法期间，此时<code>canceldKeys</code>不为空，将会触发此<code>SelectionKey</code>的<code>deregister</code>操作(释放资源,并从<code>keys</code>中移除)。无论通过<code>channel.close()</code>还是通过<code>selectionKey.cancel()</code>，都会导致<code>SelectionKey</code>被加入到<code>cannceldKey</code>中.</p><p>每次选择操作(select)期间，都可以将key添加到<code>selectedKeys</code>中或者将从<code>cancelledKeys</code>中移除。</p><h4 id="Selector的select方法的解读"><a href="#Selector的select方法的解读" class="headerlink" title="Selector的select方法的解读"></a>Selector的select方法的解读</h4><p>了解了上面的这些，我们来进入到<code>select</code>方法中，观察下它的细节。由<code>Selector</code>的api可知，<code>select</code>操作有两种形式，一种为<br>select(),selectNow(),select(long timeout);另一种为<code>select(Consumer&lt;SelectionKey&gt; action, long timeout)</code>，<code>select(Consumer&lt;SelectionKey&gt; action)</code>，<code>selectNow(Consumer&lt;SelectionKey&gt; action)</code>。后者为JDK11新加入的api，主要针对那些准备好进行I/O操作的channels在select过程中对相应的key进行的一个字的自定义的一个操作。<br>需要注意的是，有<code>Consumer&lt;SelectionKey&gt; action</code>参数的select操作是阻塞的，只有在选择了至少一个Channel的情况下，才会调用此<code>Selector</code>实例的<code>wakeup</code>方法来唤醒，同样，其所在线程被打断也可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative timeout"</span>);</span><br><span class="line">    <span class="keyword">return</span> lockAndDoSelect(<span class="keyword">null</span>, (timeout == <span class="number">0</span>) ? -<span class="number">1</span> : timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(Consumer&lt;SelectionKey&gt; action, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative timeout"</span>);</span><br><span class="line">    <span class="keyword">return</span> lockAndDoSelect(action, (timeout == <span class="number">0</span>) ? -<span class="number">1</span> : timeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#lockAndDoSelect</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockAndDoSelect</span><span class="params">(Consumer&lt;SelectionKey&gt; action, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">if</span> (inSelect)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"select in progress"</span>);</span><br><span class="line">            inSelect = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (publicSelectedKeys) &#123;</span><br><span class="line">                    <span class="keyword">return</span> doSelect(action, timeout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                inSelect = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以观察，无论哪种，它们最后都落在了<code>lockAndDoSelect</code>这个方法上，最终会执行特定系统上的<code>doSelect(action, timeout)</code>实现。<br>这里我们以<code>sun.nio.ch.WindowsSelectorImpl#doSelect</code>为例来讲述其操作执行的步骤:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.nio.ch.WindowsSelectorImpl#doSelect</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(Consumer&lt;SelectionKey&gt; action, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout; <span class="comment">// set selector timeout</span></span><br><span class="line">        processUpdateQueue();  <span class="comment">// &lt;1&gt;</span></span><br><span class="line">        processDeregisterQueue(); <span class="comment">// &lt;2&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (interruptTriggered) &#123;</span><br><span class="line">            resetWakeupSocket();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Calculate number of helper threads needed for poll. If necessary</span></span><br><span class="line">        <span class="comment">// threads are created here and start waiting on startLock</span></span><br><span class="line">        adjustThreadsCount();</span><br><span class="line">        finishLock.reset(); <span class="comment">// reset finishLock</span></span><br><span class="line">        <span class="comment">// Wakeup helper threads, waiting on startLock, so they start polling.</span></span><br><span class="line">        <span class="comment">// Redundant threads will exit here after wakeup.</span></span><br><span class="line">        startLock.startThreads();</span><br><span class="line">        <span class="comment">// do polling in the main thread. Main thread is responsible for</span></span><br><span class="line">        <span class="comment">// first MAX_SELECTABLE_FDS entries in pollArray.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                subSelector.poll();  <span class="comment">// &lt;3&gt;</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                finishLock.setException(e); <span class="comment">// Save this exception</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Main thread is out of poll(). Wakeup others and wait for them</span></span><br><span class="line">            <span class="keyword">if</span> (threads.size() &gt; <span class="number">0</span>)</span><br><span class="line">                finishLock.waitForHelperThreads();</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              end();</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// Done with poll(). Set wakeupSocket to nonsignaled  for the next run.</span></span><br><span class="line">        finishLock.checkForException();</span><br><span class="line">        processDeregisterQueue();  <span class="comment">// &lt;4&gt;</span></span><br><span class="line">        <span class="keyword">int</span> updated = updateSelectedKeys(action); <span class="comment">// &lt;5&gt;</span></span><br><span class="line">        <span class="comment">// Done with poll(). Set wakeupSocket to nonsignaled  for the next run.</span></span><br><span class="line">        resetWakeupSocket(); <span class="comment">// &lt;6&gt;</span></span><br><span class="line">        <span class="keyword">return</span> updated;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="processUpdateQueue解读"><a href="#processUpdateQueue解读" class="headerlink" title="processUpdateQueue解读"></a>processUpdateQueue解读</h4><ol><li><p>首先通过相应操作系统实现类（此处是WindowsSelectorImpl）的具体实现我们可以知道，通过<code>&lt;1&gt;</code> 处的 <code>processUpdateQueue()</code>获得关于每个剩余<code>Channel</code>（有些Channel取消了）的在此刻的<code>interestOps</code>，这里包括新注册的和<code>updateKeys</code>，并对其进行<code>pollWrapper</code>的管理操作。</p><blockquote><ul><li><p>即对于新注册的<code>SelectionKeyImpl</code>，我们在相对于这个<code>pollArray</code>所在内存地址的偏移量<code>SIZE_POLLFD * totalChannels + FD_OFFSET</code>与<code>SIZE_POLLFD * totalChannels + EVENT_OFFSET</code>分别存入<code>SelectionKeyImpl</code>的文件描述符<code>fd</code>与其对应的<code>EventOps</code>（初始为0）。</p></li><li><p>对<code>updateKeys</code>，因为是其之前已经在<code>pollArray</code>的某个相对位置上存储过，这里我们还需要对拿到的key的有效性进行判断，如果有效，只需要将正在操作的这个<code>SelectionKeyImpl</code>对象的<code>interestOps</code>写入到在<code>pollWrapper</code>中的存放它的<code>EventOps</code>位置上。</p></li></ul><p><strong>注意</strong>: 在对<code>newKeys</code>进行key的有效性判断之后，如果有效，会调用<code>growIfNeeded()</code>方法，这里首先会判断<code>channelArray.length == totalChannels</code>，此为一个<code>SelectionKeyImpl</code>的数组，初始容量大小为8。<code>channelArray</code>其实就是方便<code>Selector</code>管理在册<code>SelectionKeyImpl</code>数量的一个数组而已，通过判断它的数组长度大小，如果和<code>totalChannels</code>(初始值为1)相等，不仅仅是为了<code>channelArray</code>扩容，更重要的是为了辅助<code>pollWrapper</code>，让<code>pollWrapper</code>扩容才是这里的目的所在。<br>而当<code>totalChannels % MAX_SELECTABLE_FDS == 0</code>时，则多开一个线程处理<code>selector</code>。<code>windows</code>上<code>select</code>系统调用有最大文件描述符限制，一次只能轮询<code>1024</code>个文件描述符，如果多于1024个，需要多线程进行轮询。通过<code>ski.setIndex(totalChannels)</code>选择键记录下在数组中的索引位置<code>SelectionKeyImpl</code>选择键的映射关系，以待后续使用。同时调用<code>pollWrapper.addWakeupSocket(wakeupSourceFd, totalChannels)</code>在相对于这个<code>pollArray</code>所在内存地址的偏移量<code>SIZE_POLLFD * totalChannels + FD_OFFSET</code>这个位置上写入<code>wakeupSourceFd</code>所代表的<code>fdVal</code>值。这样在新起的线程就可以通过<code>MAX_SELECTABLE_FDS</code>来确定这个用来监控的<code>wakeupSourceFd</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * sun.nio.ch.WindowsSelectorImpl#processUpdateQueue</span></span><br><span class="line"><span class="comment">    * Process new registrations and changes to the interest ops.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processUpdateQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (updateLock) &#123;</span><br><span class="line">        SelectionKeyImpl ski;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new registrations</span></span><br><span class="line">        <span class="keyword">while</span> ((ski = newKeys.pollFirst()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ski.isValid()) &#123;</span><br><span class="line">                growIfNeeded();</span><br><span class="line">                channelArray[totalChannels] = ski;</span><br><span class="line">                ski.setIndex(totalChannels);</span><br><span class="line">                pollWrapper.putEntry(totalChannels, ski);</span><br><span class="line">                totalChannels++;</span><br><span class="line">                MapEntry previous = fdMap.put(ski);</span><br><span class="line">                <span class="keyword">assert</span> previous == <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// changes to interest ops</span></span><br><span class="line">        <span class="keyword">while</span> ((ski = updateKeys.pollFirst()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> events = ski.translateInterestOps();</span><br><span class="line">            <span class="keyword">int</span> fd = ski.getFDVal();</span><br><span class="line">            <span class="keyword">if</span> (ski.isValid() &amp;&amp; fdMap.containsKey(fd)) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = ski.getIndex();</span><br><span class="line">                <span class="keyword">assert</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; totalChannels;</span><br><span class="line">                pollWrapper.putEventOps(index, events);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.PollArrayWrapper#putEntry</span></span><br><span class="line"><span class="comment">// Prepare another pollfd struct for use.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putEntry</span><span class="params">(<span class="keyword">int</span> index, SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">    putDescriptor(index, ski.getFDVal());</span><br><span class="line">    putEventOps(index, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#growIfNeeded</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">growIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channelArray.length == totalChannels) &#123;</span><br><span class="line">        <span class="keyword">int</span> newSize = totalChannels * <span class="number">2</span>; <span class="comment">// Make a larger array</span></span><br><span class="line">        SelectionKeyImpl temp[] = <span class="keyword">new</span> SelectionKeyImpl[newSize];</span><br><span class="line">        System.arraycopy(channelArray, <span class="number">1</span>, temp, <span class="number">1</span>, totalChannels - <span class="number">1</span>);</span><br><span class="line">        channelArray = temp;</span><br><span class="line">        pollWrapper.grow(newSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totalChannels % MAX_SELECTABLE_FDS == <span class="number">0</span>) &#123; <span class="comment">// more threads needed</span></span><br><span class="line">        pollWrapper.addWakeupSocket(wakeupSourceFd, totalChannels);</span><br><span class="line">        totalChannels++;</span><br><span class="line">        threadsCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Initial capacity of the poll array</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_CAP = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// Maximum number of sockets for select().</span></span><br><span class="line"><span class="comment">// Should be INIT_CAP times a power of 2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SELECTABLE_FDS = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The list of SelectableChannels serviced by this Selector. Every mod</span></span><br><span class="line"><span class="comment">// MAX_SELECTABLE_FDS entry is bogus, to align this array with the poll</span></span><br><span class="line"><span class="comment">// array,  where the corresponding entry is occupied by the wakeupSocket</span></span><br><span class="line"><span class="keyword">private</span> SelectionKeyImpl[] channelArray = <span class="keyword">new</span> SelectionKeyImpl[INIT_CAP];</span><br><span class="line"><span class="comment">// The number of valid entries in  poll array, including entries occupied</span></span><br><span class="line"><span class="comment">// by wakeup socket handle.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> totalChannels = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.PollArrayWrapper#grow</span></span><br><span class="line"><span class="comment">// Grows the pollfd array to new size</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">    PollArrayWrapper temp = <span class="keyword">new</span> PollArrayWrapper(newSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        replaceEntry(<span class="keyword">this</span>, i, temp, i);</span><br><span class="line">    pollArray.free();</span><br><span class="line">    pollArray = temp.pollArray;</span><br><span class="line">    <span class="keyword">this</span>.size = temp.size;</span><br><span class="line">    pollArrayAddress = pollArray.address();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Maps file descriptors to their indices in  pollArray</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FdMap</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Integer</span>, <span class="title">MapEntry</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapEntry <span class="title">get</span><span class="params">(<span class="keyword">int</span> desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(Integer.valueOf(desc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapEntry <span class="title">put</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> put(Integer.valueOf(ski.getFDVal()), <span class="keyword">new</span> MapEntry(ski));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapEntry <span class="title">remove</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">        Integer fd = Integer.valueOf(ski.getFDVal());</span><br><span class="line">        MapEntry x = get(fd);</span><br><span class="line">        <span class="keyword">if</span> ((x != <span class="keyword">null</span>) &amp;&amp; (x.ski.channel() == ski.channel()))</span><br><span class="line">            <span class="keyword">return</span> remove(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class for fdMap entries</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SelectionKeyImpl ski;</span><br><span class="line">    <span class="keyword">long</span> updateCount = <span class="number">0</span>;</span><br><span class="line">    MapEntry(SelectionKeyImpl ski) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ski = ski;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FdMap fdMap = <span class="keyword">new</span> FdMap();</span><br></pre></td></tr></table></figure></blockquote></li></ol><h5 id="processDeregisterQueue解读"><a href="#processDeregisterQueue解读" class="headerlink" title="processDeregisterQueue解读"></a>processDeregisterQueue解读</h5><ol><li>接着通过<code>上面WindowsSelectorImpl#doSelect展示源码中&lt;2&gt;</code> 处的 <code>processDeregisterQueue()</code>。<ul><li>对<code>cancelledKeys</code>进行清除，遍历<code>cancelledKeys</code>，并对每个<code>key</code>进行<code>deregister</code>操作，然后从<code>cancelledKeys</code>集合中删除，从<code>keys</code>集合与<code>selectedKeys</code>中删除，以此来释放引用，方便gc回收，</li><li>其内调用<code>implDereg</code>方法，将会从<code>channelArray</code>中移除对应的<code>Channel</code>代表的<code>SelectionKeyImpl</code>，调整<code>totalChannels</code>和线程数，从<code>map</code>和<code>keys</code>中移除<code>SelectionKeyImpl</code>，移除<code>Channel</code>上的<code>SelectionKeyImpl</code>并关闭<code>Channel</code>。</li><li>同时还发现该<code>processDeregisterQueue()</code>方法在调用<code>poll</code>方法前后都进行调用，这是确保能够正确处理在调用<code>poll</code>方法阻塞的这一段时间之内取消的键能被及时清理。</li><li>最后，还会判断这个<code>cancelledKey</code>所代表的<code>channel</code>是否打开和解除注册，如果关闭并解除注册，则应该将相应的文件描述符对应占用的资源给关闭掉。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * sun.nio.ch.SelectorImpl#processDeregisterQueue</span></span><br><span class="line"><span class="comment">    * Invoked by selection operations to process the cancelled-key set</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processDeregisterQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(publicSelectedKeys);</span><br><span class="line"></span><br><span class="line">    Set&lt;SelectionKey&gt; cks = cancelledKeys();</span><br><span class="line">    <span class="keyword">synchronized</span> (cks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cks.isEmpty()) &#123;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; i = cks.iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                SelectionKeyImpl ski = (SelectionKeyImpl)i.next();</span><br><span class="line">                i.remove();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// remove the key from the selector</span></span><br><span class="line">                implDereg(ski);</span><br><span class="line"></span><br><span class="line">                selectedKeys.remove(ski);</span><br><span class="line">                keys.remove(ski);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// remove from channel's key set</span></span><br><span class="line">                deregister(ski);</span><br><span class="line"></span><br><span class="line">                SelectableChannel ch = ski.channel();</span><br><span class="line">                <span class="keyword">if</span> (!ch.isOpen() &amp;&amp; !ch.isRegistered())</span><br><span class="line">                    ((SelChImpl)ch).kill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#implDereg</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implDereg</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> !ski.isValid();</span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fdMap.remove(ski) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ski.getIndex();</span><br><span class="line">        <span class="keyword">assert</span> (i &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i != totalChannels - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Copy end one over it</span></span><br><span class="line">            SelectionKeyImpl endChannel = channelArray[totalChannels-<span class="number">1</span>];</span><br><span class="line">            channelArray[i] = endChannel;</span><br><span class="line">            endChannel.setIndex(i);</span><br><span class="line">            pollWrapper.replaceEntry(pollWrapper, totalChannels-<span class="number">1</span>, pollWrapper, i);</span><br><span class="line">        &#125;</span><br><span class="line">        ski.setIndex(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        channelArray[totalChannels - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        totalChannels--;</span><br><span class="line">        <span class="keyword">if</span> (totalChannels != <span class="number">1</span> &amp;&amp; totalChannels % MAX_SELECTABLE_FDS == <span class="number">1</span>) &#123;</span><br><span class="line">            totalChannels--;</span><br><span class="line">            threadsCount--; <span class="comment">// The last thread has become redundant.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#kill</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == ST_KILLPENDING) &#123;</span><br><span class="line">            state = ST_KILLED;</span><br><span class="line">            nd.close(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C:/Program Files/Java/jdk-11.0.1/lib/src.zip!/java.base/sun/nio/ch/SocketChannelImpl.java:1126</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    IOUtil.load();</span><br><span class="line">    nd = <span class="keyword">new</span> SocketDispatcher();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SocketDispatcher#close</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    close0(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="adjustThreadsCount解读"><a href="#adjustThreadsCount解读" class="headerlink" title="adjustThreadsCount解读"></a>adjustThreadsCount解读</h5><ol><li>接着我们来看到<code>上面WindowsSelectorImpl#doSelect</code>展示源码中<code>adjustThreadsCount()</code>方法的调用。<ul><li>前面有提到如果<code>totalChannels % MAX_SELECTABLE_FDS == 0</code>，则多开一个线程处理<code>selector</code>。这里就是根据<strong>分配的线程数量值</strong>来增加或减少线程，其实就是针对操作系统的最大<code>select</code>操作的文件描述符限制对线程个数进行调整。</li><li>我们来观察所建线程做了什么事情，即观察<code>SelectThread</code>的<code>run</code>方法实现。通过观察其源码可以看到它首先是<code>while (true)</code>，通过<code>startLock.waitForStart(this)</code>来控制该线程是否运行还是等待，运行状态的话，会进而调用<code>subSelector.poll(index)</code>（这个我们后面内容详细解读），</li><li>当此线程<code>poll</code>结束，而且相对于当前主线程假如有多条<code>SelectThread</code>子线程的话，当前这条<code>SelectThread</code>线程第一个结束<code>poll</code>的话，就调用<code>finishLock.threadFinished()</code>来通知主线程。在刚新建这个线程并调用其<code>run</code>方法的时候，此时<code>lastRun = 0</code>，在第一次启动的时候<code>sun.nio.ch.WindowsSelectorImpl.StartLock#runsCounter</code>同样为0，所以会调用<code>startLock.wait()</code>进而进入等待状态。 </li></ul></li></ol><blockquote><p><strong>注意：</strong></p><ul><li><code>sun.nio.ch.WindowsSelectorImpl.StartLock</code>同样会判断当前其所检测的线程是否废弃，废弃的话就返回<code>true</code>，这样被检测线程也就能跳出其内run方法的<code>while</code>循环从而结束线程运行。</li><li>在调整线程的时候（调用<code>adjustThreadsCount</code>方法）与<code>Selector</code>调用<code>close</code>方法会间接调用到<code>sun.nio.ch.WindowsSelectorImpl#implClose</code>，这两个方法都会涉及到<code>Selector</code>线程的释放，即调用<code>sun.nio.ch.WindowsSelectorImpl.SelectThread#makeZombie</code>。</li><li><code>finishLock.threadFinished()</code>会调用<code>wakeup()</code>方法来通知主线程，这里，我们可以学到一个细节，如果线程正阻塞在<code>select</code>方法上，就可以调用<code>wakeup</code>方法会使阻塞的选择操作立即返回，通过<code>Windows</code>的相关实现，原理其实是向<code>pipe</code>的<code>sink</code>端写入了一个字节，<code>source</code>文件描述符就会处于就绪状态，<code>poll</code>方法会返回，从而导致<code>select</code>方法返回。而在其他solaris或者linux系统上其实采用系统调用<code>pipe</code>来完成管道的创建，相当于直接用了系统的管道。通过<code>wakeup()</code>相关实现还可以看出，调用<code>wakeup</code>会设置<code>interruptTriggered</code>的标志位，所以连续多次调用<code>wakeup</code>的效果等同于一次调用，不会引起无所谓的bug出现。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#adjustThreadsCount</span></span><br><span class="line"><span class="comment">// After some channels registered/deregistered, the number of required</span></span><br><span class="line"><span class="comment">// helper threads may have changed. Adjust this number.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustThreadsCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadsCount &gt; threads.size()) &#123;</span><br><span class="line">        <span class="comment">// More threads needed. Start more threads.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = threads.size(); i &lt; threadsCount; i++) &#123;</span><br><span class="line">            SelectThread newThread = <span class="keyword">new</span> SelectThread(i);</span><br><span class="line">            threads.add(newThread);</span><br><span class="line">            newThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            newThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threadsCount &lt; threads.size()) &#123;</span><br><span class="line">        <span class="comment">// Some threads become redundant. Remove them from the threads List.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = threads.size() - <span class="number">1</span> ; i &gt;= threadsCount; i--)</span><br><span class="line">            threads.remove(i).makeZombie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl.SelectThread</span></span><br><span class="line"><span class="comment">// Represents a helper thread used for select.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index; <span class="comment">// index of this thread</span></span><br><span class="line">    <span class="keyword">final</span> SubSelector subSelector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastRun = <span class="number">0</span>; <span class="comment">// last run number</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> zombie;</span><br><span class="line">    <span class="comment">// Creates a new thread</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SelectThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"SelectorHelper"</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.index = i;</span><br><span class="line">        <span class="keyword">this</span>.subSelector = <span class="keyword">new</span> SubSelector(i);</span><br><span class="line">        <span class="comment">//make sure we wait for next round of poll</span></span><br><span class="line">        <span class="keyword">this</span>.lastRun = startLock.runsCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeZombie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        zombie = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isZombie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zombie;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// poll loop</span></span><br><span class="line">            <span class="comment">// wait for the start of poll. If this thread has become</span></span><br><span class="line">            <span class="comment">// redundant, then exit.</span></span><br><span class="line">            <span class="keyword">if</span> (startLock.waitForStart(<span class="keyword">this</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// call poll()</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                subSelector.poll(index);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Save this exception and let other threads finish.</span></span><br><span class="line">                finishLock.setException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// notify main thread, that this thread has finished, and</span></span><br><span class="line">            <span class="comment">// wakeup others, if this thread is the first to finish.</span></span><br><span class="line">            finishLock.threadFinished();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sun.nio.ch.WindowsSelectorImpl.FinishLock#threadFinished</span></span><br><span class="line"><span class="comment">// Each helper thread invokes this function on finishLock, when</span></span><br><span class="line"><span class="comment">// the thread is done with poll().</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">threadFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadsToFinish == threads.size()) &#123; <span class="comment">// finished poll() first</span></span><br><span class="line">        <span class="comment">// if finished first, wakeup others</span></span><br><span class="line">        wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">    threadsToFinish--;</span><br><span class="line">    <span class="keyword">if</span> (threadsToFinish == <span class="number">0</span>) <span class="comment">// all helper threads finished poll().</span></span><br><span class="line">        notify();             <span class="comment">// notify the main thread</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#wakeup</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Selector <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (interruptLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!interruptTriggered) &#123;</span><br><span class="line">            setWakeupSocket();</span><br><span class="line">            interruptTriggered = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#setWakeupSocket</span></span><br><span class="line"><span class="comment">// Sets Windows wakeup socket to a signaled state.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setWakeupSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setWakeupSocket0(wakeupSinkFd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setWakeupSocket0</span><span class="params">(<span class="keyword">int</span> wakeupSinkFd)</span></span>;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_sun_nio_ch_WindowsSelectorImpl_setWakeupSocket0(JNIEnv *env, jclass <span class="keyword">this</span>,</span><br><span class="line">                                                jint scoutFd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Write one byte into the pipe */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> <span class="keyword">byte</span> = <span class="number">1</span>;</span><br><span class="line">    send(scoutFd, &amp;<span class="keyword">byte</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="subSelector的poll方法解读"><a href="#subSelector的poll方法解读" class="headerlink" title="subSelector的poll方法解读"></a>subSelector的poll方法解读</h5><ol><li><code>subSelector.poll()</code> 是select的核心，由<code>native</code>函数<code>poll0</code>实现，并把<code>pollWrapper.pollArrayAddress</code>作为参数传给<code>poll0</code>，<code>readFds</code>、<code>writeFds</code> 和<code>exceptFds</code>数组用来保存底层<code>select</code>的结果，数组的第一个位置都是存放发生事件的<code>socket</code>的总数，其余位置存放发生事件的<code>socket</code>句柄<code>fd</code>。<br> 我们通过下面的代码可知:<br> 这个<code>poll0()</code>会监听<code>pollWrapper</code>中的<code>FD</code>有没有数据进出，这里会造成<code>IO</code>阻塞，直到有数据读写事件发生。由于<code>pollWrapper</code>中保存的也有<code>ServerSocketChannel</code>的<code>FD</code>，所以只要<code>ClientSocket</code>发一份数据到<code>ServerSocket</code>,那么<code>poll0()</code>就会返回；又由于<code>pollWrapper</code>中保存的也有<code>pipe</code>的<code>write</code>端的<code>FD</code>，所以只要<code>pipe</code>的<code>write</code>端向<code>FD</code>发一份数据，也会造成<code>poll0()</code>返回；如果这两种情况都没有发生，那么<code>poll0()</code>就一直阻塞，也就是<code>selector.select()</code>会一直阻塞；如果有任何一种情况发生，那么<code>selector.select()</code>就会返回，所有在<code>SelectThread</code>的<code>run()</code>里要用<code>while (true) {}</code>，这样就可以保证在<code>selector</code>接收到数据并处理完后继续监听<code>poll()</code>;</li></ol><blockquote><p>可以看出，NIO依然是阻塞式的IO，那么它和BIO的区别究竟在哪呢。<br>其实它的区别在于阻塞的位置不同，<code>BIO</code>是阻塞在<code>read</code>方法(recvfrom)，而<code>NIO</code>阻塞在<code>select</code>方法。那么这样做有什么好处呢。如果单纯的改变阻塞的位置，自然是没有什么变化的，但<code>epoll等</code>的实现的巧妙之处就在于，它利用回调机制，让监听能够只需要知晓哪些<code>socket</code>上的数据已经准备好了，只需要处理这些线程上面的数据就行了。采用<code>BIO</code>，假设有<code>1000</code>个连接，需要开<code>1000</code>个线程，然后有<code>1000</code>个<code>read</code>的位置在阻塞(我们在讲解BIO部分已经通过Demo体现)，采用<code>NIO</code>编程，只需要<strong>1</strong>个线程，它利用<code>select</code>的轮询策略配合<code>epoll</code>的事件机制及红黑树数据结构，降低了其内部轮询的开销，同时极大的减小了线程上下文切换的开销。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl.SubSelector</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSelector</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pollArrayIndex; <span class="comment">// starting index in pollArray to poll</span></span><br><span class="line">        <span class="comment">// These arrays will hold result of native select().</span></span><br><span class="line">        <span class="comment">// The first element of each array is the number of selected sockets.</span></span><br><span class="line">        <span class="comment">// Other elements are file descriptors of selected sockets.</span></span><br><span class="line">        <span class="comment">// 保存发生read的FD</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] readFds = <span class="keyword">new</span> <span class="keyword">int</span> [MAX_SELECTABLE_FDS + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 保存发生write的FD</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] writeFds = <span class="keyword">new</span> <span class="keyword">int</span> [MAX_SELECTABLE_FDS + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//保存发生except的FD</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] exceptFds = <span class="keyword">new</span> <span class="keyword">int</span> [MAX_SELECTABLE_FDS + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SubSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.pollArrayIndex = <span class="number">0</span>; <span class="comment">// main thread</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SubSelector</span><span class="params">(<span class="keyword">int</span> threadIndex)</span> </span>&#123; <span class="comment">// helper threads</span></span><br><span class="line">            <span class="keyword">this</span>.pollArrayIndex = (threadIndex + <span class="number">1</span>) * MAX_SELECTABLE_FDS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123; <span class="comment">// poll for the main thread</span></span><br><span class="line">            <span class="keyword">return</span> poll0(pollWrapper.pollArrayAddress,</span><br><span class="line">                         Math.min(totalChannels, MAX_SELECTABLE_FDS),</span><br><span class="line">                         readFds, writeFds, exceptFds, timeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">// poll for helper threads</span></span><br><span class="line">            <span class="keyword">return</span>  poll0(pollWrapper.pollArrayAddress +</span><br><span class="line">                     (pollArrayIndex * PollArrayWrapper.SIZE_POLLFD),</span><br><span class="line">                     Math.min(MAX_SELECTABLE_FDS,</span><br><span class="line">                             totalChannels - (index + <span class="number">1</span>) * MAX_SELECTABLE_FDS),</span><br><span class="line">                     readFds, writeFds, exceptFds, timeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">poll0</span><span class="params">(<span class="keyword">long</span> pollAddress, <span class="keyword">int</span> numfds,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span>[] readFds, <span class="keyword">int</span>[] writeFds, <span class="keyword">int</span>[] exceptFds, <span class="keyword">long</span> timeout)</span></span>;</span><br><span class="line">             ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="updateSelectedKeys解读"><a href="#updateSelectedKeys解读" class="headerlink" title="updateSelectedKeys解读"></a>updateSelectedKeys解读</h5><ol><li>接下来将通过<code>上面WindowsSelectorImpl#doSelect展示源码中&lt;5&gt;</code> 处的 <code>updateSelectedKeys(action)</code>来处理每个<code>channel</code>的 <strong>准备就绪</strong>的信息。<ul><li>如果该通道的<code>key</code>尚未在<code>selectedKeys</code>中存在，则将其添加到该集合中。</li><li>如果该通道的<code>key</code>已经存在<code>selectedKeys</code>中，即这个<code>channel</code>存在所支持的<code>ReadyOps</code>就绪操作中必须包含一个这种操作(由<code>(ski.nioReadyOps() &amp; ski.nioInterestOps()) != 0</code>来确定)，此时修改其<code>ReadyOps</code>为当前所要进行的操作。而我们之前看到的<code>Consumer&lt;SelectionKey&gt;</code>这个动作也是在此处进行。而由下面源码可知，先前记录在<code>ReadyOps</code>中的任何就绪信息在调用此<code>action</code>之前被丢弃掉，直接进行设定。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#updateSelectedKeys</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">updateSelectedKeys</span><span class="params">(Consumer&lt;SelectionKey&gt; action)</span> </span>&#123;</span><br><span class="line">    updateCount++;</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = <span class="number">0</span>;</span><br><span class="line">    numKeysUpdated += subSelector.processSelectedKeys(updateCount, action);</span><br><span class="line">    <span class="keyword">for</span> (SelectThread t: threads) &#123;</span><br><span class="line">        numKeysUpdated += t.subSelector.processSelectedKeys(updateCount, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#processReadyEvents</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">processReadyEvents</span><span class="params">(<span class="keyword">int</span> rOps,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        SelectionKeyImpl ski,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Consumer&lt;SelectionKey&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ski.translateAndSetReadyOps(rOps);</span><br><span class="line">        <span class="keyword">if</span> ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != <span class="number">0</span>) &#123;</span><br><span class="line">            action.accept(ski);</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(publicSelectedKeys);</span><br><span class="line">        <span class="keyword">if</span> (selectedKeys.contains(ski)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ski.translateAndUpdateReadyOps(rOps)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ski.translateAndSetReadyOps(rOps);</span><br><span class="line">            <span class="keyword">if</span> ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != <span class="number">0</span>) &#123;</span><br><span class="line">                selectedKeys.add(ski);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl.SubSelector#processSelectedKeys</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processSelectedKeys</span><span class="params">(<span class="keyword">long</span> updateCount, Consumer&lt;SelectionKey&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = <span class="number">0</span>;</span><br><span class="line">    numKeysUpdated += processFDSet(updateCount, action, readFds,</span><br><span class="line">                                    Net.POLLIN,</span><br><span class="line">                                    <span class="keyword">false</span>);</span><br><span class="line">    numKeysUpdated += processFDSet(updateCount, action, writeFds,</span><br><span class="line">                                    Net.POLLCONN |</span><br><span class="line">                                    Net.POLLOUT,</span><br><span class="line">                                    <span class="keyword">false</span>);</span><br><span class="line">    numKeysUpdated += processFDSet(updateCount, action, exceptFds,</span><br><span class="line">                                    Net.POLLIN |</span><br><span class="line">                                    Net.POLLCONN |</span><br><span class="line">                                    Net.POLLOUT,</span><br><span class="line">                                    <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * sun.nio.ch.WindowsSelectorImpl.SubSelector#processFDSet</span></span><br><span class="line"><span class="comment">    * updateCount is used to tell if a key has been counted as updated</span></span><br><span class="line"><span class="comment">    * in this select operation.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * me.updateCount &lt;= updateCount</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processFDSet</span><span class="params">(<span class="keyword">long</span> updateCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Consumer&lt;SelectionKey&gt; action,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span>[] fds, <span class="keyword">int</span> rOps,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> isExceptFds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= fds[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> desc = fds[i];</span><br><span class="line">        <span class="keyword">if</span> (desc == wakeupSourceFd) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (interruptLock) &#123;</span><br><span class="line">                interruptTriggered = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MapEntry me = fdMap.get(desc);</span><br><span class="line">        <span class="comment">// If me is null, the key was deregistered in the previous</span></span><br><span class="line">        <span class="comment">// processDeregisterQueue.</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        SelectionKeyImpl sk = me.ski;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The descriptor may be in the exceptfds set because there is</span></span><br><span class="line">        <span class="comment">// OOB data queued to the socket. If there is OOB data then it</span></span><br><span class="line">        <span class="comment">// is discarded and the key is not added to the selected set.</span></span><br><span class="line">        <span class="keyword">if</span> (isExceptFds &amp;&amp;</span><br><span class="line">            (sk.channel() <span class="keyword">instanceof</span> SocketChannelImpl) &amp;&amp;</span><br><span class="line">            discardUrgentData(desc))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//我们应该关注的</span></span><br><span class="line">        <span class="keyword">int</span> updated = processReadyEvents(rOps, sk, action);</span><br><span class="line">        <span class="keyword">if</span> (updated &gt; <span class="number">0</span> &amp;&amp; me.updateCount != updateCount) &#123;</span><br><span class="line">            me.updateCount = updateCount;</span><br><span class="line">            numKeysUpdated++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>至此，关于Selector的内容就暂时告一段落，在下一篇中，我会针对Java NIO Buffer进行相关解读。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。&lt;/p&gt;
&lt;p&gt;关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:&lt;/p&gt;
&lt;p&gt;Rxjava源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av34537840&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av34537840&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Reactor源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av35326911&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av35326911&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列源码解读基于JDK11 api细节可能与其他版本有所差别，请自行解决jdk版本问题。&lt;/p&gt;
&lt;p&gt;本系列前几篇:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c2cc075f265da611037298e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BIO到NIO源码的一些事儿之BIO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c2e23156fb9a049ff4e4009&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BIO到NIO源码的一些事儿之NIO 上&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c34d1dd6fb9a049c84fa2ce&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BIO到NIO源码的一些事儿之NIO 中&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="响应式" scheme="https://muyinchen.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
      <category term="Reactor Rxjava  NIO" scheme="https://muyinchen.github.io/tags/Reactor-Rxjava-NIO/"/>
    
  </entry>
  
  <entry>
    <title>BIO到NIO源码的一些事儿之NIO 中</title>
    <link href="https://muyinchen.github.io/2019/01/09/BIO%E5%88%B0NIO%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF%E4%B9%8BNIO%20%E4%B8%AD/"/>
    <id>https://muyinchen.github.io/2019/01/09/BIO到NIO源码的一些事儿之NIO 中/</id>
    <published>2019-01-08T17:40:25.000Z</published>
    <updated>2019-01-09T04:00:49.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。</p><p>关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:</p><p>Rxjava源码解读与分享：<a href="https://www.bilibili.com/video/av34537840" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840</a></p><p>Reactor源码解读与分享：<a href="https://www.bilibili.com/video/av35326911" target="_blank" rel="noopener">https://www.bilibili.com/video/av35326911</a></p><p>本系列源码解读基于JDK11 api细节可能与其他版本有所差别，请自行解决jdk版本问题。</p><a id="more"></a><h2 id="Channel解读"><a href="#Channel解读" class="headerlink" title="Channel解读"></a>Channel解读</h2><p>接上一篇<a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a></p><h3 id="赋予Channel支持网络socket的能力"><a href="#赋予Channel支持网络socket的能力" class="headerlink" title="赋予Channel支持网络socket的能力"></a>赋予Channel支持网络socket的能力</h3><p>我们最初的目的就是为了增强Socket，基于这个基本需求，没有条件创造条件，于是为了让Channel拥有网络socket的能力，这里定义了一个<code>java.nio.channels.NetworkChannel</code>接口。花不多说，我们来看这个接口的定义:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetworkChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">NetworkChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SocketAddress <span class="title">getLocalAddress</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">NetworkChannel <span class="title">setOption</span><span class="params">(SocketOption&lt;T&gt; name, T value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getOption</span><span class="params">(SocketOption&lt;T&gt; name)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>bind(SocketAddress)</code> 方法将<code>socket</code>绑定到本地 <code>SocketAddress</code>上，通过getLocalAddress()方法返回<code>socket</code>绑定的地址，<br>通过 <code>setOption(SocketOption,Object)</code>和<code>getOption(SocketOption)</code>方法设置和查询<code>socket</code>支持的配置选项。 </p><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>接下来我们来看 <code>java.nio.channels.ServerSocketChannel</code>抽象类及其实现类<code>sun.nio.ch.ServerSocketChannelImpl</code>对之实现的细节。<br>首先我们来看其对于bind的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#bind</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="comment">//通过localAddress判断是否已经调用过bind</span></span><br><span class="line">        <span class="keyword">if</span> (localAddress != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlreadyBoundException();</span><br><span class="line">        <span class="comment">//InetSocketAddress(0)表示绑定到本机的所有地址，由操作系统选择合适的端口</span></span><br><span class="line">        InetSocketAddress isa = (local == <span class="keyword">null</span>)</span><br><span class="line">                                ? <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>)</span><br><span class="line">                                : Net.checkAddress(local);</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>)</span><br><span class="line">            sm.checkListen(isa.getPort());</span><br><span class="line">        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">        Net.bind(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">        <span class="comment">//开启监听，s如果参数backlog小于1，默认接受50个连接 </span></span><br><span class="line">        Net.listen(fd, backlog &lt; <span class="number">1</span> ? <span class="number">50</span> : backlog);</span><br><span class="line">        localAddress = Net.localAddress(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们来看看Net中的bind和listen方法是如何实现的。</p><h5 id="Net-bind"><a href="#Net-bind" class="headerlink" title="Net.bind"></a>Net.bind</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.Net#bind(java.io.FileDescriptor, java.net.InetAddress, int)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(FileDescriptor fd, InetAddress addr, <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bind(UNSPEC, fd, addr, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ProtocolFamily family, FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                    InetAddress addr, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果传入的协议域不是IPV4而且支持IPV6,则使用ipv6</span></span><br><span class="line">    <span class="keyword">boolean</span> preferIPv6 = isIPv6Available() &amp;&amp;</span><br><span class="line">        (family != StandardProtocolFamily.INET);</span><br><span class="line">    bind0(fd, preferIPv6, exclusiveBind, addr, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">bind0</span><span class="params">(FileDescriptor fd, <span class="keyword">boolean</span> preferIPv6,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">boolean</span> useExclBind, InetAddress addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>bind0为native方法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_sun_nio_ch_Net_bind0(JNIEnv *env, jclass clazz, jobject fdo, jboolean preferIPv6,</span><br><span class="line">                          jboolean useExclBind, jobject iao, <span class="keyword">int</span> port)</span><br><span class="line">&#123;</span><br><span class="line">    SOCKETADDRESS sa;</span><br><span class="line">    <span class="keyword">int</span> sa_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将java的InetAddress转换为c的struct sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len,</span><br><span class="line">                                  preferIPv6) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//转换失败，方法返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用bind方法:int bind(int sockfd, struct sockaddr* addr, socklen_t addrlen) </span></span><br><span class="line">    rv = NET_Bind(fdval(env, fdo), &amp;sa, sa_len);</span><br><span class="line">    <span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">        handleSocketError(env, errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>socket是用户程序与内核交互信息的枢纽，它自身没有网络协议地址和端口号等信息,在进行网络通信的时候，必须把一个socket与一个地址相关联。<br>很多时候内核会我们自动绑定一个地址，然而有时用户可能需要自己来完成这个绑定的过程，以满足实际应用的需要；<br>最典型的情况是一个服务器进程需要绑定一个众所周知的地址或端口以等待客户来连接。<br>对于客户端，很多时候并不需要调用bind方法，而是由内核自动绑定；</p><p><strong>这里要注意</strong>，绑定归绑定，在有连接过来的时候会创建一个新的Socket，然后服务端操作这个新的Socket即可。这里就可以关注<strong>accept</strong>方法了。由<code>sun.nio.ch.ServerSocketChannelImpl#bind</code>最后，我们知道其通过<code>Net.listen(fd, backlog &lt; 1 ? 50 : backlog)</code>开启监听，如果参数backlog小于1，默认接受50个连接。由此，我们来关注下<code>Net.listen</code>方法细节。</p><h5 id="Net-listen"><a href="#Net-listen" class="headerlink" title="Net.listen"></a>Net.listen</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.Net#listen</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(FileDescriptor fd, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>可以知道，<code>Net.listen</code>是<code>native</code>方法，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_sun_nio_ch_Net_listen(JNIEnv *env, jclass cl, jobject fdo, jint backlog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (listen(fdval(env, fdo), backlog) &lt; <span class="number">0</span>)</span><br><span class="line">        handleSocketError(env, errno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到底层是调用<code>listen</code>实现的，<code>listen</code>函数在一般在调用<code>bind</code>之后到调用<code>accept</code>之前调用，它的函数原型是：<br><code>int listen(int sockfd, int backlog)</code>返回值：0表示成功， -1表示失败</p><p>我们再来关注下bind操作中的其他细节，最开始时的<code>ensureOpen()</code>方法判断:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#ensureOpen</span></span><br><span class="line"><span class="comment">// @throws ClosedChannelException if channel is closed</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> ClosedChannelException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isOpen())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.channels.spi.AbstractInterruptibleChannel#isOpen</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !closed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果<code>socket</code>关闭，则抛出<code>ClosedChannelException</code> 。</p><p>我们再来看下<code>Net#checkAddress</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.Net#checkAddress(java.net.SocketAddress)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InetSocketAddress <span class="title">checkAddress</span><span class="params">(SocketAddress sa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sa == <span class="keyword">null</span>)<span class="comment">//地址为空  </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//非InetSocketAddress类型地址 </span></span><br><span class="line">    <span class="keyword">if</span> (!(sa <span class="keyword">instanceof</span> InetSocketAddress))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedAddressTypeException(); <span class="comment">// ## needs arg</span></span><br><span class="line">    InetSocketAddress isa = (InetSocketAddress)sa;</span><br><span class="line">    <span class="comment">//地址不可识别  </span></span><br><span class="line">    <span class="keyword">if</span> (isa.isUnresolved())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnresolvedAddressException(); <span class="comment">// ## needs arg</span></span><br><span class="line">    InetAddress addr = isa.getAddress();</span><br><span class="line">        <span class="comment">//非ip4和ip6地址  </span></span><br><span class="line">    <span class="keyword">if</span> (!(addr <span class="keyword">instanceof</span> Inet4Address || addr <span class="keyword">instanceof</span> Inet6Address))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid address type"</span>);</span><br><span class="line">    <span class="keyword">return</span> isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面可以看出，bind首先检查<code>ServerSocket</code>是否关闭，是否绑定地址， 如果既没有绑定也没关闭，则检查绑定的<code>socketaddress</code>是否正确或合法； 然后通过Net工具类的<code>bind</code>和<code>listen</code>，完成实际的<code>ServerSocket</code>地址绑定和开启监听，如果绑定是开启的参数小于<code>1</code>，则默认接受<code>50</code>个连接。 </p><p>对照我们之前在第一篇中接触的BIO，我们来看些<code>accept()</code>方法的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#accept()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    acceptLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        FileDescriptor newfd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        InetSocketAddress[] isaa = <span class="keyword">new</span> InetSocketAddress[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> blocking = isBlocking();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin(blocking);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                n = accept(<span class="keyword">this</span>.fd, newfd, isaa);</span><br><span class="line">            &#125; <span class="keyword">while</span> (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            end(blocking, n &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">assert</span> IOStatus.check(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//针对接受连接的处理通道socketchannelimpl，默认为阻塞模式 </span></span><br><span class="line">        <span class="comment">// newly accepted socket is initially in blocking mode</span></span><br><span class="line">        IOUtil.configureBlocking(newfd, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        InetSocketAddress isa = isaa[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//构建SocketChannelImpl，这个具体在SocketChannelImpl再说  </span></span><br><span class="line">        SocketChannel sc = <span class="keyword">new</span> SocketChannelImpl(provider(), newfd, isa);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check permitted to accept connections from the remote address</span></span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//检查地址和port权限</span></span><br><span class="line">                sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException x) &#123;</span><br><span class="line">                sc.close();</span><br><span class="line">                <span class="keyword">throw</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//返回socketchannelimpl  </span></span><br><span class="line">        <span class="keyword">return</span> sc;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        acceptLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于<code>accept(this.fd, newfd, isaa)</code>，调用accept接收socket中已建立的连接，我们之前有在BIO中了解过，函数最终会调用:int accept(int sockfd,struct sockaddr <em>addr, socklen_t </em>addrlen);</p><ul><li>如果fd监听socket的队列中没有等待的连接，socket也没有被标记为Non-blocking，accept()会阻塞直到连接出现；</li><li>如果socket被标记为Non-blocking，队列中也没有等待的连接，accept()返回错误EAGAIN或EWOULDBLOCK</li></ul><p>这里<code>begin(blocking);</code> 与 <code>end(blocking, n &gt; 0);</code>的合作模式我们在<a href="https://github.com/muyinchen/woker/blob/master/NIO/%E8%A1%A5%E5%85%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%9AInterruptibleChannel%20%E4%B8%8E%E5%8F%AF%E4%B8%AD%E6%96%AD%20IO.md" target="_blank" rel="noopener">InterruptibleChannel 与可中断 IO</a>这一篇文章中已经涉及过，这里再次提一下，让大家看到其应用，此处专注的是等待连接这个过程，期间可以出现异常打断，这个过程正常结束的话，就会正常往下执行逻辑，不要搞的好像这个Channel要结束了一样，<code>end(blocking, n &gt; 0)</code>的第二个参数completed也只是在判断这个等待过程是否结束而已，不要功能范围扩大化。</p><h4 id="supportedOptions"><a href="#supportedOptions" class="headerlink" title="supportedOptions"></a>supportedOptions</h4><p>我们再来看下<code>NetworkChannel</code>的其他方法实现，首先来看<code>supportedOptions</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#supportedOptions</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultOptionsHolder.defaultOptions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl.DefaultOptionsHolder</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultOptionsHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() &#123;</span><br><span class="line">        HashSet&lt;SocketOption&lt;?&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(StandardSocketOptions.SO_RCVBUF);</span><br><span class="line">        set.add(StandardSocketOptions.SO_REUSEADDR);</span><br><span class="line">        <span class="keyword">if</span> (Net.isReusePortAvailable()) &#123;</span><br><span class="line">            set.add(StandardSocketOptions.SO_REUSEPORT);</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(StandardSocketOptions.IP_TOS);</span><br><span class="line">        set.addAll(ExtendedSocketOptions.options(SOCK_STREAM));</span><br><span class="line">        <span class="comment">//返回不可修改的HashSet </span></span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对上述配置中的一些配置我们大致来瞅眼:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.StandardSocketOptions</span></span><br><span class="line"><span class="comment">//socket接受缓存大小  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SocketOption&lt;Integer&gt; SO_RCVBUF =</span><br><span class="line">        <span class="keyword">new</span> StdSocketOption&lt;Integer&gt;(<span class="string">"SO_RCVBUF"</span>, Integer.class);</span><br><span class="line"><span class="comment">//是否可重用地址  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SocketOption&lt;Boolean&gt; SO_REUSEADDR =</span><br><span class="line">        <span class="keyword">new</span> StdSocketOption&lt;Boolean&gt;(<span class="string">"SO_REUSEADDR"</span>, Boolean.class);</span><br><span class="line"><span class="comment">//是否可重用port</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SocketOption&lt;Boolean&gt; SO_REUSEPORT =</span><br><span class="line">        <span class="keyword">new</span> StdSocketOption&lt;Boolean&gt;(<span class="string">"SO_REUSEPORT"</span>, Boolean.class);</span><br><span class="line"><span class="comment">//Internet协议（IP）标头（header）中的服务类型（ToS）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SocketOption&lt;Integer&gt; IP_TOS =</span><br><span class="line">        <span class="keyword">new</span> StdSocketOption&lt;Integer&gt;(<span class="string">"IP_TOS"</span>, Integer.class);</span><br></pre></td></tr></table></figure></p><h4 id="setOption实现"><a href="#setOption实现" class="headerlink" title="setOption实现"></a>setOption实现</h4><p>知道了上面的支持配置，我们来看下<code>setOption</code>实现细节:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#setOption</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ServerSocketChannel <span class="title">setOption</span><span class="params">(SocketOption&lt;T&gt; name, T value)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(name);</span><br><span class="line">    <span class="keyword">if</span> (!supportedOptions().contains(name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"'"</span> + name + <span class="string">"' not supported"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name == StandardSocketOptions.IP_TOS) &#123;</span><br><span class="line">            ProtocolFamily family = Net.isIPv6Available() ?</span><br><span class="line">                StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;</span><br><span class="line">            Net.setSocketOption(fd, family, name, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) &#123;</span><br><span class="line">            <span class="comment">// SO_REUSEADDR emulated when using exclusive bind</span></span><br><span class="line">            isReuseAddress = (Boolean)value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no options that require special handling</span></span><br><span class="line">            Net.setSocketOption(fd, Net.UNSPEC, name, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，大家就能看到<code>supportedOptions().contains(name)</code>的作用了，首先会进行支持配置的判断，然后进行正常的设置逻辑。里面对于Socket配置设定主要执行了<code>Net.setSocketOption</code>，这里，就只对其代码做中文注释就好，整个逻辑过程没有太复杂的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSocketOption</span><span class="params">(FileDescriptor fd, ProtocolFamily family,</span></span></span><br><span class="line"><span class="function"><span class="params">                            SocketOption&lt;?&gt; name, Object value)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid option value"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// only simple values supported by this method</span></span><br><span class="line">    Class&lt;?&gt; type = name.type();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (extendedOptions.isOptionSupported(name)) &#123;</span><br><span class="line">        extendedOptions.setOption(fd, name, value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非整形和布尔型，则抛出断言错误  </span></span><br><span class="line">    <span class="keyword">if</span> (type != Integer.class &amp;&amp; type != Boolean.class)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// special handling</span></span><br><span class="line">    <span class="keyword">if</span> (name == StandardSocketOptions.SO_RCVBUF ||</span><br><span class="line">        name == StandardSocketOptions.SO_SNDBUF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断接受和发送缓冲区大小  </span></span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)value).intValue();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid send/receive buffer size"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//缓冲区有数据，延迟关闭socket的的时间 </span></span><br><span class="line">    <span class="keyword">if</span> (name == StandardSocketOptions.SO_LINGER) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)value).intValue();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            value = Integer.valueOf(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">65535</span>)</span><br><span class="line">            value = Integer.valueOf(<span class="number">65535</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//UDP单播  </span></span><br><span class="line">    <span class="keyword">if</span> (name == StandardSocketOptions.IP_TOS) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)value).intValue();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid IP_TOS value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//UDP多播  </span></span><br><span class="line">    <span class="keyword">if</span> (name == StandardSocketOptions.IP_MULTICAST_TTL) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)value).intValue();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid TTL/hop value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map option name to platform level/name</span></span><br><span class="line">    OptionKey key = SocketOptionRegistry.findOption(name, family);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Option not found"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">    <span class="comment">//转换配置参数值  </span></span><br><span class="line">    <span class="keyword">if</span> (type == Integer.class) &#123;</span><br><span class="line">        arg = ((Integer)value).intValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = ((Boolean)value).booleanValue();</span><br><span class="line">        arg = (b) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> mayNeedConversion = (family == UNSPEC);</span><br><span class="line">    <span class="keyword">boolean</span> isIPv6 = (family == StandardProtocolFamily.INET6);</span><br><span class="line">    <span class="comment">//设置文件描述符的值及其他</span></span><br><span class="line">    setIntOption0(fd, mayNeedConversion, key.level(), key.name(), arg, isIPv6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getOption"><a href="#getOption" class="headerlink" title="getOption"></a>getOption</h4><p>接下来，我们来看<code>getOption</code>实现，源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#getOption</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getOption</span><span class="params">(SocketOption&lt;T&gt; name)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(name);</span><br><span class="line">    <span class="comment">//非通道支持选项，则抛出UnsupportedOperationException  </span></span><br><span class="line">    <span class="keyword">if</span> (!supportedOptions().contains(name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"'"</span> + name + <span class="string">"' not supported"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) &#123;</span><br><span class="line">            <span class="comment">// SO_REUSEADDR emulated when using exclusive bind</span></span><br><span class="line">            <span class="keyword">return</span> (T)Boolean.valueOf(isReuseAddress);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//假如获取的不是上面的配置，则委托给Net来处理 </span></span><br><span class="line">        <span class="comment">// no options that require special handling</span></span><br><span class="line">        <span class="keyword">return</span> (T) Net.getSocketOption(fd, Net.UNSPEC, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.Net#getSocketOption</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">getSocketOption</span><span class="params">(FileDescriptor fd, ProtocolFamily family,</span></span></span><br><span class="line"><span class="function"><span class="params">                                SocketOption&lt;?&gt; name)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class&lt;?&gt; type = name.type();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (extendedOptions.isOptionSupported(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> extendedOptions.getOption(fd, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只支持整形和布尔型，否则抛出断言错误  </span></span><br><span class="line">    <span class="comment">// only simple values supported by this method</span></span><br><span class="line">    <span class="keyword">if</span> (type != Integer.class &amp;&amp; type != Boolean.class)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map option name to platform level/name</span></span><br><span class="line">    OptionKey key = SocketOptionRegistry.findOption(name, family);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Option not found"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> mayNeedConversion = (family == UNSPEC);</span><br><span class="line">    <span class="comment">//获取文件描述的选项配置 </span></span><br><span class="line">    <span class="keyword">int</span> value = getIntOption0(fd, mayNeedConversion, key.level(), key.name());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == Integer.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//我们要看到前面支持配置处的源码其支持的类型要么是Boolean，要么是Integer</span></span><br><span class="line">        <span class="comment">//所以，返回值为Boolean.FALSE 或 Boolean.TRUE也就不足为奇了</span></span><br><span class="line">        <span class="keyword">return</span> (value == <span class="number">0</span>) ? Boolean.FALSE : Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ServerSocketChannel与ServerSocket在bind处的异同"><a href="#ServerSocketChannel与ServerSocket在bind处的异同" class="headerlink" title="ServerSocketChannel与ServerSocket在bind处的异同"></a>ServerSocketChannel与ServerSocket在bind处的异同</h4><p>在<strong>Net.bind</strong>一节中，我们最后说了一个注意点，每个连接过来的时候都会创建一个Socket来供此连接进行操作，这个在accept方法中可以看到，其在得到连接之后，就 <code>new SocketChannelImpl(provider(), newfd, isa)</code>这个对象。那这里，就引出一个话题，我们在使用bind方法的时候，是不是也应该绑定到一个Socket之上呢，那之前bio是怎么做呢，我们先来回顾一下。<br>我们之前在调用<code>java.net.ServerSocket#ServerSocket(int, int, java.net.InetAddress)</code>方法的时候，里面有一个<code>setImpl()</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        setImpl();</span><br><span class="line">        <span class="keyword">if</span> (port &lt; <span class="number">0</span> || port &gt; <span class="number">0xFFFF</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                       <span class="string">"Port value out of range: "</span> + port);</span><br><span class="line">        <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">          backlog = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bind(<span class="keyword">new</span> InetSocketAddress(bindAddr, port), backlog);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//java.net.ServerSocket#setImpl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            impl = factory.createSocketImpl();</span><br><span class="line">            checkOldImpl();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No need to do a checkOldImpl() here, we know it's an up to date</span></span><br><span class="line">            <span class="comment">// SocketImpl!</span></span><br><span class="line">            impl = <span class="keyword">new</span> SocksSocketImpl();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>)</span><br><span class="line">            impl.setServerSocket(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>但是，我们此处的重点在<code>bind(new InetSocketAddress(bindAddr, port), backlog);</code>，这里的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress endpoint, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oldImpl &amp;&amp; isBound())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Already bound"</span>);</span><br><span class="line">        <span class="keyword">if</span> (endpoint == <span class="keyword">null</span>)</span><br><span class="line">            endpoint = <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(endpoint <span class="keyword">instanceof</span> InetSocketAddress))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported address type"</span>);</span><br><span class="line">        InetSocketAddress epoint = (InetSocketAddress) endpoint;</span><br><span class="line">        <span class="keyword">if</span> (epoint.isUnresolved())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Unresolved address"</span>);</span><br><span class="line">        <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">          backlog = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SecurityManager security = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>)</span><br><span class="line">                security.checkListen(epoint.getPort());</span><br><span class="line">                <span class="comment">//重点！！</span></span><br><span class="line">            getImpl().bind(epoint.getAddress(), epoint.getPort());</span><br><span class="line">            getImpl().listen(backlog);</span><br><span class="line">            bound = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>我们有看到 <code>getImpl()</code>我标示了重点，这里面做了什么，我们走进去:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket#getImpl</span></span><br><span class="line"><span class="function">SocketImpl <span class="title">getImpl</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!created)</span><br><span class="line">        createImpl();</span><br><span class="line">    <span class="keyword">return</span> impl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在整个过程中<code>created</code>还是对象刚创建时的初始值，为false，那么，铁定会进入<code>createImpl()</code>方法中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket#createImpl</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createImpl</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (impl == <span class="keyword">null</span>)</span><br><span class="line">        setImpl();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        impl.create(<span class="keyword">true</span>);</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而此处，因为前面<code>impl</code>已经赋值，所以，会走<code>impl.create(true)</code>，进而将<code>created</code>设定为<code>true</code>。而此刻，终于到我想讲的重点了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.AbstractPlainSocketImpl#create</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stream = stream;</span><br><span class="line">    <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">        ResourceManager.beforeUdpCreate();</span><br><span class="line">        <span class="comment">// only create the fd after we know we will be able to create the socket</span></span><br><span class="line">        fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketCreate(<span class="keyword">false</span>);</span><br><span class="line">            SocketCleanable.register(fd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            ResourceManager.afterUdpClose();</span><br><span class="line">            fd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">throw</span> ioe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        socketCreate(<span class="keyword">true</span>);</span><br><span class="line">        SocketCleanable.register(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">        socket.setCreated();</span><br><span class="line">    <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)</span><br><span class="line">        serverSocket.setCreated();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>socketCreate(true);</code>，它的实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketCreate</span><span class="params">(<span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket closed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newfd = socket0(stream);</span><br><span class="line"></span><br><span class="line">    fdAccess.set(fd, newfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过本地方法<code>socket0(stream)</code>得到了一个文件描述符，由此，Socket创建了出来，然后进行相应的绑定。<br>我们再把眼光放回到<code>sun.nio.ch.ServerSocketChannelImpl#accept()</code>中，这里new的<code>SocketChannelImpl</code>对象是得到连接之后做的事情，那对于服务器来讲，绑定时候用的Socket呢，这里，我们在使用<code>ServerSocketChannel</code>的时候，往往要使用JDK给我们提供的对我统一的方法<code>open</code>，也是为了降低我们使用的复杂度，这里是<code>java.nio.channels.ServerSocketChannel#open</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.ServerSocketChannel#open</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openServerSocketChannel();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorProviderImpl#openServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">openServerSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServerSocketChannelImpl(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#ServerSocketChannelImpl(SelectorProvider)</span></span><br><span class="line">ServerSocketChannelImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    <span class="keyword">this</span>.fd =  Net.serverSocket(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.fdVal = IOUtil.fdVal(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.Net#serverSocket</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FileDescriptor <span class="title">serverSocket</span><span class="params">(<span class="keyword">boolean</span> stream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IOUtil.newFD(socket0(isIPv6Available(), stream, <span class="keyword">true</span>, fastLoopback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，只要new了一个ServerSocketChannelImpl对象，就相当于拿到了一个<code>socket</code>然后bind也就有着落了。但是，我们要注意下细节<code>ServerSocketChannel#open</code>得到的是<code>ServerSocketChannel</code>类型。我们accept到一个客户端来的连接后，应该在客户端与服务器之间创建一个Socket通道来供两者通信操作的，所以，<code>sun.nio.ch.ServerSocketChannelImpl#accept()</code>中所做的是<code>SocketChannel sc = new SocketChannelImpl(provider(), newfd, isa);</code>，得到的是<code>SocketChannel</code>类型的对象，这样，就可以将Socket的读写数据的方法定义在这个类里面。</p><h4 id="由ServerSocketChannel的socket方法延伸的"><a href="#由ServerSocketChannel的socket方法延伸的" class="headerlink" title="由ServerSocketChannel的socket方法延伸的"></a>由ServerSocketChannel的socket方法延伸的</h4><p>关于<code>ServerSocketChannel</code>，我们还有方法需要接触一下，如socket():<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#socket</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerSocket <span class="title">socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (socket == <span class="keyword">null</span>)</span><br><span class="line">            socket = ServerSocketAdaptor.create(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> socket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到了<code>ServerSocketAdaptor</code>，我们通过此类的注释可知，这是一个和<code>ServerSocket</code>调用一样，但是底层是用<code>ServerSocketChannelImpl</code>来实现的一个类，其适配是的目的是适配我们使用<code>ServerSocket</code>的方式，所以该<code>ServerSocketAdaptor</code>继承<code>ServerSocket</code>并按顺序重写了它的方法，所以，我们在写这块儿代码的时候也就有了新的选择。</p><p><a href="https://github.com/muyinchen/woker/blob/master/NIO/%E8%A1%A5%E5%85%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%9AInterruptibleChannel%20%E4%B8%8E%E5%8F%AF%E4%B8%AD%E6%96%AD%20IO.md" target="_blank" rel="noopener">InterruptibleChannel 与可中断 IO</a>这一篇文章中已经涉及过<code>java.nio.channels.spi.AbstractInterruptibleChannel#close</code>的实现，这里，我们再来回顾下其中的某些细节，顺带引出我们新的话题:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractInterruptibleChannel#close</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closed)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">        implCloseChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#implCloseChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">implCloseChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        implCloseSelectableChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clone keys to avoid calling cancel when holding keyLock</span></span><br><span class="line">        SelectionKey[] copyOfKeys = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys != <span class="keyword">null</span>) &#123;</span><br><span class="line">                copyOfKeys = keys.clone();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copyOfKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SelectionKey k : copyOfKeys) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    k.cancel();   <span class="comment">// invalidate and adds key to cancelledKey set</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#implCloseSelectableChannel</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implCloseSelectableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> !isOpen();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> blocking;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set state to ST_CLOSING</span></span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="keyword">assert</span> state &lt; ST_CLOSING;</span><br><span class="line">        state = ST_CLOSING;</span><br><span class="line">        blocking = isBlocking();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for any outstanding accept to complete</span></span><br><span class="line">    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">            <span class="keyword">assert</span> state == ST_CLOSING;</span><br><span class="line">            <span class="keyword">long</span> th = thread;</span><br><span class="line">            <span class="keyword">if</span> (th != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//本地线程不为null，则本地Socket预先关闭</span></span><br><span class="line">                <span class="comment">//并通知线程通知关闭</span></span><br><span class="line">                nd.preClose(fd);</span><br><span class="line">                NativeThread.signal(th);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// wait for accept operation to end</span></span><br><span class="line">                <span class="keyword">while</span> (thread != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        stateLock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        interrupted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// non-blocking mode: wait for accept to complete</span></span><br><span class="line">        acceptLock.lock();</span><br><span class="line">        acceptLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set state to ST_KILLPENDING</span></span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="keyword">assert</span> state == ST_CLOSING;</span><br><span class="line">        state = ST_KILLPENDING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close socket if not registered with Selector</span></span><br><span class="line">    <span class="comment">//如果未在Selector上注册，直接kill掉</span></span><br><span class="line">    <span class="comment">//即关闭文件描述  </span></span><br><span class="line">    <span class="keyword">if</span> (!isRegistered())</span><br><span class="line">        kill();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore interrupt status</span></span><br><span class="line">    <span class="comment">//印证了我们上一篇中在异步打断中若是通过线程的中断方法中断线程的话</span></span><br><span class="line">    <span class="comment">//最后要设定该线程状态是interrupt</span></span><br><span class="line">    <span class="keyword">if</span> (interrupted)</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == ST_KILLPENDING) &#123;</span><br><span class="line">            state = ST_KILLED;</span><br><span class="line">            nd.close(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="channel的close-应用"><a href="#channel的close-应用" class="headerlink" title="channel的close()应用"></a>channel的close()应用</h5><p>也是因为<code>close()</code>并没有在<a href="https://github.com/muyinchen/woker/blob/master/NIO/%E8%A1%A5%E5%85%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%9AInterruptibleChannel%20%E4%B8%8E%E5%8F%AF%E4%B8%AD%E6%96%AD%20IO.md" target="_blank" rel="noopener">InterruptibleChannel 与可中断 IO</a>这一篇文章中进行具体的讲解应用，这里其应用的更多是在<code>SocketChannel</code>这里，其更多的涉及到客户端与服务端建立连接交换数据，所以断开连接后，将不用的Channel关闭是很正常的。<br>这里，在<code>sun.nio.ch.ServerSocketChannelImpl#accept()</code>中的源码中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// newly accepted socket is initially in blocking mode</span></span><br><span class="line">        IOUtil.configureBlocking(newfd, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        InetSocketAddress isa = isaa[<span class="number">0</span>];</span><br><span class="line">        SocketChannel sc = <span class="keyword">new</span> SocketChannelImpl(provider(), newfd, isa);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check permitted to accept connections from the remote address</span></span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException x) &#123;</span><br><span class="line">                sc.close();</span><br><span class="line">                <span class="keyword">throw</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sc;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        acceptLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里通过对所接收的连接的远程地址做合法性判断，假如验证出现异常，则关闭上面创建的<code>SocketChannel</code>。<br>还有一个关于close()的实际用法，在客户端建立连接的时候，如果连接出异常，同样是要关闭所创建的Socket:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.SocketChannel#open(java.net.SocketAddress)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">(SocketAddress remote)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SocketChannel sc = open();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sc.connect(remote);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sc.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable suppressed) &#123;</span><br><span class="line">                x.addSuppressed(suppressed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> sc.isConnected();</span><br><span class="line">        <span class="keyword">return</span> sc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接着，我们在<code>implCloseSelectableChannel</code>中会发现<code>nd.preClose(fd);</code>与<code>nd.close(fd);</code>，这个在<code>SocketChannelImpl</code>与<code>ServerSocketChannelImpl</code>两者对于<code>implCloseSelectableChannel</code>实现中都可以看到，这个nd是什么，这里，我们拿<code>ServerSocketChannelImpl</code>来讲，在这个类的最后面有一段静态代码块(<code>SocketChannelImpl</code>同理)，也就是在这个类加载的时候就会执行:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C:/Program Files/Java/jdk-11.0.1/lib/src.zip!/java.base/sun/nio/ch/ServerSocketChannelImpl.java:550</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">     <span class="comment">//加载nio，net资源库</span></span><br><span class="line">        IOUtil.load();</span><br><span class="line">        initIDs();</span><br><span class="line">        nd = <span class="keyword">new</span> SocketDispatcher();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>也就是说，在<code>ServerSocketChannelImpl</code>这个类字节码加载的时候，就会创建<code>SocketDispatcher</code>对象。通过<code>SocketDispatcher</code>允许在不同的平台调用不同的本地方法进行读写操作,然后基于这个类，我们就可以在<code>sun.nio.ch.SocketChannelImpl</code>做Socket的I/O操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketDispatcher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketDispatcher</span> <span class="keyword">extends</span> <span class="title">NativeDispatcher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        IOUtil.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读操作  </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read0(fd, address, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">readv</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readv0(fd, address, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写操作  </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> write0(fd, address, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">writev</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> writev0(fd, address, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预关闭文件描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preClose</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        preClose0(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件描述</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        close0(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- Native methods</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">read0</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">readv0</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">write0</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">writev0</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">preClose0</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">close0</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="FileDescriptor"><a href="#FileDescriptor" class="headerlink" title="FileDescriptor"></a>FileDescriptor</h4><p>我们有看到<code>FileDescriptor</code>在前面代码中有大量的出现，这里，我们对它来专门介绍。通过FileDescriptor 这个类的实例来充当底层机器特定结构的不透明处理，表示打开文件，打开socket或其他字节源或接收器。<br>文件描述符的主要用途是创建一个 FileInputStream或 FileOutputStream来包含它。<br>注意: 应用程序不应创建自己的文件描述符。<br>我们来看其部分源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> handle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Closeable parent;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Closeable&gt; otherParents;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> closed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * true, if file is opened for appending.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> append;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        initIDs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在未明确关闭FileDescriptor的情况下进行清理.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> PhantomCleanable&lt;FileDescriptor&gt; cleanup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个无效的FileDescriptor对象，fd或handle会在之后进行设定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fd = -<span class="number">1</span>;</span><br><span class="line">        handle = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Used for standard input, output, and error only.</span></span><br><span class="line"><span class="comment">     * For Windows the corresponding handle is initialized.</span></span><br><span class="line"><span class="comment">     * For Unix the append mode is cached.</span></span><br><span class="line"><span class="comment">     * 仅用于标准输入，输出和错误。</span></span><br><span class="line"><span class="comment">     * 对于Windows，初始化相应的句柄。</span></span><br><span class="line"><span class="comment">     * 对于Unix，缓存附加模式。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fd the raw fd number (0, 1, 2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileDescriptor</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fd = fd;</span><br><span class="line">        <span class="keyword">this</span>.handle = getHandle(fd);</span><br><span class="line">        <span class="keyword">this</span>.append = getAppend(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们平时所用的标准输入，输出，错误流的句柄可以如下，通常，我们不会直接使用它们，而是使用<code>java.lang.System.in</code>，<code>java.lang.System#out</code>，<code>java.lang.System#err</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor in = <span class="keyword">new</span> FileDescriptor(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor out = <span class="keyword">new</span> FileDescriptor(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor err = <span class="keyword">new</span> FileDescriptor(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>测试该文件描述符是否有效可以使用如下方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.io.FileDescriptor#valid</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (handle != -<span class="number">1</span>) || (fd != -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>返回值为true的话，那么这个文件描述符对象所代表的<code>socket</code> <code>文件操作</code>或其他活动的网络连接都是有效的，反之，false则是无效。<br>更多内容，读者可以自行深入源码，此处就不过多解释了。为了让大家可以更好的理解上述内容，我们会在后面的部分还要进一步涉及一下。</p><h3 id="NIO包下SocketChannel解读"><a href="#NIO包下SocketChannel解读" class="headerlink" title="NIO包下SocketChannel解读"></a>NIO包下SocketChannel解读</h3><p>在前面，我们已经接触了<code>SocketChannel</code>，这里，来接触下细节。</p><p>同样，我们也可以通过调用此类的<code>open</code>方法来创建<code>socket channel</code>。这里需要注意：</p><ul><li>无法为任意预先存在的<code>socket</code>创建<code>channel</code>。</li><li>新创建的<code>socket channel</code>已打开但尚未连接。</li><li>尝试在未连接的<code>channel</code>上调用<code>I/O</code>操作将导致抛出<code>NotYetConnectedException</code>。</li><li>可以通过调用<code>connect</code>方法连接<code>socket channel</code>;</li><li>一旦连接后，<code>socket channel</code>会保持连接状态，直到它关闭。</li><li>是否有连接<code>socket channel</code>可以通过确定调用其<code>isConnected</code>方法。</li></ul><p><code>socket channel</code>支持 非阻塞连接：</p><ul><li>可以先创建<code>socket channel</code>，然后可以通过 <code>connect</code> 方法建立到远程<code>socket</code>的连接。</li><li>通过调用<code>finishConnect</code>方法来结束连接。</li><li>判断是否正在进行连接操作可以通过调用<code>isConnectionPending</code>方法来确定。</li></ul><p><code>socket channel</code>支持异步关闭，类似于<code>Channel</code>类中的异步关闭操作。</p><ul><li>如果<code>socket</code>的输入端被一个线程关闭而另一个线程在此<code>socket channel</code>上因在进行读操作而被阻塞，那么被阻塞线程中的读操作将不读取任何字节并将返回 <code>-1</code> 。</li><li>如果<code>socket</code>的输出端被一个线程关闭而另一个线程在<code>socket channel</code>上因在进行写操作而被阻塞，则被阻塞的线程将收到<code>AsynchronousCloseException</code>。</li></ul><p>接下来，我们来看其具体实现方法。</p><h4 id="ServerSocketChannel与SocketChannel的open"><a href="#ServerSocketChannel与SocketChannel的open" class="headerlink" title="ServerSocketChannel与SocketChannel的open()"></a>ServerSocketChannel与SocketChannel的open()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.SocketChannel#open()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSocketChannel();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.channels.SocketChannel#open(java.net.SocketAddress)</span></span><br><span class="line"><span class="comment">//这个方法省的我们再次调用connect了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">(SocketAddress remote)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//默认是堵塞的，这个在AbstractSelectableChannel处讨论过了</span></span><br><span class="line">    SocketChannel sc = open();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sc.connect(remote);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable suppressed) &#123;</span><br><span class="line">            x.addSuppressed(suppressed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> sc.isConnected();</span><br><span class="line">    <span class="keyword">return</span> sc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorProviderImpl#openSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">openSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SocketChannelImpl(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#SocketChannelImpl(java.nio.channels.spi.SelectorProvider)</span></span><br><span class="line">SocketChannelImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">     <span class="comment">//调用socket函数，true表示TCP</span></span><br><span class="line">    <span class="keyword">this</span>.fd = Net.socket(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.fdVal = IOUtil.fdVal(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.Net#socket(boolean)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FileDescriptor <span class="title">socket</span><span class="params">(<span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> socket(UNSPEC, stream);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.Net#socket(java.net.ProtocolFamily, boolean)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FileDescriptor <span class="title">socket</span><span class="params">(ProtocolFamily family, <span class="keyword">boolean</span> stream)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> preferIPv6 = isIPv6Available() &amp;&amp;</span><br><span class="line">        (family != StandardProtocolFamily.INET);</span><br><span class="line">    <span class="keyword">return</span> IOUtil.newFD(socket0(preferIPv6, stream, <span class="keyword">false</span>, fastLoopback));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.IOUtil#newFD</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileDescriptor <span class="title">newFD</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    setfdVal(fd, i);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setfdVal</span><span class="params">(FileDescriptor fd, <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure><p>关于<code>Net.socket(true)</code>，我们前面已经提到过了，这里，通过其底层源码来再次调教下 (此处不想看可以跳过):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,</span><br><span class="line">                            jboolean stream, jboolean reuse, jboolean ignored)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//字节流还是数据报,TCP对应SOCK_STREAM,UDP对应SOCK_DGRAM,此处传入的stream=true;</span></span><br><span class="line">    <span class="keyword">int</span> type = (stream ? SOCK_STREAM : SOCK_DGRAM);</span><br><span class="line">    <span class="comment">//判断是IPV6还是IPV4</span></span><br><span class="line">    <span class="keyword">int</span> domain = (ipv6_available() &amp;&amp; preferIPv6) ? AF_INET6 : AF_INET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用Linux的socket函数,domain为代表协议;</span></span><br><span class="line">    <span class="comment">//type为套接字类型，protocol设置为0来表示使用默认的传输协议</span></span><br><span class="line">    fd = socket(domain, type, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//出错</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> handleSocketError(env, errno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disable IPV6_V6ONLY to ensure dual-socket support */</span></span><br><span class="line">    <span class="keyword">if</span> (domain == AF_INET6) &#123;</span><br><span class="line">        <span class="keyword">int</span> arg = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//arg=1设置ipv6的socket只接收ipv6地址的报文,arg=0表示也可接受ipv4的请求</span></span><br><span class="line">        <span class="keyword">if</span> (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (<span class="keyword">char</span>*)&amp;arg,</span><br><span class="line">                       sizeof(<span class="keyword">int</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            JNU_ThrowByNameWithLastError(env,</span><br><span class="line">                                         JNU_JAVANETPKG <span class="string">"SocketException"</span>,</span><br><span class="line">                                         <span class="string">"Unable to set IPV6_V6ONLY"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SO_REUSEADDR有四种用途:</span></span><br><span class="line">    <span class="comment">//1.当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。 </span></span><br><span class="line">    <span class="comment">//2.SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但每个实例绑定的IP地址是不能相同的。</span></span><br><span class="line">    <span class="comment">//3.SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。 </span></span><br><span class="line">   <span class="comment">//4.SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP;</span></span><br><span class="line">    <span class="keyword">if</span> (reuse) &#123;</span><br><span class="line">        <span class="keyword">int</span> arg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">char</span>*)&amp;arg,</span><br><span class="line">                       sizeof(arg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            JNU_ThrowByNameWithLastError(env,</span><br><span class="line">                                         JNU_JAVANETPKG <span class="string">"SocketException"</span>,</span><br><span class="line">                                         <span class="string">"Unable to set SO_REUSEADDR"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if defined(__linux__)</span><br><span class="line">    <span class="keyword">if</span> (type == SOCK_DGRAM) &#123;</span><br><span class="line">        <span class="keyword">int</span> arg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = (domain == AF_INET6) ? IPPROTO_IPV6 : IPPROTO_IP;</span><br><span class="line">        <span class="keyword">if</span> ((setsockopt(fd, level, IP_MULTICAST_ALL, (<span class="keyword">char</span>*)&amp;arg, sizeof(arg)) &lt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (errno != ENOPROTOOPT)) &#123;</span><br><span class="line">            JNU_ThrowByNameWithLastError(env,</span><br><span class="line">                                         JNU_JAVANETPKG <span class="string">"SocketException"</span>,</span><br><span class="line">                                         <span class="string">"Unable to set IP_MULTICAST_ALL"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//IPV6_MULTICAST_HOPS用于控制多播的范围，</span></span><br><span class="line">     <span class="comment">// 1表示只在本地网络转发,</span></span><br><span class="line">     <span class="comment">//更多介绍请参考(http://www.ctt.sbras.ru/cgi-bin/www/unix_help/unix-man?ip6+4);</span></span><br><span class="line">    <span class="comment">/* By default, Linux uses the route default */</span></span><br><span class="line">    <span class="keyword">if</span> (domain == AF_INET6 &amp;&amp; type == SOCK_DGRAM) &#123;</span><br><span class="line">        <span class="keyword">int</span> arg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &amp;arg,</span><br><span class="line">                       sizeof(arg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            JNU_ThrowByNameWithLastError(env,</span><br><span class="line">                                         JNU_JAVANETPKG <span class="string">"SocketException"</span>,</span><br><span class="line">                                         <span class="string">"Unable to set IPV6_MULTICAST_HOPS"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Linux 3.9之后加入了<code>SO_REUSEPORT</code>配置，这个配置很强大，多个<code>socket</code>(不管是处于监听还是非监听，不管是TCP还是UDP)只要在绑定之前设置了<code>SO_REUSEPORT</code>属性，那么就可以绑定到完全相同的地址和端口。<br>为了阻止”port 劫持”(<code>Port hijacking</code>)有一个特别的限制：所有希望共享源地址和端口的socket都必须拥有相同的有效用户id(<code>effective user ID</code>)。这样一个用户就不能从另一个用户那里”偷取”端口。另外，内核在处理<code>SO_REUSEPORT socket</code>的时候使用了其它系统上没有用到的”特殊技巧”：</p><ul><li>对于UDP socket，内核尝试平均的转发数据报;</li><li>对于TCP监听socket，内核尝试将新的客户连接请求(由accept返回)平均的交给共享同一地址和端口的socket(服务器监听socket)。</li></ul><p>例如：一个简单的服务器程序的多个实例可以使用<code>SO_REUSEPORT socket</code>，这样就实现一个简单的负载均衡，因为内核已经把请求的分配都做了。</p><p>在前面的代码中可以看到，在这个<code>socket</code>创建成功之后，调用<code>IOUtil.newFD</code>创建了文件描述符<br>。这里，我只是想知道这个Socket是可以输入呢，还是可以读呢，还是有错呢，参考<code>FileDescriptor</code>这一节最后那几个标准状态的设定，其实这里也是一样，因为我们要往Socket中写和读，其标准状态无非就这三种:输入，输出，出错。而这个Socket是绑定在<code>SocketChannel</code>上的，那就把<code>FileDescriptor</code>也绑定到上面即可，这样我们就可以获取到它的状态了。由于FileDescriptor没有提供外部设置fd的方法，setfdVal是通过本地方法实现的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_sun_nio_ch_IOUtil_setfdVal(JNIEnv *env, jclass clazz, jobject fdo, jint val)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;SetIntField(env, fdo, fd_fdID, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假如各位有对Linux下的shell编程或者命令有了解的话，我们知道，shell对报错进行重定向要使用2&gt;，也就是将错误信息由2号所指向的通道写出，这里0和1 同样指向一个通道。此处同样也代表了状态，这样就可以对代表Socket的状态进行操作了，也就是改变<code>SelectionKey</code>的<code>interest ops</code>，即首先对<code>SelectionKey</code>按输入输出类型进行分类，然后我们的读写状态的操作也就有着落了。此处我们打个戳，在下一篇中会对其进行细节讲解。</p><p>我们回归到<code>SocketChannel</code>的<code>open</code>方法中。我们可以看到，<code>SelectorProvider.provider().openSocketChannel()</code>返回的是<code>SocketChannelImpl</code>对象实例。在<code>SocketChannelImpl(SelectorProvider sp)</code>中我们并未看到其对<code>this.state</code>进行值操作，也就是其默认为0，即<code>ST_UNCONNECTED</code>(未连接状态)，同时Socket默认是堵塞的。<br>所以，一般情况下，当采用异步方式时，使用不带参数的open方法比较常见，这样，我们会随之调用<code>configureBlocking</code>来设置非堵塞。</p><h4 id="SocketChannel的connect解读"><a href="#SocketChannel的connect解读" class="headerlink" title="SocketChannel的connect解读"></a>SocketChannel的connect解读</h4><p>由前面可知，我们调用<code>connect</code>方法连接到远程服务器,其源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#connect</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress sa)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InetSocketAddress isa = Net.checkAddress(sa);</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>)</span><br><span class="line">        sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());</span><br><span class="line"></span><br><span class="line">    InetAddress ia = isa.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (ia.isAnyLocalAddress())</span><br><span class="line">        ia = InetAddress.getLocalHost();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> blocking = isBlocking();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//支持线程中断，通过设置当前线程的Interruptible blocker属性实现</span></span><br><span class="line">                    beginConnect(blocking, isa);</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//调用connect函数实现，如果采用堵塞模式，会一直等待，直到成功或出//现异常</span></span><br><span class="line">                        n = Net.connect(fd, ia, isa.getPort());</span><br><span class="line">                    &#125; <span class="keyword">while</span> (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    endConnect(blocking, (n &gt; <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">assert</span> IOStatus.check(n);</span><br><span class="line">                <span class="comment">//连接成功</span></span><br><span class="line">                <span class="keyword">return</span> n &gt; <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="comment">// connect failed, close the channel</span></span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> SocketExceptions.of(ioe, isa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于<code>beginConnect</code>与<code>endConnect</code>，是针对<code>AbstractInterruptibleChannel</code>中<code>begin()</code>与<code>end</code>方法的一种增强。这里我们需要知道的是，假如是非阻塞Channel的话，我们无须去关心连接过程的打断。顾名思义，只有阻塞等待才需要去考虑打断这一场景的出现。剩下的细节我已经在代码中进行了完整的注释，读者可自行查看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#beginConnect</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beginConnect</span><span class="params">(<span class="keyword">boolean</span> blocking, InetSocketAddress isa)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//只有阻塞的时候才会进入begin</span></span><br><span class="line">    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">        <span class="comment">// set hook for Thread.interrupt</span></span><br><span class="line">        <span class="comment">//支持线程中断，通过设置当前线程的Interruptible blocker属性实现</span></span><br><span class="line">        begin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="comment">//默认为open, 除非调用了close方法</span></span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="comment">//检查连接状态</span></span><br><span class="line">        <span class="keyword">int</span> state = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">if</span> (state == ST_CONNECTED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlreadyConnectedException();</span><br><span class="line">        <span class="keyword">if</span> (state == ST_CONNECTIONPENDING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionPendingException();</span><br><span class="line">        <span class="comment">//断言当前的状态是否是未连接状态，如果是，赋值表示正在连接中</span></span><br><span class="line">        <span class="keyword">assert</span> state == ST_UNCONNECTED;</span><br><span class="line">        <span class="comment">//表示正在连接中</span></span><br><span class="line">        <span class="keyword">this</span>.state = ST_CONNECTIONPENDING;</span><br><span class="line">        <span class="comment">//只有未绑定本地地址也就是说未调用bind方法才执行,</span></span><br><span class="line">        <span class="comment">//该方法在ServerSocketChannel中也见过</span></span><br><span class="line">        <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>)</span><br><span class="line">            NetHooks.beforeTcpConnect(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">        remoteAddress = isa;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">            <span class="comment">// record thread so it can be signalled if needed</span></span><br><span class="line">            readerThread = NativeThread.current();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在连接过程中，我们需要注意的就是几个连接的状态:<code>ST_UNCONNECTED</code>、<code>ST_CONNECTED</code> 、<code>ST_CONNECTIONPENDING</code>、<code>ST_CLOSING</code>、<code>ST_KILLPENDING</code>、<code>ST_KILLED</code>，也是因为其是一个公共状态，可能会有多个线程对其进行连接操作的。所以，<code>state</code>被定义为一个<code>volatile</code>变量，这个变量在改变的时候需要有<code>stateLock</code>这个对象来作为<code>synchronized</code>锁对象来控制同步操作的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#endConnect</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">endConnect</span><span class="params">(<span class="keyword">boolean</span> blocking, <span class="keyword">boolean</span> completed)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    endRead(blocking, completed);</span><br><span class="line">    <span class="comment">//当上面代码中n&gt;0，说明连接成功，更新状态为ST_CONNECTED</span></span><br><span class="line">    <span class="keyword">if</span> (completed) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == ST_CONNECTIONPENDING) &#123;</span><br><span class="line">                localAddress = Net.localAddress(fd);</span><br><span class="line">                state = ST_CONNECTED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#endRead</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">endRead</span><span class="params">(<span class="keyword">boolean</span> blocking, <span class="keyword">boolean</span> completed)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> AsynchronousCloseException</span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//当阻塞状态下的话，才进入</span></span><br><span class="line">    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">            readerThread = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// notify any thread waiting in implCloseSelectableChannel</span></span><br><span class="line">            <span class="keyword">if</span> (state == ST_CLOSING) &#123;</span><br><span class="line">                stateLock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//和begin成对出现，当线程中断时，抛出ClosedByInterruptException</span></span><br><span class="line">        <span class="comment">// remove hook for Thread.interrupt</span></span><br><span class="line">        end(completed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来关注<code>connect</code>中的<code>Net.connect(fd, ia, isa.getPort())</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.Net#connect</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">connect</span><span class="params">(FileDescriptor fd, InetAddress remote, <span class="keyword">int</span> remotePort)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connect(UNSPEC, fd, remote, remotePort);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.Net#connect</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">connect</span><span class="params">(ProtocolFamily family, FileDescriptor fd, InetAddress remote, <span class="keyword">int</span> remotePort)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> preferIPv6 = isIPv6Available() &amp;&amp;</span><br><span class="line">        (family != StandardProtocolFamily.INET);</span><br><span class="line">    <span class="keyword">return</span> connect0(preferIPv6, fd, remote, remotePort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法最终会调用native方法，具体注释如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_Net_connect0(JNIEnv *env, jclass clazz, jboolean preferIPv6,</span><br><span class="line">                             jobject fdo, jobject iao, jint port)</span><br><span class="line">&#123;</span><br><span class="line">    SOCKETADDRESS sa;</span><br><span class="line">    <span class="keyword">int</span> sa_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rv;</span><br><span class="line">    <span class="comment">//地址转换为struct sockaddr格式</span></span><br><span class="line">    <span class="keyword">if</span> (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> IOS_THROWN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传入fd和sockaddr,与远程服务器建立连接，一般就是TCP三次握手</span></span><br><span class="line">   <span class="comment">//如果设置了configureBlocking(false),不会堵塞，否则会堵塞一直到超时或出现异常</span></span><br><span class="line">    rv = connect(fdval(env, fdo), &amp;sa.sa, sa_len);</span><br><span class="line">    <span class="comment">//0表示连接成功，失败时通过errno获取具体原因</span></span><br><span class="line">    <span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//非堵塞，连接还未建立(-2)</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EINPROGRESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> IOS_UNAVAILABLE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="comment">//中断(-3)</span></span><br><span class="line">            <span class="keyword">return</span> IOS_INTERRUPTED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handleSocketError(env, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接建立,一般TCP连接连接都需要时间，因此除非是本地网络，</span></span><br><span class="line">    <span class="comment">//一般情况下非堵塞模式返回IOS_UNAVAILABLE比较多；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面可以通过注释看到，如果是非堵塞，而且连接也并未立马建立成功，其返回的是-2，也就是连接未建立成功，由之前<code>beginConnect</code>部分源码可知，此时状态为<code>ST_CONNECTIONPENDING</code>，那么，非阻塞条件下，什么时候会变为<code>ST_CONNECTED</code>?有什么方法可以查询状态或者等待连接完成？<br>那就让我们来关注下<code>sun.nio.ch.SocketChannelImpl#finishConnect</code></p><h4 id="SocketChannelImpl中finishConnect解读"><a href="#SocketChannelImpl中finishConnect解读" class="headerlink" title="SocketChannelImpl中finishConnect解读"></a>SocketChannelImpl中finishConnect解读</h4><p>首先，我们回顾下，前面我们涉及了<code>sun.nio.ch.ServerSocketAdaptor</code>的用法，方便我们只有Socket编程习惯人群使用，这里，我们也就可以看到基本的核心实现逻辑，那么有<code>ServerSocketAdaptor</code>就有<code>SocketAdaptor</code>，这里，在BIO的Socket编程中最后也是调用了<code>connect(address)</code>操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.Socket#Socket</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Socket</span><span class="params">(SocketAddress address, SocketAddress localAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    setImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// backward compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (address == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        createImpl(stream);</span><br><span class="line">        <span class="keyword">if</span> (localAddr != <span class="keyword">null</span>)</span><br><span class="line">            bind(localAddr);</span><br><span class="line">        connect(address);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | IllegalArgumentException | SecurityException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ce) &#123;</span><br><span class="line">            e.addSuppressed(ce);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，我们可以调用<code>java.nio.channels.SocketChannel#open()</code>，然后调用所得到的<code>SocketChannel</code>对象的<code>socket()</code>方法，就可以得到<code>sun.nio.ch.SocketAdaptor</code>对象实例了。我们来查看<code>SocketAdaptor</code>的connect实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketAdaptor#connect</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress remote)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    connect(remote, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress remote, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remote == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connect: The address can't be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connect: timeout can't be negative"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sc.blockingLock()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sc.isBlocking())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//未设定超时则会一直在此等待直到连接或者出现异常</span></span><br><span class="line">            <span class="comment">// no timeout</span></span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">                sc.connect(remote);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有超时设定，则会将Socket给设定为非阻塞</span></span><br><span class="line">            <span class="comment">// timed connect</span></span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc.connect(remote))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> timeoutNanos = NANOSECONDS.convert(timeout, MILLISECONDS);</span><br><span class="line">            <span class="keyword">long</span> to = timeout;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//通过计算超时时间，在允许的时间范围内无限循环来进行连接，</span></span><br><span class="line">                <span class="comment">//如果超时，则关闭这个Socket</span></span><br><span class="line">                <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (sc.pollConnected(to)) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> connected = sc.finishConnect();</span><br><span class="line">                    <span class="comment">//看下文解释</span></span><br><span class="line">                    <span class="keyword">assert</span> connected;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                timeoutNanos -= System.nanoTime() - startTime;</span><br><span class="line">                <span class="keyword">if</span> (timeoutNanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sc.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException x) &#123; &#125;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SocketTimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">                to = MILLISECONDS.convert(timeoutNanos, NANOSECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">            Net.translateException(x, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里先解释下一个小注意点:在Java中，<code>assert</code>关键字是从<code>JAVA SE 1.4</code> 引入的，为了避免和<strong>老版本的Java代码</strong>中使用了<code>assert</code>关键字导致错误，<strong>Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都 将忽略！），如果要开启断言检查，则需要用开关-enableassertions或-ea来开启。</strong><br>通过上面的源码注释，相信大伙已经知道大致的流程了，那关于<code>sun.nio.ch.SocketChannelImpl#finishConnect</code>到底做了什么，此处，我们来探索一番:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#finishConnect</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// no-op if already connected</span></span><br><span class="line">                <span class="keyword">if</span> (isConnected())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> blocking = isBlocking();</span><br><span class="line">                <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beginFinishConnect(blocking);</span><br><span class="line">                    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//阻塞情况下，第二个参数传入true</span></span><br><span class="line">                            n = checkConnect(fd, <span class="keyword">true</span>);</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((n == <span class="number">0</span> || n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//非阻塞情况下，第二个参数传入false</span></span><br><span class="line">                        n = checkConnect(fd, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    connected = (n &gt; <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    endFinishConnect(blocking, connected);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">assert</span> (blocking &amp;&amp; connected) ^ !blocking;</span><br><span class="line">                <span class="keyword">return</span> connected;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="comment">// connect failed, close the channel</span></span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> SocketExceptions.of(ioe, remoteAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#checkConnect</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">checkConnect</span><span class="params">(FileDescriptor fd, <span class="keyword">boolean</span> block)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>关于<code>beginFinishConnect</code>与<code>endFinishConnect</code>和我们之前分析的<code>sun.nio.ch.SocketChannelImpl#beginConnect</code>与<code>sun.nio.ch.SocketChannelImpl#endConnect</code>过程差不多，不懂读者可回看。剩下的，就是我们关注的主要核心逻辑<code>checkConnect(fd, true)</code>，它也是一个本地方法，涉及到的源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_SocketChannelImpl_checkConnect(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line">                                               jobject fdo, jboolean block)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    socklen_t n = sizeof(<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">//获取FileDescriptor中的fd</span></span><br><span class="line">    jint fd = fdval(env, fdo);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    struct pollfd poller;</span><br><span class="line">    <span class="comment">//文件描述符</span></span><br><span class="line">    poller.fd = fd;</span><br><span class="line">    <span class="comment">//请求的事件为写事件</span></span><br><span class="line">    poller.events = POLLOUT;</span><br><span class="line">    <span class="comment">//返回的事件</span></span><br><span class="line">    poller.revents = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-1表示阻塞,0表示立即返回，不阻塞进程</span></span><br><span class="line">    result = poll(&amp;poller, <span class="number">1</span>, block ? -<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//小于0表示调用失败</span></span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">return</span> IOS_INTERRUPTED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            JNU_ThrowIOExceptionWithLastError(env, <span class="string">"poll failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> IOS_THROWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非堵塞时，0表示没有准备好的连接</span></span><br><span class="line">    <span class="keyword">if</span> (!block &amp;&amp; (result == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> IOS_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//准备好写或出现错误的socket数量&gt;0</span></span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        result = getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;n);</span><br><span class="line">        <span class="comment">//出错</span></span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleSocketError(env, errno);</span><br><span class="line">        <span class="comment">//发生错误，处理错误</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleSocketError(env, error);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((poller.revents &amp; POLLHUP) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleSocketError(env, ENOTCONN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//socket已经准备好，可写，即连接已经建立好</span></span><br><span class="line">        <span class="comment">// connected</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体的过程如源码注释所示，其中是否阻塞我们在本地方法源码中和之前<code>sun.nio.ch.SocketChannelImpl#finishConnect</code>的行为产生对应。另外，从上面的源码看到，底层是通过<code>poll</code>查询<code>socket</code>的状态，从而判断连接是否建立成功；由于在非堵塞模式下，<code>finishConnect</code>方法会立即返回，根据此处<code>sun.nio.ch.SocketAdaptor#connect</code>的处理，其使用循环的方式判断连接是否建立，在我们的nio编程中，这个是不建议的，属于半成品，而是建议注册到<code>Selector</code>，通过<code>ops=OP_CONNECT</code>获取连接完成的<code>SelectionKey</code>,然后调用<code>finishConnect</code>完成连接的建立；<br>那么<code>finishConnect</code>是否可以不调用呢？答案是否定的，因为只有<code>finishConnect</code>中才会将状态更新为<code>ST_CONNECTED</code>，而在调用<code>read</code>和<code>write</code>时都会对状态进行判断。</p><p>这里，我们算是引出了我们即将要涉及的<code>Selector</code>和<code>SelectionKey</code>，我们会在下一篇中进行详细讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。&lt;/p&gt;
&lt;p&gt;关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:&lt;/p&gt;
&lt;p&gt;Rxjava源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av34537840&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av34537840&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Reactor源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av35326911&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av35326911&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列源码解读基于JDK11 api细节可能与其他版本有所差别，请自行解决jdk版本问题。&lt;/p&gt;
    
    </summary>
    
      <category term="响应式" scheme="https://muyinchen.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
      <category term="Reactor Rxjava  NIO" scheme="https://muyinchen.github.io/tags/Reactor-Rxjava-NIO/"/>
    
  </entry>
  
  <entry>
    <title>BIO到NIO源码的一些事儿之NIO 上</title>
    <link href="https://muyinchen.github.io/2019/01/03/BIO%E5%88%B0NIO%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF%E4%B9%8BNIO%20%E4%B8%8A/"/>
    <id>https://muyinchen.github.io/2019/01/03/BIO到NIO源码的一些事儿之NIO 上/</id>
    <published>2019-01-03T15:40:25.000Z</published>
    <updated>2019-01-05T14:34:44.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BIO到NIO源码的一些事儿之NIO-上"><a href="#BIO到NIO源码的一些事儿之NIO-上" class="headerlink" title="BIO到NIO源码的一些事儿之NIO 上"></a>BIO到NIO源码的一些事儿之NIO 上</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此篇文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。</p><p>关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:</p><p>Rxjava源码解读与分享：<a href="https://www.bilibili.com/video/av34537840" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840</a></p><p>Reactor源码解读与分享：<a href="https://www.bilibili.com/video/av35326911" target="_blank" rel="noopener">https://www.bilibili.com/video/av35326911</a></p><a id="more"></a><h2 id="场景代入"><a href="#场景代入" class="headerlink" title="场景代入"></a>场景代入</h2><p>接上一篇 <a href="https://juejin.im/post/5c2cc075f265da611037298e" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之BIO</a>，我们来接触NIO的一些事儿。</p><p>在上一篇中，我们可以看到，我们要做到异步非阻塞，我们自己进行的是创建线程池同时对部分代码做timeout的修改来对接客户端，但是弊端也很清晰，我们转换下思维，这里举个场景例子，A班同学要和B班同学一起一对一完成任务，每对人拿到的任务是不一样的，消耗的时间有长有短，任务因为有奖励所以同学们会抢，传统模式下，A班同学和B班同学不经管理话，即便只是一个心跳检测的任务都得一起，在这种情况下，客户端根本不会有数据要发送，只是想告诉服务器自己还活着，这种情况下，假如B班再来一个同学做对接的话，就很有问题了，B班的每一个同学都可以看成服务器端的一个线程。所以，我们需要一个管理者，于是<code>Selector</code>就出现了，作为管理者，这里，我们往往需要管理同学们的状态，是否在等待任务，是否在接收信息，是否在输出信息等等，<code>Selector</code>更侧重于动作，针对于这些状态标签来做事情就可以了，那这些状态标签其实也是需要管理的，于是<code>SelectionKey</code>也就应运而生。接着我们需要对这些同学进行包装增强，使之携带这样的标签。同样，对于同学我们应该进一步解放双手的，比如给其配台电脑，这样，同学是不是可以做更多的事情了，那这个电脑在此处就是Buffer的存在了。<br>于是在NIO中最主要是有三种角色的，<code>Buffer</code>缓冲区，<code>Channel</code>通道，<code>Selector</code>选择器，我们都涉及到了，接下来，我们对其源码一步步分析解读。</p><h2 id="Channel解读"><a href="#Channel解读" class="headerlink" title="Channel解读"></a>Channel解读</h2><h3 id="赋予Channel可异步可中断的能力"><a href="#赋予Channel可异步可中断的能力" class="headerlink" title="赋予Channel可异步可中断的能力"></a>赋予Channel可异步可中断的能力</h3><p>有上可知，同学其实都是代表着一个个的<code>Socket</code>的存在，那么这里<code>Channel</code>就是对其进行的增强包装，也就是<code>Channel</code>的具体实现里应该有<code>Socket</code>这个字段才行，然后具体实现类里面也是紧紧围绕着<code>Socket</code>具备的功能来做文章的。那么，我们首先来看<code>java.nio.channels.Channel</code>接口的设定:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tells whether or not this channel is open.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if, and only if, this channel is open</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this channel.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; After a channel is closed, any further attempt to invoke I/O</span></span><br><span class="line"><span class="comment">     * operations upon it will cause a &#123;<span class="doctag">@link</span> ClosedChannelException&#125; to be</span></span><br><span class="line"><span class="comment">     * thrown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this channel is already closed then invoking this method has no</span></span><br><span class="line"><span class="comment">     * effect.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; This method may be invoked at any time.  If some other thread has</span></span><br><span class="line"><span class="comment">     * already invoked it, however, then another invocation will block until</span></span><br><span class="line"><span class="comment">     * the first invocation is complete, after which it will return without</span></span><br><span class="line"><span class="comment">     * effect. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IOException  If an I/O error occurs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处就是很直接的设定，判断Channel是否是open状态，关闭Channel的动作，我们在接下来会讲到<code>ClosedChannelException</code>是如何具体在代码中发生的。<br>有时候，一个Channel可能会被异步关闭和中断，这也是我们所需求的。那么要实现这个效果我们须得设定一个可以进行此操作效果的接口。达到的具体的效果应该是如果线程在实现这个接口的的Channel中进行IO操作的时候，另一个线程可以调用该Channel的close方法。导致的结果就是，进行IO操作的那个阻塞线程会收到一个<code>AsynchronousCloseException</code>异常。</p><p>同样，我们应该考虑到另一种情况，如果线程在实现这个接口的的Channel中进行IO操作的时候，另一个线程可能会调用被阻塞线程的<code>interrupt</code>方法(<code>Thread#interrupt()</code>)，从而导致Channel关闭，那么这个阻塞的线程应该要收到<code>ClosedByInterruptException</code>异常，同时将中断状态设定到该阻塞线程之上。</p><p>这时候，如果中断状态已经在该线程设定完毕，此时在其之上的有Channel又调用了IO阻塞操作，那么，这个Channel会被关闭，同时，该线程会立即受到一个<code>ClosedByInterruptException</code>异常，它的interrupt状态仍然保持不变。<br>这个接口定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterruptibleChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Channel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this channel.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Any thread currently blocked in an I/O operation upon this channel</span></span><br><span class="line"><span class="comment">     * will receive an &#123;<span class="doctag">@link</span> AsynchronousCloseException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; This method otherwise behaves exactly as specified by the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Channel#close Channel&#125; interface.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IOException  If an I/O error occurs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其针对上面所提到逻辑的具体实现是在<code>java.nio.channels.spi.AbstractInterruptibleChannel</code>进行的，关于这个类的解析，我们来参考这篇文章<a href="https://github.com/muyinchen/woker/blob/master/NIO/%E8%A1%A5%E5%85%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%9AInterruptibleChannel%20%E4%B8%8E%E5%8F%AF%E4%B8%AD%E6%96%AD%20IO.md" target="_blank" rel="noopener">InterruptibleChannel 与可中断 IO</a></p><h3 id="赋予Channel可被多路复用的能力"><a href="#赋予Channel可被多路复用的能力" class="headerlink" title="赋予Channel可被多路复用的能力"></a>赋予Channel可被多路复用的能力</h3><p>我们在前面有说到，<code>Channel</code>可以被<code>Selector</code>进行使用，而<code>Selector</code>是根据<code>Channel</code>的状态来分配任务的，那么<code>Channel</code>应该提供一个注册到<code>Selector</code>上的方法，来和<code>Selector</code>进行绑定。也就是说<code>Channel</code>的实例要调用<code>register(Selector,int,Object)</code>。注意，因为<code>Selector</code>是要根据状态值进行管理的，所以此方法会返回一个<code>SelectionKey</code>对象来表示这个<code>channel</code>在<code>selector</code>上的状态。关于<code>SelectionKey</code>，它是包含很多东西的，这里暂不提。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#register</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (!isOpen())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">        <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isBlocking())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">            <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                <span class="comment">// re-check if channel has been closed</span></span><br><span class="line">                <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                SelectionKey k = findKey(sel);</span><br><span class="line">                <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    k.attach(att);</span><br><span class="line">                    k.interestOps(ops);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// New registration</span></span><br><span class="line">                    k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">                    addKey(k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#addKey</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addKey</span><span class="params">(SelectionKey k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(keyLock);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((keys != <span class="keyword">null</span>) &amp;&amp; (keyCount &lt; keys.length)) &#123;</span><br><span class="line">            <span class="comment">// Find empty element of key array</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (keys[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keys == <span class="keyword">null</span>) &#123;</span><br><span class="line">            keys = <span class="keyword">new</span> SelectionKey[<span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Grow key array</span></span><br><span class="line">            <span class="keyword">int</span> n = keys.length * <span class="number">2</span>;</span><br><span class="line">            SelectionKey[] ks =  <span class="keyword">new</span> SelectionKey[n];</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; i++)</span><br><span class="line">                ks[i] = keys[i];</span><br><span class="line">            keys = ks;</span><br><span class="line">            i = keyCount;</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = k;</span><br><span class="line">        keyCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>一旦注册到<code>Selector</code>上，Channel将一直保持注册直到其被解除注册。在解除注册的时候会解除Selector分配给Channel的所有资源。<br>也就是Channel并没有直接提供解除注册的方法，那我们换一个思路，我们将Selector上代表其注册的Key取消不就可以了。这里可以通过调用<code>SelectionKey#cancel()</code>方法来显式的取消key。然后在<code>Selector</code>下一次选择操作期间进行对Channel的取消注册。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectionKey#cancel</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cancels this key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this key has not yet been cancelled then it is added to its</span></span><br><span class="line"><span class="comment">     * selector's cancelled-key set while synchronized on that set.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Synchronizing "this" to prevent this key from getting canceled</span></span><br><span class="line">        <span class="comment">// multiple times by different threads, which might cause race</span></span><br><span class="line">        <span class="comment">// condition between selector's select() and channel's close().</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//还是调用Selector的cancel方法</span></span><br><span class="line">                ((AbstractSelector)selector()).cancel(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelector#cancel</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(SelectionKey k)</span> </span>&#123;                       </span><br><span class="line">        <span class="keyword">synchronized</span> (cancelledKeys) &#123;</span><br><span class="line">            cancelledKeys.add(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在下一次select操作的时候来解除那些要求cancel的key，即解除Channel注册</span></span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#select(long)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative timeout"</span>);</span><br><span class="line">            <span class="comment">//重点关注此方法</span></span><br><span class="line">        <span class="keyword">return</span> lockAndDoSelect(<span class="keyword">null</span>, (timeout == <span class="number">0</span>) ? -<span class="number">1</span> : timeout);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#lockAndDoSelect</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockAndDoSelect</span><span class="params">(Consumer&lt;SelectionKey&gt; action, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">if</span> (inSelect)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"select in progress"</span>);</span><br><span class="line">            inSelect = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (publicSelectedKeys) &#123;</span><br><span class="line">                    <span class="comment">//重点关注此方法</span></span><br><span class="line">                    <span class="keyword">return</span> doSelect(action, timeout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                inSelect = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#doSelect</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(Consumer&lt;SelectionKey&gt; action, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout; <span class="comment">// set selector timeout</span></span><br><span class="line">        processUpdateQueue();</span><br><span class="line">        <span class="comment">//重点关注此方法</span></span><br><span class="line">        processDeregisterQueue();</span><br><span class="line">        <span class="keyword">if</span> (interruptTriggered) &#123;</span><br><span class="line">            resetWakeupSocket();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sun.nio.ch.SelectorImpl#processDeregisterQueue</span></span><br><span class="line"><span class="comment">     * Invoked by selection operations to process the cancelled-key set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processDeregisterQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(publicSelectedKeys);</span><br><span class="line"></span><br><span class="line">        Set&lt;SelectionKey&gt; cks = cancelledKeys();</span><br><span class="line">        <span class="keyword">synchronized</span> (cks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cks.isEmpty()) &#123;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; i = cks.iterator();</span><br><span class="line">                <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();</span><br><span class="line">                    i.remove();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// remove the key from the selector</span></span><br><span class="line">                    implDereg(ski);</span><br><span class="line"></span><br><span class="line">                    selectedKeys.remove(ski);</span><br><span class="line">                    keys.remove(ski);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// remove from channel's key set</span></span><br><span class="line">                    deregister(ski);</span><br><span class="line"></span><br><span class="line">                    SelectableChannel ch = ski.channel();</span><br><span class="line">                    <span class="keyword">if</span> (!ch.isOpen() &amp;&amp; !ch.isRegistered())</span><br><span class="line">                        ((SelChImpl)ch).kill();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里，当Channel关闭时，无论是通过调用<code>Channel#close</code>还是通过打断线程的方式来对Channel进行关闭，其都会隐式的取消关于这个Channel的所有的keys，其内部也是调用了<code>k.cancel()</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractInterruptibleChannel#close</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this channel.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If the channel has already been closed then this method returns</span></span><br><span class="line"><span class="comment">     * immediately.  Otherwise it marks the channel as closed and then invokes</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> #implCloseChannel implCloseChannel&#125; method in order to</span></span><br><span class="line"><span class="comment">     * complete the close operation.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IOException</span></span><br><span class="line"><span class="comment">     *          If an I/O error occurs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            closed = <span class="keyword">true</span>;</span><br><span class="line">            implCloseChannel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#implCloseChannel</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">implCloseChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        implCloseSelectableChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clone keys to avoid calling cancel when holding keyLock</span></span><br><span class="line">        SelectionKey[] copyOfKeys = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys != <span class="keyword">null</span>) &#123;</span><br><span class="line">                copyOfKeys = keys.clone();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copyOfKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SelectionKey k : copyOfKeys) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    k.cancel();   <span class="comment">// invalidate and adds key to cancelledKey set</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果<code>Selector</code>自身关闭掉，那么Channel也会被解除注册，同时代表Channel注册的key也将变得无效：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelector#close</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> open = selectorOpen.getAndSet(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!open)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        implCloseSelector();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#implCloseSelector</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">implCloseSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    wakeup();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        implClose();</span><br><span class="line">        <span class="keyword">synchronized</span> (publicSelectedKeys) &#123;</span><br><span class="line">            <span class="comment">// Deregister channels</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; i = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                SelectionKeyImpl ski = (SelectionKeyImpl)i.next();</span><br><span class="line">                deregister(ski);</span><br><span class="line">                SelectableChannel selch = ski.channel();</span><br><span class="line">                <span class="keyword">if</span> (!selch.isOpen() &amp;&amp; !selch.isRegistered())</span><br><span class="line">                    ((SelChImpl)selch).kill();</span><br><span class="line">                selectedKeys.remove(ski);</span><br><span class="line">                i.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> selectedKeys.isEmpty() &amp;&amp; keys.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个channel最多可以最多只能在特定的selector注册一次。我们可以通过调用<code>java.nio.channels.SelectableChannel#isRegistered</code>的方法来确定是否向一个或多个Selector注册了channel。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#isRegistered</span></span><br><span class="line"> <span class="comment">// -- Registration --</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isRegistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">            <span class="comment">//我们在之前往Selector上注册的时候调用了addKey方法，即每次往//一个Selector注册一次，keyCount就要自增一次。</span></span><br><span class="line">            <span class="keyword">return</span> keyCount != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>至此，继承了SelectableChannel这个类之后，这个channel就可以安全的由多个并发线程来使用。<br>这里，要注意的是，继承了<code>AbstractSelectableChannel</code>这个类之后，新创建的channel始终处于阻塞模式。然而与<code>Selector</code>的多路复用有关的操作必须基于非阻塞模式，所以在注册到<code>Selector</code>之前，必须将<code>channel</code>置于非阻塞模式，并且在取消注册之前，<code>channel</code>可能不会返回到阻塞模式。<br>这里，我们涉及了Channel的阻塞模式与非阻塞模式。在阻塞模式下，在<code>Channel</code>上调用的每个I/O操作都将阻塞，直到完成为止。 在非阻塞模式下，I/O操作永远不会阻塞，并且可以传输比请求的字节更少的字节，或者根本不传输任何字节。 我们可以通过调用channel的isBlocking方法来确定其是否为阻塞模式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#register</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (!isOpen())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">        <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">     <span class="comment">//此处会做判断，假如是阻塞模式，则会返回true，然后就会抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (isBlocking())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">            <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                <span class="comment">// re-check if channel has been closed</span></span><br><span class="line">                <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                SelectionKey k = findKey(sel);</span><br><span class="line">                <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    k.attach(att);</span><br><span class="line">                    k.interestOps(ops);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// New registration</span></span><br><span class="line">                    k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">                    addKey(k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>所以，我们在使用的时候可以基于以下的例子作为参考:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NIOServerSelectorThread</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//打开ServerSocketChannel，用于监听客户端的连接，他是所有客户端连接的父管道</span></span><br><span class="line">serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//将管道设置为非阻塞模式</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//利用ServerSocketChannel创建一个服务端Socket对象，即ServerSocket</span></span><br><span class="line">serverSocket = serverSocketChannel.socket();</span><br><span class="line"><span class="comment">//为服务端Socket绑定监听端口</span></span><br><span class="line">serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"><span class="comment">//创建多路复用器</span></span><br><span class="line">selector = Selector.open();</span><br><span class="line"><span class="comment">//将ServerSocketChannel注册到Selector多路复用器上，并且监听ACCEPT事件</span></span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">System.out.println(<span class="string">"The server is start in port: "</span>+port);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因时间关系，本篇暂时到这里，剩下的会在下一篇中进行讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BIO到NIO源码的一些事儿之NIO-上&quot;&gt;&lt;a href=&quot;#BIO到NIO源码的一些事儿之NIO-上&quot; class=&quot;headerlink&quot; title=&quot;BIO到NIO源码的一些事儿之NIO 上&quot;&gt;&lt;/a&gt;BIO到NIO源码的一些事儿之NIO 上&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;此篇文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。&lt;/p&gt;
&lt;p&gt;关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:&lt;/p&gt;
&lt;p&gt;Rxjava源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av34537840&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av34537840&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Reactor源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av35326911&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av35326911&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="响应式" scheme="https://muyinchen.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
      <category term="Reactor Rxjava  NIO" scheme="https://muyinchen.github.io/tags/Reactor-Rxjava-NIO/"/>
    
  </entry>
  
  <entry>
    <title>BIO到NIO源码的一些事儿之BIO</title>
    <link href="https://muyinchen.github.io/2019/01/02/BIO%E5%88%B0NIO%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF%E4%B9%8BBIO/"/>
    <id>https://muyinchen.github.io/2019/01/02/BIO到NIO源码的一些事儿之BIO/</id>
    <published>2019-01-02T14:40:25.000Z</published>
    <updated>2019-01-02T14:08:33.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BIO到NIO源码的一些事儿之BIO"><a href="#BIO到NIO源码的一些事儿之BIO" class="headerlink" title="BIO到NIO源码的一些事儿之BIO"></a>BIO到NIO源码的一些事儿之BIO</h1><p>此篇文章会详细解读由BIO到NIO的逐步演进的心灵路程，为Reactor-Netty 库的讲解铺平道路。</p><p>关于<code>Java编程方法论-Reactor与Webflux</code>的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:</p><p>Rxjava源码解读与分享：<a href="https://www.bilibili.com/video/av34537840" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840</a></p><p>Reactor源码解读与分享：<a href="https://www.bilibili.com/video/av35326911" target="_blank" rel="noopener">https://www.bilibili.com/video/av35326911</a></p><a id="more"></a><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>我们通过一个BIO的Demo来展示其用法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBIOServer</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;<span class="comment">//服务端Socket</span></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;<span class="comment">//客户端socket</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        String inputContent;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(stringNowTime() + <span class="string">": serverSocket started"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                System.out.println(stringNowTime() + <span class="string">": id为"</span> + socket.hashCode()+ <span class="string">"的Clientsocket connected"</span>);</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> ((inputContent = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到id为"</span> + socket.hashCode() + <span class="string">"  "</span>+inputContent);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"id为"</span> + socket.hashCode()+ <span class="string">"的Clientsocket "</span>+stringNowTime()+<span class="string">"读取结束"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringNowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        <span class="keyword">return</span> format.format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BIOServer server = <span class="keyword">new</span> BIOServer();</span><br><span class="line">        server.initBIOServer(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBIOClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        String inputContent;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">            writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">            System.out.println(<span class="string">"clientSocket started: "</span> + stringNowTime());</span><br><span class="line">            <span class="keyword">while</span> (((inputContent = reader.readLine()) != <span class="keyword">null</span>) &amp;&amp; count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                inputContent = stringNowTime() + <span class="string">": 第"</span> + count + <span class="string">"条消息: "</span> + inputContent + <span class="string">"\n"</span>;</span><br><span class="line">                writer.write(inputContent);<span class="comment">//将消息发送给服务端</span></span><br><span class="line">                writer.flush();</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">                reader.close();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringNowTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        <span class="keyword">return</span> format.format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BIOClient client = <span class="keyword">new</span> BIOClient();</span><br><span class="line">        client.initBIOClient(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子，我们可以知道，无论是服务端还是客户端，我们关注的几个操作有基于服务端的<code>serverSocket = new ServerSocket(port)</code> <code>serverSocket.accept()</code>，基于客户端的<code>Socket socket = new Socket(host, port);</code> 以及两者都有的读取与写入Socket数据的方式，即通过流来进行读写，这个读写不免通过一个中间字节数组buffer来进行。</p><h2 id="ServerSocket中bind解读"><a href="#ServerSocket中bind解读" class="headerlink" title="ServerSocket中bind解读"></a>ServerSocket中bind解读</h2><p>于是，我们通过源码来看这些相应的逻辑。我们先来看<code>ServerSocket.java</code>这个类的相关代码。<br>我们查看<code>ServerSocket.java</code>的构造器可以知道，其最后依然会调用它的<code>bind</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket#ServerSocket(int)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(port, <span class="number">50</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    setImpl();</span><br><span class="line">    <span class="keyword">if</span> (port &lt; <span class="number">0</span> || port &gt; <span class="number">0xFFFF</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Port value out of range: "</span> + port);</span><br><span class="line">    <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">        backlog = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bind(<span class="keyword">new</span> InetSocketAddress(bindAddr, port), backlog);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照我们的Demo和上面的源码可知，这里传入的参数endpoint并不会为null，同时，属于<code>InetSocketAddress</code>类型，backlog大小为50，于是，我们应该关注的主要代码逻辑也就是<code>getImpl().bind(epoint.getAddress(), epoint.getPort());</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress endpoint, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isClosed())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!oldImpl &amp;&amp; isBound())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Already bound"</span>);</span><br><span class="line">    <span class="keyword">if</span> (endpoint == <span class="keyword">null</span>)</span><br><span class="line">        endpoint = <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(endpoint <span class="keyword">instanceof</span> InetSocketAddress))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported address type"</span>);</span><br><span class="line">    InetSocketAddress epoint = (InetSocketAddress) endpoint;</span><br><span class="line">    <span class="keyword">if</span> (epoint.isUnresolved())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Unresolved address"</span>);</span><br><span class="line">    <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">        backlog = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>)</span><br><span class="line">            security.checkListen(epoint.getPort());</span><br><span class="line">        <span class="comment">// 我们应该关注的主要逻辑</span></span><br><span class="line">        getImpl().bind(epoint.getAddress(), epoint.getPort());</span><br><span class="line">        getImpl().listen(backlog);</span><br><span class="line">        bound = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">        bound = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        bound = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里<code>getImpl()</code>，由上面构造器的实现中，我们有看到<code>setImpl();</code>，可知，其<code>factory</code>默认为null，所以，这里我们关注的是<code>SocksSocketImpl</code>这个类，创建其对象，并将当前<code>ServerSocket</code>对象设定其中，这个设定的源码请在<code>SocksSocketImpl</code>的父类<code>java.net.SocketImpl</code>中查看。<br>那么getImpl也就明了了，其实就是我们Socket的底层实现对应的实体类了，因为不同的操作系统内核是不同的，他们对于Socket的实现当然会各有不同，我们这点要注意下，这里针对的是win下面的系统。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The factory for all server sockets.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SocketImplFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        impl = factory.createSocketImpl();</span><br><span class="line">        checkOldImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No need to do a checkOldImpl() here, we know it's an up to date</span></span><br><span class="line">        <span class="comment">// SocketImpl!</span></span><br><span class="line">        impl = <span class="keyword">new</span> SocksSocketImpl();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (impl != <span class="keyword">null</span>)</span><br><span class="line">        impl.setServerSocket(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Get the &#123;<span class="doctag">@code</span> SocketImpl&#125; attached to this socket, creating</span></span><br><span class="line"><span class="comment">* it if necessary.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  the &#123;<span class="doctag">@code</span> SocketImpl&#125; attached to that ServerSocket.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> SocketException if creation fails.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">SocketImpl <span class="title">getImpl</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!created)</span><br><span class="line">        createImpl();</span><br><span class="line">    <span class="keyword">return</span> impl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates the socket implementation.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException if creation fails</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createImpl</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (impl == <span class="keyword">null</span>)</span><br><span class="line">        setImpl();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        impl.create(<span class="keyword">true</span>);</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再看<code>SocksSocketImpl</code>的bind方法实现，然后得到其最后无非是调用本地方法<code>bind0</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.AbstractPlainSocketImpl#bind</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Binds the socket to the specified address of the specified local port.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> address the address</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> lport the port</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(InetAddress address, <span class="keyword">int</span> lport)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (fdLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!closePending &amp;&amp; (socket == <span class="keyword">null</span> || !socket.isBound())) &#123;</span><br><span class="line">            NetHooks.beforeTcpBind(fd, address, lport);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    socketBind(address, lport);</span><br><span class="line">    <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">        socket.setBound();</span><br><span class="line">    <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)</span><br><span class="line">        serverSocket.setBound();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.net.PlainSocketImpl#socketBind</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketBind</span><span class="params">(InetAddress address, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nativefd = checkAndReturnNativeFD();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (address == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"inet address argument is null."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preferIPv4Stack &amp;&amp; !(address <span class="keyword">instanceof</span> Inet4Address))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Protocol family not supported"</span>);</span><br><span class="line"></span><br><span class="line">    bind0(nativefd, address, port, useExclusiveBind);</span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">0</span>) &#123;</span><br><span class="line">        localport = localPort0(nativefd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        localport = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.net.PlainSocketImpl#bind0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">bind0</span><span class="params">(<span class="keyword">int</span> fd, InetAddress localAddress, <span class="keyword">int</span> localport,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span> exclBind)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>这里，我们还要了解的是，使用了多线程只是能够实现对”业务逻辑处理”的多线程，但是对于数据报文的接收还是需要一个一个来的，也就是我们上面Demo中见到的accept以及read方法阻塞问题，多线程是根本解决不了的，那么首先我们来看看accept为什么会造成阻塞，accept方法的作用是询问操作系统是否有新的Socket套接字信息从端口XXX处发送过来，注意这里询问的是操作系统，也就是说Socket套接字IO模式的支持是基于操作系统的，如果操作系统没有发现有套接字从指定端口XXX连接进来，那么操作系统就会等待，这样accept方法就会阻塞，他的内部实现使用的是操作系统级别的同步IO。</p><h2 id="ServerSocket中accept解读"><a href="#ServerSocket中accept解读" class="headerlink" title="ServerSocket中accept解读"></a>ServerSocket中accept解读</h2><p>于是，我们来分析下<code>ServerSocket.accept</code>方法的源码过程:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isClosed())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!isBound())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is not bound yet"</span>);</span><br><span class="line">    Socket s = <span class="keyword">new</span> Socket((SocketImpl) <span class="keyword">null</span>);</span><br><span class="line">    implAccept(s);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先进行的是一些判断，接着创建了一个Socket对象（为什么这里要创建一个Socket对象，后面会讲到），执行了implAccept方法，来看看implAccept方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Subclasses of ServerSocket use this method to override accept()</span></span><br><span class="line"><span class="comment">* to return their own subclass of socket.  So a FooServerSocket</span></span><br><span class="line"><span class="comment">* will typically hand this method an &lt;i&gt;empty&lt;/i&gt; FooSocket.  On</span></span><br><span class="line"><span class="comment">* return from implAccept the FooSocket will be connected to a client.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> s the Socket</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> java.nio.channels.IllegalBlockingModeException</span></span><br><span class="line"><span class="comment">*         if this socket has an associated channel,</span></span><br><span class="line"><span class="comment">*         and the channel is in non-blocking mode</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException if an I/O error occurs when waiting</span></span><br><span class="line"><span class="comment">* for a connection.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span>   1.1</span></span><br><span class="line"><span class="comment">* <span class="doctag">@revised</span> 1.4</span></span><br><span class="line"><span class="comment">* <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">implAccept</span><span class="params">(Socket s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">SocketImpl si = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.impl == <span class="keyword">null</span>)</span><br><span class="line">        s.setImpl();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s.impl.reset();</span><br><span class="line">    &#125;</span><br><span class="line">    si = s.impl;</span><br><span class="line">    s.impl = <span class="keyword">null</span>;</span><br><span class="line">    si.address = <span class="keyword">new</span> InetAddress();</span><br><span class="line">    si.fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    getImpl().accept(si);  <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    SocketCleanable.register(si.fd);   <span class="comment">// raw fd has been set</span></span><br><span class="line"></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkAccept(si.getInetAddress().getHostAddress(),</span><br><span class="line">                                si.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (si != <span class="keyword">null</span>)</span><br><span class="line">        si.reset();</span><br><span class="line">    s.impl = si;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (si != <span class="keyword">null</span>)</span><br><span class="line">        si.reset();</span><br><span class="line">    s.impl = si;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line">s.impl = si;</span><br><span class="line">s.postAccept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面执行了<1>处getImpl的accept方法之后，我们在AbstractPlainSocketImpl找到accept方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.AbstractPlainSocketImpl#accept</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Accepts connections.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> s the connection</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SocketImpl s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">acquireFD();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    socketAccept(s);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    releaseFD();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></1></p><p>可以看到他调用了socketAccept方法，因为每个操作系统的Socket地实现都不同，所以这里Windows下就执行了我们PlainSocketImpl里面的socketAccept方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.net.PlainSocketImpl#socketAccept</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketAccept</span><span class="params">(SocketImpl s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nativefd = checkAndReturnNativeFD();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"socket is null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newfd = -<span class="number">1</span>;</span><br><span class="line">    InetSocketAddress[] isaa = <span class="keyword">new</span> InetSocketAddress[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;  <span class="comment">//&lt;1&gt;</span></span><br><span class="line">        newfd = accept0(nativefd, isaa); <span class="comment">// &lt;2&gt;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        configureBlocking(nativefd, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            waitForNewConnection(nativefd, timeout);</span><br><span class="line">            newfd = accept0(nativefd, isaa);  <span class="comment">// &lt;3&gt;</span></span><br><span class="line">            <span class="keyword">if</span> (newfd != -<span class="number">1</span>) &#123;</span><br><span class="line">                configureBlocking(newfd, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            configureBlocking(nativefd, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// &lt;4&gt;</span></span><br><span class="line">    <span class="comment">/* Update (SocketImpl)s' fd */</span></span><br><span class="line">    fdAccess.set(s.fd, newfd);</span><br><span class="line">    <span class="comment">/* Update socketImpls remote port, address and localport */</span></span><br><span class="line">    InetSocketAddress isa = isaa[<span class="number">0</span>];</span><br><span class="line">    s.port = isa.getPort();</span><br><span class="line">    s.address = isa.getAddress();</span><br><span class="line">    s.localport = localport;</span><br><span class="line">    <span class="keyword">if</span> (preferIPv4Stack &amp;&amp; !(s.address <span class="keyword">instanceof</span> Inet4Address))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Protocol family not supported"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.net.PlainSocketImpl#accept0</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">accept0</span><span class="params">(<span class="keyword">int</span> fd, InetSocketAddress[] isaa)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>  这里<1>到<4>之间是我们关注的代码，<2>和<3>执行了accept0方法，这个是native方法，具体来说就是与操作系统交互来实现监听指定端口上是否有客户端接入，正是因为accept0在没有客户端接入的时候会一直处于阻塞状态，所以造成了我们程序级别的accept方法阻塞，当然对于程序级别的阻塞，我们是可以避免的，也就是我们可以将accept方法修改成非阻塞式，但是对于accept0造成的阻塞我们暂时是没法改变的，操作系统级别的阻塞其实就是我们通常所说的同步异步中的同步了。<br>前面说到我们可以在程序级别改变accept的阻塞，具体怎么实现？其实就是通过我们上面socketAccept方法中判断timeout的值来实现，在第<1>处判断timeout的值如果小于等于0，那么直接执行accept0方法，这时候将一直处于阻塞状态，但是如果我们设置了timeout的话，即timeout值大于0的话，则程序会在等到我们设置的时间后返回，注意这里的newfd如果等于-1的话，表示这次accept没有发现有数据从底层返回；那么到底timeout的值是在哪设置？我们可以通过ServerSocket的setSoTimeout方法进行设置，来看看这个方法：</1></3></2></4></1></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Enable/disable &#123;<span class="doctag">@link</span> SocketOptions#SO_TIMEOUT SO_TIMEOUT&#125; with the</span></span><br><span class="line"><span class="comment">* specified timeout, in milliseconds.  With this option set to a non-zero</span></span><br><span class="line"><span class="comment">* timeout, a call to accept() for this ServerSocket</span></span><br><span class="line"><span class="comment">* will block for only this amount of time.  If the timeout expires,</span></span><br><span class="line"><span class="comment">* a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the</span></span><br><span class="line"><span class="comment">* ServerSocket is still valid.  The option &lt;B&gt;must&lt;/B&gt; be enabled</span></span><br><span class="line"><span class="comment">* prior to entering the blocking operation to have effect.  The</span></span><br><span class="line"><span class="comment">* timeout must be &#123;<span class="doctag">@code</span> &gt; 0&#125;.</span></span><br><span class="line"><span class="comment">* A timeout of zero is interpreted as an infinite timeout.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> timeout the specified timeout, in milliseconds</span></span><br><span class="line"><span class="comment">* <span class="doctag">@exception</span> SocketException if there is an error in</span></span><br><span class="line"><span class="comment">* the underlying protocol, such as a TCP error.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span>   1.1</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #getSoTimeout()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSoTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isClosed())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line">getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其执行了getImpl的setOption方法，并且设置了timeout时间，这里，我们从AbstractPlainSocketImpl中查看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.AbstractPlainSocketImpl#setOption</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOption</span><span class="params">(<span class="keyword">int</span> opt, Object val)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isClosedOrPending()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket Closed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="comment">/* check type safety b4 going native.  These should never</span></span><br><span class="line"><span class="comment">            * fail, since only java.Socket* has access to</span></span><br><span class="line"><span class="comment">            * PlainSocketImpl.setOption().</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">    <span class="keyword">case</span> SO_LINGER:</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span> || (!(val <span class="keyword">instanceof</span> Integer) &amp;&amp; !(val <span class="keyword">instanceof</span> Boolean)))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Bad parameter for option"</span>);</span><br><span class="line">        <span class="keyword">if</span> (val <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">            <span class="comment">/* true only if disabling - enabling should be Integer */</span></span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SO_TIMEOUT: <span class="comment">//&lt;1&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span> || (!(val <span class="keyword">instanceof</span> Integer)))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Bad parameter for SO_TIMEOUT"</span>);</span><br><span class="line">        <span class="keyword">int</span> tmp = ((Integer) val).intValue();</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout &lt; 0"</span>);</span><br><span class="line">        timeout = tmp;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IP_TOS:</span><br><span class="line">            <span class="keyword">if</span> (val == <span class="keyword">null</span> || !(val <span class="keyword">instanceof</span> Integer)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"bad argument for IP_TOS"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            trafficClass = ((Integer)val).intValue();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SO_BINDADDR:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Cannot re-bind socket"</span>);</span><br><span class="line">    <span class="keyword">case</span> TCP_NODELAY:</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span> || !(val <span class="keyword">instanceof</span> Boolean))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"bad parameter for TCP_NODELAY"</span>);</span><br><span class="line">        on = ((Boolean)val).booleanValue();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SO_SNDBUF:</span><br><span class="line">    <span class="keyword">case</span> SO_RCVBUF:</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span> || !(val <span class="keyword">instanceof</span> Integer) ||</span><br><span class="line">            !(((Integer)val).intValue() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"bad parameter for SO_SNDBUF "</span> +</span><br><span class="line">                                        <span class="string">"or SO_RCVBUF"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SO_KEEPALIVE:</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span> || !(val <span class="keyword">instanceof</span> Boolean))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"bad parameter for SO_KEEPALIVE"</span>);</span><br><span class="line">        on = ((Boolean)val).booleanValue();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SO_OOBINLINE:</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span> || !(val <span class="keyword">instanceof</span> Boolean))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"bad parameter for SO_OOBINLINE"</span>);</span><br><span class="line">        on = ((Boolean)val).booleanValue();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SO_REUSEADDR:</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span> || !(val <span class="keyword">instanceof</span> Boolean))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"bad parameter for SO_REUSEADDR"</span>);</span><br><span class="line">        on = ((Boolean)val).booleanValue();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SO_REUSEPORT:</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span> || !(val <span class="keyword">instanceof</span> Boolean))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"bad parameter for SO_REUSEPORT"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"unsupported option"</span>);</span><br><span class="line">        on = ((Boolean)val).booleanValue();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"unrecognized TCP option: "</span> + opt);</span><br><span class="line">    &#125;</span><br><span class="line">    socketSetOption(opt, on, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法比较长，我们仅看与<code>timeout</code>有关的代码，即<1>处的代码。其实这里仅仅就是将我们setOption里面传入的timeout值设置到了AbstractPlainSocketImpl的全局变量timeout里而已。</1></p><p>这样，我们就可以在程序级别将accept方法设置成为非阻塞式的了，但是read方法现在还是阻塞式的，即后面我们还需要改造read方法，同样将它在程序级别上变成非阻塞式。</p><h2 id="通过Demo改造来进行accept的非阻塞实现"><a href="#通过Demo改造来进行accept的非阻塞实现" class="headerlink" title="通过Demo改造来进行accept的非阻塞实现"></a>通过Demo改造来进行accept的非阻塞实现</h2><p>在正式改造前，我们有必要来解释下Socket下同步/异步和阻塞/非阻塞:</p><p>   同步/异步是属于操作系统级别的，指的是操作系统在收到程序请求的IO之后，如果IO资源没有准备好的话，该如何响应程序的问题，同步的话就是不响应，直到IO资源准备好；而异步的话则会返回给程序一个标志，这个标志用于当IO资源准备好后通过事件机制发送的内容应该发到什么地方。</p><p>   阻塞/非阻塞是属于程序级别的，指的是程序在请求操作系统进行IO操作时，如果IO资源没有准备好的话，程序该怎么处理的问题，阻塞的话就是程序什么都不做，一直等到IO资源准备好，非阻塞的话程序则继续运行，但是会时不时的去查看下IO到底准备好没有呢；</p><p>   我们通常见到的BIO是同步阻塞式的，同步的话说明操作系统底层是一直等待IO资源准备直到ok的，阻塞的话是程序本身也在一直等待IO资源准备直到ok，具体来讲程序级别的阻塞就是accept和read造成的，我们可以通过改造将其变成非阻塞式，但是操作系统层次的阻塞我们没法改变。</p><p>   我们的NIO是同步非阻塞式的，其实它的非阻塞实现原理和我们上面的讲解差不多的，就是为了改善accept和read方法带来的阻塞现象，所以引入了<code>Channel</code>和<code>Buffer</code>的概念。</p><p>好了，我们对我们的Demo进行改进，解决accept带来的阻塞问题(为多个客户端连接做的异步处理，这里就不多解释了，读者可自行思考，实在不行可到本人相关视频中找到对应解读)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOProNotB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBIOServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;<span class="comment">//服务端Socket</span></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;<span class="comment">//客户端socket</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        ClientSocketThread thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            serverSocket.setSoTimeout(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(stringNowTime() + <span class="string">": serverSocket started"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket = serverSocket.accept();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">//运行到这里表示本次accept是没有收到任何数据的，服务端的主线程在这里可以做一些其他事情</span></span><br><span class="line">                    System.out.println(<span class="string">"now time is: "</span> + stringNowTime());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(stringNowTime() + <span class="string">": id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket connected"</span>);</span><br><span class="line">                thread = <span class="keyword">new</span> ClientSocketThread(socket);</span><br><span class="line">                threadPool.execute(thread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringNowTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss:SSS"</span>);</span><br><span class="line">        <span class="keyword">return</span> format.format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClientSocketThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientSocketThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            String inputContent;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> ((inputContent = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到id为"</span> + socket.hashCode() + <span class="string">"  "</span> + inputContent);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket "</span> + stringNowTime() + <span class="string">"读取结束"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BIOProNotB server = <span class="keyword">new</span> BIOProNotB();</span><br><span class="line">        server.initBIOServer(<span class="number">8888</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为我们的ServerSocket设置了timeout时间，这样的话调用accept方法的时候每隔1s他就会被唤醒一次，而不再是一直在那里，只有有客户端接入才会返回信息；我们运行一下看看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2019-01-02 17:28:43:362: serverSocket started</span><br><span class="line">now time is: 2019-01-02 17:28:44:363</span><br><span class="line">now time is: 2019-01-02 17:28:45:363</span><br><span class="line">now time is: 2019-01-02 17:28:46:363</span><br><span class="line">now time is: 2019-01-02 17:28:47:363</span><br><span class="line">now time is: 2019-01-02 17:28:48:363</span><br><span class="line">now time is: 2019-01-02 17:28:49:363</span><br><span class="line">now time is: 2019-01-02 17:28:50:363</span><br><span class="line">now time is: 2019-01-02 17:28:51:364</span><br><span class="line">now time is: 2019-01-02 17:28:52:365</span><br><span class="line">now time is: 2019-01-02 17:28:53:365</span><br><span class="line">now time is: 2019-01-02 17:28:54:365</span><br><span class="line">now time is: 2019-01-02 17:28:55:365</span><br><span class="line">now time is: 2019-01-02 17:28:56:365 // &lt;1&gt;</span><br><span class="line">2019-01-02 17:28:56:911: id为1308927845的Clientsocket connected</span><br><span class="line">now time is: 2019-01-02 17:28:57:913 // &lt;2&gt;</span><br><span class="line">now time is: 2019-01-02 17:28:58:913</span><br></pre></td></tr></table></figure></p><p>可以看到，我们刚开始并没有客户端接入的时候，是会执行<code>System.out.println(&quot;now time is: &quot; + stringNowTime());</code>的输出，还有一点需要注意的就是，仔细看看上面的输出结果的标记<1>与<2>，你会发现<2>处时间值不是17:28:57:365，原因就在于如果accept正常返回值的话，是不会执行catch语句部分的。</2></2></1></p><h2 id="通过Demo改造来进行read的非阻塞实现"><a href="#通过Demo改造来进行read的非阻塞实现" class="headerlink" title="通过Demo改造来进行read的非阻塞实现"></a>通过Demo改造来进行read的非阻塞实现</h2><p>   这样的话，我们就把accept部分改造成了非阻塞式了，那么read部分可以改造么？当然可以，改造方法和accept很类似，我们在read的时候，会调用<br><code>java.net.AbstractPlainSocketImpl#getInputStream</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Gets an InputStream for this socket.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (fdLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isClosedOrPending())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Socket Closed"</span>);</span><br><span class="line">    <span class="keyword">if</span> (shut_rd)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Socket input is shutdown"</span>);</span><br><span class="line">    <span class="keyword">if</span> (socketInputStream == <span class="keyword">null</span>)</span><br><span class="line">        socketInputStream = <span class="keyword">new</span> SocketInputStream(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> socketInputStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里面创建了一个<code>SocketInputStream</code>对象，会将当前<code>AbstractPlainSocketImpl</code>对象传进去，于是，在读数据的时候，我们会调用如下方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read(b, off, length, impl.getTimeout());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> length, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EOF already encountered</span></span><br><span class="line">    <span class="keyword">if</span> (eof) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connection reset</span></span><br><span class="line">    <span class="keyword">if</span> (impl.isConnectionReset()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Connection reset"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bounds check</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">0</span> || off &lt; <span class="number">0</span> || length &gt; b.length - off) &#123;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"length == "</span> + length</span><br><span class="line">                + <span class="string">" off == "</span> + off + <span class="string">" buffer length == "</span> + b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// acquire file descriptor and do the read</span></span><br><span class="line">    FileDescriptor fd = impl.acquireFD();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        n = socketRead(fd, b, off, length, timeout);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectionResetException rstExc) &#123;</span><br><span class="line">        impl.setConnectionReset();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        impl.releaseFD();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If we get here we are at EOF, the socket has been closed,</span></span><br><span class="line"><span class="comment">        * or the connection has been reset.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">if</span> (impl.isClosedOrPending()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket closed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (impl.isConnectionReset()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Connection reset"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    eof = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">socketRead</span><span class="params">(FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> socketRead0(fd, b, off, len, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，我们看到了socketRead同样设定了timeout，而且这个timeout就是我们创建这个<code>SocketInputStream</code>对象时传入的<code>AbstractPlainSocketImpl</code>对象来控制的，所以，我们只需要设定<code>serverSocket.setSoTimeout(1000)</code>即可。<br>我们再次修改服务端代码(代码总共两次设定，第一次是设定的是ServerSocket级别的，第二次设定的客户端连接返回的那个Socket，两者不一样)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOProNotBR</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBIOServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;<span class="comment">//服务端Socket</span></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;<span class="comment">//客户端socket</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        ClientSocketThread thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            serverSocket.setSoTimeout(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(stringNowTime() + <span class="string">": serverSocket started"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket = serverSocket.accept();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">//运行到这里表示本次accept是没有收到任何数据的，服务端的主线程在这里可以做一些其他事情</span></span><br><span class="line">                    System.out.println(<span class="string">"now time is: "</span> + stringNowTime());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(stringNowTime() + <span class="string">": id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket connected"</span>);</span><br><span class="line">                thread = <span class="keyword">new</span> ClientSocketThread(socket);</span><br><span class="line">                threadPool.execute(thread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringNowTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss:SSS"</span>);</span><br><span class="line">        <span class="keyword">return</span> format.format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClientSocketThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientSocketThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            String inputContent;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.setSoTimeout(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> ((inputContent = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"收到id为"</span> + socket.hashCode() + <span class="string">"  "</span> + inputContent);</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">//执行到这里表示read方法没有获取到任何数据，线程可以执行一些其他的操作</span></span><br><span class="line">                        System.out.println(<span class="string">"Not read data: "</span> + stringNowTime());</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//执行到这里表示读取到了数据，我们可以在这里进行回复客户端的工作</span></span><br><span class="line">                    System.out.println(<span class="string">"id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket "</span> + stringNowTime() + <span class="string">"读取结束"</span>);</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BIOProNotBR server = <span class="keyword">new</span> BIOProNotBR();</span><br><span class="line">        server.initBIOServer(<span class="number">8888</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">2019-01-02 17:59:03:713: serverSocket started</span><br><span class="line">now time is: 2019-01-02 17:59:04:714</span><br><span class="line">now time is: 2019-01-02 17:59:05:714</span><br><span class="line">now time is: 2019-01-02 17:59:06:714</span><br><span class="line">2019-01-02 17:59:06:932: id为1810132623的Clientsocket connected</span><br><span class="line">now time is: 2019-01-02 17:59:07:934</span><br><span class="line">Not read data: 2019-01-02 17:59:07:935</span><br><span class="line">now time is: 2019-01-02 17:59:08:934</span><br><span class="line">Not read data: 2019-01-02 17:59:08:935</span><br><span class="line">now time is: 2019-01-02 17:59:09:935</span><br><span class="line">Not read data: 2019-01-02 17:59:09:936</span><br><span class="line">收到id为1810132623  2019-01-02 17:59:09: 第0条消息: ccc // &lt;1&gt;</span><br><span class="line">now time is: 2019-01-02 17:59:10:935</span><br><span class="line">Not read data: 2019-01-02 17:59:10:981 // &lt;2&gt;</span><br><span class="line">收到id为1810132623  2019-01-02 17:59:11: 第1条消息: bbb</span><br><span class="line">now time is: 2019-01-02 17:59:11:935</span><br><span class="line">Not read data: 2019-01-02 17:59:12:470</span><br><span class="line">now time is: 2019-01-02 17:59:12:935</span><br><span class="line">id为1810132623的Clientsocket 2019-01-02 17:59:13:191读取结束</span><br><span class="line">now time is: 2019-01-02 17:59:13:935</span><br><span class="line">id为1810132623的Clientsocket 2019-01-02 17:59:14:192读取结束</span><br></pre></td></tr></table></figure></p><p> 其中，Not read data输出部分解决了我们的read阻塞问题，每隔1s会去唤醒我们的read操作，如果在1s内没有读到数据的话就会执行<code>System.out.println(&quot;Not read data: &quot; + stringNowTime())</code>，在这里我们就可以进行一些其他操作了，避免了阻塞中当前线程的现象，当我们有数据发送之后，就有了<1>处的输出了，因为read得到输出，所以不再执行catch语句部分，因此你会发现<2>处输出时间是和<1>处的时间相差1s而不是和之前的17:59:09:936相差一秒；</1></2></1></p><p>   这样的话，我们就解决了accept以及read带来的阻塞问题了，同时在服务端为每一个客户端都创建了一个线程来处理各自的业务逻辑，这点其实基本上已经解决了阻塞问题了，我们可以理解成是最初版的NIO，但是，为每个客户端都创建一个线程这点确实让人头疼的，特别是客户端多了的话，很浪费服务器资源，再加上线程之间的切换开销，更是雪上加霜，即使你引入了线程池技术来控制线程的个数，但是当客户端多起来的时候会导致线程池的BlockingQueue队列越来越大，那么，这时候的NIO就可以为我们解决这个问题，它并不会为每个客户端都创建一个线程，在服务端只有一个线程，会为每个客户端创建一个通道。</p><h2 id="对accept-一些代码注意点的思考"><a href="#对accept-一些代码注意点的思考" class="headerlink" title="对accept()一些代码注意点的思考"></a>对accept()一些代码注意点的思考</h2><p>accept()本地方法，我们可以来试着看一看Linux这块的相关解读：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">struct</span> sockaddr *addr,<span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p><p>accept()系统调用主要用在基于连接的套接字类型，比如SOCK_STREAM和SOCK_SEQPACKET。它提取出所监听套接字的等待连接队列中第一个连接请求，<strong>创建一个新的套接字</strong>，并返回指向该套接字的文件描述符。新建立的套接字不在监听状态，原来所监听的套接字也不受该系统调用的影响。</p><p><strong>备注：新建立的套接字准备发送send()和接收数据recv()。</strong></p><p>参数：</p><p>sockfd,    利用系统调用socket()建立的套接字描述符，通过bind()绑定到一个本地地址(一般为服务器的套接字)，并且通过listen()一直在监听连接；</p><p>addr,    指向struct sockaddr的指针，该结构用通讯层服务器对等套接字的地址(一般为客户端地址)填写，返回地址addr的确切格式由套接字的地址类别(比如TCP或UDP)决定；若addr为NULL，没有有效地址填写，这种情况下，addrlen也不使用，应该置为NULL；</p><p><strong>备注：addr是个指向局部数据结构sockaddr_in的指针，这就是要求接入的信息本地的套接字(地址和指针)。</strong></p><p>addrlen,    一个值结果参数，调用函数必须初始化为包含addr所指向结构大小的数值，函数返回时包含对等地址(一般为服务器地址)的实际数值；</p><p><strong>备注：addrlen是个局部整形变量，设置为sizeof(struct   sockaddr_in)。</strong></p><p>如果队列中没有等待的连接，套接字也没有被标记为Non-blocking，accept()会阻塞调用函数直到连接出现；如果套接字被标记为Non-blocking，队列中也没有等待的连接，accept()返回错误EAGAIN或EWOULDBLOCK。</p><p><strong>备注：一般来说，实现时accept()为阻塞函数，当监听socket调用accept()时，它先到自己的receive_buf中查看是否有连接数据包；若有，把数据拷贝出来，删掉接收到的数据包，创建新的socket与客户发来的地址建立连接；若没有，就阻塞等待；</strong></p><p>为了在套接字中有到来的连接时得到通知，可以使用<strong>select()</strong>或<strong>poll()</strong>。当尝试建立新连接时，系统发送一个可读事件，然后调用accept()为该连接获取套接字。另一种方法是，当套接字中有连接到来时设定套接字发送SIGIO信号。</p><p>返回值<br>成功时，返回非负整数，该整数是接收到套接字的描述符；出错时，返回－1，相应地设定全局变量errno。</p><p>所以，我们在我们的Java部分的源码里(<strong>java.net.ServerSocket#accept</strong>)会new 一个Socket出来，方便连接后拿到的新Socket的文件描述符的信息给设定到我们new出来的这个Socket上来，这点在<code>java.net.PlainSocketImpl#socketAccept</code>中看到的尤为明显，读者可以回顾相关源码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BIO到NIO源码的一些事儿之BIO&quot;&gt;&lt;a href=&quot;#BIO到NIO源码的一些事儿之BIO&quot; class=&quot;headerlink&quot; title=&quot;BIO到NIO源码的一些事儿之BIO&quot;&gt;&lt;/a&gt;BIO到NIO源码的一些事儿之BIO&lt;/h1&gt;&lt;p&gt;此篇文章会详细解读由BIO到NIO的逐步演进的心灵路程，为Reactor-Netty 库的讲解铺平道路。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;Java编程方法论-Reactor与Webflux&lt;/code&gt;的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:&lt;/p&gt;
&lt;p&gt;Rxjava源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av34537840&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av34537840&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Reactor源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av35326911&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av35326911&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="响应式" scheme="https://muyinchen.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
      <category term="Reactor Rxjava" scheme="https://muyinchen.github.io/tags/Reactor-Rxjava/"/>
    
  </entry>
  
  <entry>
    <title>tomcat从启动到接轨Servlet二三事</title>
    <link href="https://muyinchen.github.io/2018/12/26/tomcat%E4%BB%8E%E5%90%AF%E5%8A%A8%E5%88%B0%E6%8E%A5%E8%BD%A8Servlet%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>https://muyinchen.github.io/2018/12/26/tomcat从启动到接轨Servlet二三事/</id>
    <published>2018-12-26T15:40:25.000Z</published>
    <updated>2018-12-28T09:47:32.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat从启动到接轨Servlet二三事"><a href="#tomcat从启动到接轨Servlet二三事" class="headerlink" title="tomcat从启动到接轨Servlet二三事"></a>tomcat从启动到接轨Servlet二三事</h1><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>也是因为之前自己的不谨慎，在写<code>Java编程方法论-Reactor与Webflux</code>的时候，因觉得tomcat关于connector部分已经有不错的博文了，草草参考了下，并没有对源码进行深入分析，导致自己在录制分享视频的时候，发现自己文章内容展现的和源码并不一致，又通过搜索引擎搜索了一些中文博客的文章，并不尽如人意，索性，自己的就通过最新的源码来重新梳理一下关于tomcat connector部分内容，也是给自己一个警醒，凡事务必仔细仔细再仔细！<br>参考源码地址: <a href="https://github.com/apache/tomcat" target="_blank" rel="noopener">https://github.com/apache/tomcat</a></p><p>关于<code>Java编程方法论-Reactor与Webflux</code>的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:</p><p>Rxjava源码解读与分享：<a href="https://www.bilibili.com/video/av34537840" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840</a></p><p>Reactor源码解读与分享：<a href="https://www.bilibili.com/video/av35326911" target="_blank" rel="noopener">https://www.bilibili.com/video/av35326911</a></p><a id="more"></a><h2 id="Tomcat的启动过程详解"><a href="#Tomcat的启动过程详解" class="headerlink" title="Tomcat的启动过程详解"></a>Tomcat的启动过程详解</h2><p>###　启动与结束Tomcat基本操作<br>在Linux系统下，启动和关闭Tomcat使用命令操作。</p><p>进入Tomcat下的bin目录:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /java/tomcat/bin</span><br></pre></td></tr></table></figure></p><p>启动Tomcat命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./startup.sh</span><br></pre></td></tr></table></figure><p>停止Tomcat服务命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure><p>执行tomcat 的<code>./shutdown.sh</code>后，虽然tomcat服务不能正常访问了，但是<code>ps -ef | grep tomcat</code> 后，发现<code>tomcat</code>对应的<code>java</code>进程未随web容器关闭而销毁，进而存在僵尸<code>java</code>进程。网上看了下导致僵尸进程的原因可能是有非守护线程（即User Thread）存在，jvm不会退出（当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出）。通过一下命令查看Tomcat进程是否结束：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep tomcat</span><br></pre></td></tr></table></figure><p>如果存在用户线程，给kill掉就好了即使用<code>kill -9 pid</code></p><h3 id="启动过程Bootstrap详解"><a href="#启动过程Bootstrap详解" class="headerlink" title="启动过程Bootstrap详解"></a>启动过程Bootstrap详解</h3><p>我们接着从<code>startup.sh</code>这个shell脚本中可以发现，其最终调用了<code>catalina.sh start</code>，于是，我们找到<code>catalina.sh</code>里，在<code>elif [ &quot;$1&quot; = &quot;start&quot; ] ;</code>处，我们往下走，可以发现，其调用了<code>org.apache.catalina.startup.Bootstrap.java</code>这个类下的<code>start()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.apache.catalina.startup.Bootstrap</span></span><br><span class="line"><span class="comment">* Start the Catalina daemon.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception Fatal start error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( catalinaDaemon==<span class="keyword">null</span> ) init();</span><br><span class="line"></span><br><span class="line">    Method method = catalinaDaemon.getClass().getMethod(<span class="string">"start"</span>, (Class [] )<span class="keyword">null</span>);</span><br><span class="line">    method.invoke(catalinaDaemon, (Object [])<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，在服务器第一次启动的时候，会调用其<code>init()</code>，其主要用于创建<code>org.apache.catalina.startup.Catalina.java</code>的类实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.apache.catalina.startup.Bootstrap</span></span><br><span class="line"><span class="comment">* Initialize daemon.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception Fatal initialization error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    initClassLoaders();</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line"></span><br><span class="line">    SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load our startup class and call its process() method</span></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">"Loading startup class"</span>);</span><br><span class="line">    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">"org.apache.catalina.startup.Catalina"</span>);</span><br><span class="line">    Object startupInstance = startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the shared extensions class loader</span></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">"Setting startup class properties"</span>);</span><br><span class="line">    String methodName = <span class="string">"setParentClassLoader"</span>;</span><br><span class="line">    Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">    paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">"java.lang.ClassLoader"</span>);</span><br><span class="line">    Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">    paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">    Method method =</span><br><span class="line">        startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">    method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">    catalinaDaemon = startupInstance;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="启动过程Catalina详解"><a href="#启动过程Catalina详解" class="headerlink" title="启动过程Catalina详解"></a>启动过程Catalina详解</h3><h4 id="Catalina中start解读"><a href="#Catalina中start解读" class="headerlink" title="Catalina中start解读"></a>Catalina中start解读</h4><p>接着，在Bootstrap的start()方法中会调用Catalina实例的start方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.apache.catalina.startup.Catalina</span></span><br><span class="line"><span class="comment">* Start a new server instance.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">"catalina.noServer"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">"catalina.serverStartFail"</span>), e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getServer().destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e1) &#123;</span><br><span class="line">            log.debug(<span class="string">"destroy() failed for failed Server "</span>, e1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(sm.getString(<span class="string">"catalina.startup"</span>, Long.valueOf((t2 - t1) / <span class="number">1000000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register shutdown hook</span></span><br><span class="line">    <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">            shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If JULI is being used, disable JULI's shutdown hook since</span></span><br><span class="line">        <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">        <span class="comment">// if JULI's hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">        LogManager logManager = LogManager.getLogManager();</span><br><span class="line">        <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">            ((ClassLoaderLogManager) logManager).setUseShutdownHook(</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (await) &#123;</span><br><span class="line">        await();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里面，我们主要关心<code>load()</code>，<code>getServer().start()</code>，对于后者，在它的前后我们看到有启动时间的计算，这也是平时我们在启动tomcat过程中所看到的日志打印输出所在，后面的我这里就不提了。</p><h4 id="Catalina中load-解读"><a href="#Catalina中load-解读" class="headerlink" title="Catalina中load()解读"></a>Catalina中load()解读</h4><p>首先我们来看load()，这里，其会通过<code>createStartDigester()</code>创建并配置我们将用来启动的Digester，然后获取我们所配置的ServerXml文件，依次对里面属性进行配置，最后调用<code>getServer().init()</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.apache.catalina.startup.Catalina</span></span><br><span class="line"><span class="comment">* Start a new server instance.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    initDirs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before digester - it may be needed</span></span><br><span class="line">    initNaming();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set configuration source</span></span><br><span class="line">    ConfigFileLoader.setSource(<span class="keyword">new</span> CatalinaBaseConfigurationSource(Bootstrap.getCatalinaBaseFile(), getConfigFile()));</span><br><span class="line">    File file = configFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and execute our Digester</span></span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (ConfigurationSource.Resource resource = ConfigFileLoader.getSource().getServerXml()) &#123;</span><br><span class="line">        InputStream inputStream = resource.getInputStream();</span><br><span class="line">        InputSource inputSource = <span class="keyword">new</span> InputSource(resource.getURI().toURL().toString());</span><br><span class="line">        inputSource.setByteStream(inputStream);</span><br><span class="line">        digester.push(<span class="keyword">this</span>);</span><br><span class="line">        digester.parse(inputSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span>  (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(sm.getString(<span class="string">"catalina.configFail"</span>, getConfigFile() + <span class="string">"] or [server-embed.xml"</span>), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(sm.getString(<span class="string">"catalina.configFail"</span>, file.getAbsolutePath()), e);</span><br><span class="line">            <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">                log.warn(sm.getString(<span class="string">"catalina.incorrectPermissions"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stream redirection</span></span><br><span class="line">    initStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"catalina.initError"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(sm.getString(<span class="string">"catalina.init"</span>, Long.valueOf((t2 - t1) / <span class="number">1000000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，这个server从哪里来，我们从<code>digester.addObjectCreate(&quot;Server&quot;, &quot;org.apache.catalina.core.StandardServer&quot;, &quot;className&quot;);</code>中可以知道，其使用了这个类的实例，我们再回到<code>digester.push(this); digester.parse(inputSource);</code>这两句代码上来，可知，未开始解析时先调用Digester.push(this)，此时栈顶元素是Catalina，这个用来为catalina设置server，这里，要对<code>digester</code>的解析来涉及下:</p><p>如解析到<code>&lt;Server&gt;</code>时就会创建<code>StandardServer</code>类的实例并反射调用<code>Digester</code>的<code>stack</code>栈顶对象的<code>setter</code>方法(调用的方法通过传入的<code>name</code>值确定)。<br><code>digester</code>中涉及的<code>IntrospectionUtils.setProperty(top, name, value)</code>方法，即<code>top</code>为栈顶对象，<code>name</code>为这个栈顶对象要设置的属性名，<code>value</code>为要设置的属性值。<br>刚开始时栈顶元素是<code>Catalina</code>，即调用<code>Catalina.setServer(Server object)</code>方法设置<code>Server</code>为后面调用<code>Server.start()</code>做准备，然后将<code>StandardServer</code>对象实例放入<code>Digester</code>的<code>stack</code>对象栈中。</p><h5 id="getServer-init"><a href="#getServer-init" class="headerlink" title="getServer().init()"></a>getServer().init()</h5><p>接下来，我们来看<code>getServer().init()</code>，由上知，我们去找<code>org.apache.catalina.core.StandardServer.java</code>这个类，其继承<code>LifecycleMBeanBase</code>并实现了<code>Server</code>，通过<code>LifecycleMBeanBase</code>此类，说明这个<code>StandardServer</code>管理的生命周期，即通过<code>LifecycleMBeanBase</code>父类<code>LifecycleBase</code>实现的<code>init()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.util.LifecycleBase.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        initInternal();</span><br><span class="line">        setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleSubClassException(t, <span class="string">"lifecycleBase.initFail"</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>于是，我们关注 <code>initInternal()</code>在<code>StandardServer</code>中的实现，代码过多，这里就把过程讲下:<br>1、调用父类org.apache.catalina.util.LifecycleMBeanBase#initInternal方法，注册MBean</p><p>2、注册本类的其它属性的MBean</p><p>3、NamingResources初始化 : globalNamingResources.init();</p><p>4、从common ClassLoader开始往上查看，直到SystemClassLoader，遍历各个classLoader对应的查看路径，找到jar结尾的文件，读取Manifest信息，加入到ExtensionValidator#containerManifestResources属性中。</p><p>5、初始化service，默认实现是StandardService。</p><p>　　 i) 调用super.initInternal()方法</p><p>   ii) container初始化，这里container实例是StandardEngine。<br>​<br>   iii) Executor初始化<br>​<br>   iv)Connector初始化:<br>​<br>​      a）org.apache.catalina.connector.Connector   Connector[HTTP/1.1-8080]<br>​<br>​      b) org.apache.catalina.connector.Connector   Connector[AJP/1.3-8009]</p><h4 id="Catalina中start里的getServer-start-解读"><a href="#Catalina中start里的getServer-start-解读" class="headerlink" title="Catalina中start里的getServer().start()解读"></a>Catalina中start里的getServer().start()解读</h4><p>这里，我们可以看到<code>StandardServer</code>的父类<code>org.apache.catalina.util.LifecycleBase.java</code>的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||</span><br><span class="line">            LifecycleState.STARTED.equals(state)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> LifecycleException();</span><br><span class="line">            log.debug(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">        stop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;</span><br><span class="line">            !state.equals(LifecycleState.STOPPED)) &#123;</span><br><span class="line">        invalidTransition(Lifecycle.BEFORE_START_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setStateInternal(LifecycleState.STARTING_PREP, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        startInternal();</span><br><span class="line">        <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">            <span class="comment">// This is a 'controlled' failure. The component put itself into the</span></span><br><span class="line">            <span class="comment">// FAILED state so call stop() to complete the clean-up.</span></span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.STARTING)) &#123;</span><br><span class="line">            <span class="comment">// Shouldn't be necessary but acts as a check that sub-classes are</span></span><br><span class="line">            <span class="comment">// doing what they are supposed to.</span></span><br><span class="line">            invalidTransition(Lifecycle.AFTER_START_EVENT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setStateInternal(LifecycleState.STARTED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// This is an 'uncontrolled' failure so put the component into the</span></span><br><span class="line">        <span class="comment">// FAILED state and throw an exception.</span></span><br><span class="line">        handleSubClassException(t, <span class="string">"lifecycleBase.startFail"</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于<code>StandardServer</code>，我们关注的是其对于<code>startInternal();</code>的实现，源码不贴了，具体过程如下:<br>1、触发CONFIGURE_START_EVENT事件。</p><p>2、设置本对象状态为STARTING</p><p>3、NameingResource启动:globalNamingResources.start();<br>4、StandardService启动。</p><p>　　 i)  设置状态为STARTING</p><p>   ii)  container启动，即StandardEngine启动<br>​<br>   iii)  Executor 启动<br>​<br>   iv) Connector启动:<br>​<br>​       a）org.apache.catalina.connector.Connector   Connector[HTTP/1.1-8080]<br>​<br>​       b) org.apache.catalina.connector.Connector   Connector[AJP/1.3-8009]</p><p>终于，我们探究到了我要讲的主角<code>Connector</code>。</p><h2 id="Connector解读"><a href="#Connector解读" class="headerlink" title="Connector解读"></a>Connector解读</h2><h3 id="Connector构造器"><a href="#Connector构造器" class="headerlink" title="Connector构造器"></a>Connector构造器</h3><p>我们由<code>apache-tomcat-9.0.14\conf</code>目录(此处请自行下载相应版本的tomcat)下的server.xml中的<code>Connector</code>配置可知，其默认8080端口的配置协议为<code>HTTP/1.1</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>知道了这些，我们去看它的代码中的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> aprConnector = AprLifecycleListener.isAprAvailable() &amp;&amp;</span><br><span class="line">            AprLifecycleListener.getUseAprConnector();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"HTTP/1.1"</span>.equals(protocol) || protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aprConnector) &#123;</span><br><span class="line">            protocolHandlerClassName = <span class="string">"org.apache.coyote.http11.Http11AprProtocol"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            protocolHandlerClassName = <span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"AJP/1.3"</span>.equals(protocol)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aprConnector) &#123;</span><br><span class="line">            protocolHandlerClassName = <span class="string">"org.apache.coyote.ajp.AjpAprProtocol"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            protocolHandlerClassName = <span class="string">"org.apache.coyote.ajp.AjpNioProtocol"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        protocolHandlerClassName = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate protocol handler</span></span><br><span class="line">    ProtocolHandler p = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(protocolHandlerClassName);</span><br><span class="line">        p = (ProtocolHandler) clazz.getConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(sm.getString(</span><br><span class="line">                <span class="string">"coyoteConnector.protocolHandlerInstantiationFailed"</span>), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.protocolHandler = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default for Connector depends on this system property</span></span><br><span class="line">    setThrowOnFailure(Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于tomcat8.5以上，其默认就是<code>Http11NioProtocol</code>协议，这里，我们给其设定了<code>HTTP/1.1</code>，但根据上面的if语句的判断，是相等的，也就是最后还是选择的<code>Http11NioProtocol</code>。</p><h3 id="Connector初始化与启动"><a href="#Connector初始化与启动" class="headerlink" title="Connector初始化与启动"></a>Connector初始化与启动</h3><p>同样，由上一节可知，我们会涉及到Connector初始化，也就是其也会继承<code>LifecycleMBeanBase</code>，那么，我们来看其相关<code>initInternal()</code>实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"coyoteConnector.protocolHandlerInstantiationFailed"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize adapter</span></span><br><span class="line">    adapter = <span class="keyword">new</span> CoyoteAdapter(<span class="keyword">this</span>);</span><br><span class="line">    protocolHandler.setAdapter(adapter);</span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        protocolHandler.setUtilityExecutor(service.getServer().getUtilityExecutor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == parseBodyMethodsSet) &#123;</span><br><span class="line">        setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">"coyoteConnector.protocolHandlerNoApr"</span>,</span><br><span class="line">                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable() &amp;&amp; AprLifecycleListener.getUseOpenSSL() &amp;&amp;</span><br><span class="line">            protocolHandler <span class="keyword">instanceof</span> AbstractHttp11JsseProtocol) &#123;</span><br><span class="line">        AbstractHttp11JsseProtocol&lt;?&gt; jsseProtocolHandler =</span><br><span class="line">                (AbstractHttp11JsseProtocol&lt;?&gt;) protocolHandler;</span><br><span class="line">        <span class="keyword">if</span> (jsseProtocolHandler.isSSLEnabled() &amp;&amp;</span><br><span class="line">                jsseProtocolHandler.getSslImplementationName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// OpenSSL is compatible with the JSSE configuration, so use it if APR is available</span></span><br><span class="line">            jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation.class.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        protocolHandler.init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"coyoteConnector.protocolHandlerInitializationFailed"</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里涉及的过程如下：<br>1、注册MBean</p><p>2、CoyoteAdapter实例化，CoyoteAdapter是请求的入口。当有请求时，CoyoteAdapter对状态进行了处理，结尾处对请求进行回收，中间过程交由pipeline来处理。</p><p>3、protocolHandler 初始化（org.apache.coyote.http11.Http11Protocol）</p><p>  在这一步中，完成了endpoint的初始化</p><p>关于启动就不说了，其设定本对象状态为STARTING，同时调用<code>protocolHandler.start();</code>，接下来，就要进入我们的核心节奏了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate settings before starting</span></span><br><span class="line">    <span class="keyword">if</span> (getPortWithOffset() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(</span><br><span class="line">                <span class="string">"coyoteConnector.invalidPort"</span>, Integer.valueOf(getPortWithOffset())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        protocolHandler.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"coyoteConnector.protocolHandlerStartFailed"</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Protocol的相关解读"><a href="#Protocol的相关解读" class="headerlink" title="Protocol的相关解读"></a>Protocol的相关解读</h3><p>这里，我们直接从其抽象实现<code>org.apache.coyote.AbstractProtocol.java</code>来看，其也是遵循生命周期的，所以其也要继承<code>LifecycleMBeanBase</code>并实现自己的<code>init()</code>与<code>start()</code>等生命周期方法，其内部都是由相应的自实现的<code>endpoint</code>来执行具体逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.coyote.AbstractProtocol.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">        getLog().info(sm.getString(<span class="string">"abstractProtocolHandler.init"</span>, getName()));</span><br><span class="line">        logPortOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oname == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Component not pre-registered so register it</span></span><br><span class="line">        oname = createObjectName();</span><br><span class="line">        <span class="keyword">if</span> (oname != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rgOname = <span class="keyword">new</span> ObjectName(domain + <span class="string">":type=GlobalRequestProcessor,name="</span> + getName());</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(</span><br><span class="line">                getHandler().getGlobal(), rgOname, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String endpointName = getName();</span><br><span class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line"></span><br><span class="line">    endpoint.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">        getLog().info(sm.getString(<span class="string">"abstractProtocolHandler.start"</span>, getName()));</span><br><span class="line">        logPortOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    endpoint.start();</span><br><span class="line">    monitorFuture = getUtilityExecutor().scheduleWithFixedDelay(</span><br><span class="line">            <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isPaused()) &#123;</span><br><span class="line">                        startAsyncTimeout();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拿<code>org.apache.coyote.http11.Http11NioProtocol</code>这个类来讲，其接收的是<code>NioEndpoint</code>来进行构造器的实现，其内部的方法的具体实现也经由此<code>NioEndpoint</code>来实现其逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Http11NioProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractHttp11JsseProtocol</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Http11NioProtocol.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Http11NioProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> NioEndpoint());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Log <span class="title">getLog</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> log; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------- Pool setup --------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPollerThreadCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        ((NioEndpoint)getEndpoint()).setPollerThreadCount(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPollerThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((NioEndpoint)getEndpoint()).getPollerThreadCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSelectorTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        ((NioEndpoint)getEndpoint()).setSelectorTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSelectorTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((NioEndpoint)getEndpoint()).getSelectorTimeout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPollerThreadPriority</span><span class="params">(<span class="keyword">int</span> threadPriority)</span> </span>&#123;</span><br><span class="line">        ((NioEndpoint)getEndpoint()).setPollerThreadPriority(threadPriority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPollerThreadPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ((NioEndpoint)getEndpoint()).getPollerThreadPriority();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------------------------------------------- JMX related methods</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getNamePrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSSLEnabled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"https-"</span> + getSslImplementationShortName()+ <span class="string">"-nio"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"http-nio"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Endpoint相关解读"><a href="#Endpoint相关解读" class="headerlink" title="Endpoint相关解读"></a>Endpoint相关解读</h3><p>这里，<code>EndPoint</code>用于处理具体连接和传输数据，即用来实现网络连接和控制，它是服务器对外<code>I/O</code>操作的接入点。主要任务是管理对外的<code>socket</code>连接，同时将建立好的<code>socket</code>连接交到合适的工作线程中去。<br>里面两个主要的属性类是<code>Acceptor</code>和<code>Poller</code>、<code>SocketProcessor</code>。<br>我们以<code>NioEndpoint</code>为例，其内部请求处理具体的流程如下:</p><p><img src="https://github.com/muyinchen/woker/blob/master/mypics/NioEndpoint%20%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E5%A6%82%E5%9B%BE.png?raw=true" alt=""></p><p>结合上一节最后，我们主要还是关注其对于<code>Protocol</code>有关生命周期方法的具体实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.tomcat.util.net.AbstractEndpoint.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">        bindWithCleanup();</span><br><span class="line">        bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Register endpoint (as ThreadPool - historical name)</span></span><br><span class="line">        oname = <span class="keyword">new</span> ObjectName(domain + <span class="string">":type=ThreadPool,name=\""</span> + getName() + <span class="string">"\""</span>);</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        ObjectName socketPropertiesOname = <span class="keyword">new</span> ObjectName(domain +</span><br><span class="line">                <span class="string">":type=ThreadPool,name=\""</span> + getName() + <span class="string">"\",subType=SocketProperties"</span>);</span><br><span class="line">        socketProperties.setObjectName(socketPropertiesOname);</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(socketProperties, socketPropertiesOname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (SSLHostConfig sslHostConfig : findSslHostConfigs()) &#123;</span><br><span class="line">            registerJmx(sslHostConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindState == BindState.UNBOUND) &#123;</span><br><span class="line">        bindWithCleanup();</span><br><span class="line">        bindState = BindState.BOUND_ON_START;</span><br><span class="line">    &#125;</span><br><span class="line">    startInternal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//org.apache.tomcat.util.net.AbstractEndpoint.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindWithCleanup</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bind();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Ensure open sockets etc. are cleaned up if something goes</span></span><br><span class="line">        <span class="comment">// wrong during bind</span></span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        unbind();</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两个方法主要调用<code>bind</code>(此处可以查阅<code>bindWithCleanup()</code>的具体实现) 和<code>startlntemal</code> 方法，它们是模板方法，可以自行根据需求实现，这里，我们参考<code>NioEndpoint</code> 中的实现， <code>bind</code> 方法代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.tomcat.util.net.NioEndpoint.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    initServerSocket();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize thread count defaults for acceptor, poller</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> Doesn't seem to work that well with multiple accept threads</span></span><br><span class="line">        acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//minimum one poller thread</span></span><br><span class="line">        pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的bind 方法中首先初始化了<code>ServerSocket</code>(这个东西我们在jdk网络编程里都接触过，就不多说了，这里是封装了一个工具类，看下面实现)，然后检查了代表<code>Acceptor</code> 和<code>Poller</code> 初始化的线程数量的<code>acceptorThreadCount</code>属性和<code>pollerThreadCount</code> 属性，它们的值至少为1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Separated out to make it easier for folks that extend NioEndpoint to</span></span><br><span class="line"><span class="comment">// implement custom [server]sockets</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initServerSocket</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">        serverSock = ServerSocketChannel.open();</span><br><span class="line">        socketProperties.setProperties(serverSock.socket());</span><br><span class="line">        InetSocketAddress addr = <span class="keyword">new</span> InetSocketAddress(getAddress(), getPortWithOffset());</span><br><span class="line">        serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Retrieve the channel provided by the OS</span></span><br><span class="line">        Channel ic = System.inheritedChannel();</span><br><span class="line">        <span class="keyword">if</span> (ic <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">            serverSock = (ServerSocketChannel) ic;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (serverSock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">"endpoint.init.bind.inherited"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，<code>Acceptor</code> 用于接收请求，将接收到请求交给<code>Poller</code> 处理，它们都是启动线程来处理的。另外还进行了初始化<code>SSL</code> 等内容。<code>NioEndpoint</code> 的<code>startInternal</code> 方法代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The socket pollers.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Poller[] pollers = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Start the NIO endpoint, creating acceptor, poller threads.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">        running = <span class="keyword">true</span>;</span><br><span class="line">        paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getProcessorCache());</span><br><span class="line">        eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                        socketProperties.getEventCache());</span><br><span class="line">        nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create worker collection</span></span><br><span class="line">        <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start poller threads</span></span><br><span class="line">        pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">            Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">"-ClientPoller-"</span>+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里首先初始化了一些属性，初始化的属性中的<code>processorCache</code> 是<code>SynchronizedStack&lt;SocketProcessor&gt;</code>类型， <code>SocketProcessor</code> 是<code>NioEndpoint</code> 的一个内部类， <code>Poller</code> 接收到请求后就会交给它处理， <code>SocketProcessor</code> 又会将请求传递到<code>Handler</code>。<br>然后启动了<code>Poller</code> 和<code>Acceptor</code> 来处理请求，这里我们要注意的的是，<code>pollers</code>是一个数组，其管理了一堆<code>Runnable</code>，由前面可知，假如我们并没有对其进行设定，那就是1，也就是说，其默认情况下只是一个单线程。这个线程创建出来后就将其设定为守护线程，直到tomcat容器结束，其自然也会跟着结束。<br>这里，我们想要对其进行配置的话，可以在<code>server.xml</code>中进行相应设定:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxHeaderCount</span>=<span class="string">"64"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxParameterCount</span>=<span class="string">"64"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxHttpHeaderSize</span>=<span class="string">"8192"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">useBodyEncodingForURI</span>=<span class="string">"false"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxThreads</span>=<span class="string">"128"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">minSpareThreads</span>=<span class="string">"12"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">acceptCount</span>=<span class="string">"1024"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">connectionLinger</span>=<span class="string">"-1"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">keepAliveTimeout</span>=<span class="string">"60"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxKeepAliveRequests</span>=<span class="string">"32"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">maxConnections</span>=<span class="string">"10000"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">acceptorThreadCount</span>=<span class="string">"1"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">pollerThreadCount</span>=<span class="string">"2"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">selectorTimeout</span>=<span class="string">"1000"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">useSendfile</span>=<span class="string">"true"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">selectorPool.maxSelectors</span>=<span class="string">"128"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>启动<code>Acceptor</code>的<code>startAcceptorThreads</code> 方法在 <code>AbstractEndpoint</code> 中，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">    acceptors = <span class="keyword">new</span> ArrayList&lt;&gt;(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Acceptor&lt;U&gt; acceptor = <span class="keyword">new</span> Acceptor&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">        String threadName = getName() + <span class="string">"-Acceptor-"</span> + i;</span><br><span class="line">        acceptor.setThreadName(threadName);</span><br><span class="line">        acceptors.add(acceptor);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(acceptor, threadName);</span><br><span class="line">        t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">        t.setDaemon(getDaemon());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>getAcceptorThreadCount</code> 方法就是获取的init 方法中处理过的acceptorThreadCount属性，获取到后就会启动相应数量的Acceptor 线程来接收请求。默认同样是1，其创建线程的方式和Poller一致，就不多说了。</p><p>这里，我们再来看下webapps/docs/config/http.xml的文档说明:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">"acceptorThreadCount"</span> <span class="attr">required</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>The number of threads to be used to accept connections. Increase this</span><br><span class="line">    value on a multi CPU machine, although you would never really need more</span><br><span class="line">    than <span class="tag">&lt;<span class="name">code</span>&gt;</span>2<span class="tag">&lt;/<span class="name">code</span>&gt;</span>. Also, with a lot of non keep alive connections, you</span><br><span class="line">    might want to increase this value as well. Default value is</span><br><span class="line">    <span class="tag">&lt;<span class="name">code</span>&gt;</span>1<span class="tag">&lt;/<span class="name">code</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">attribute</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">"pollerThreadCount"</span> <span class="attr">required</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>(int)The number of threads to be used to run for the polling events.</span><br><span class="line">    Default value is <span class="tag">&lt;<span class="name">code</span>&gt;</span>1<span class="tag">&lt;/<span class="name">code</span>&gt;</span> per processor but not more than 2.<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    When accepting a socket, the operating system holds a global lock. So the benefit of</span><br><span class="line">    going above 2 threads diminishes rapidly. Having more than one thread is for</span><br><span class="line">    system that need to accept connections very rapidly. However usually just</span><br><span class="line">    increasing <span class="tag">&lt;<span class="name">code</span>&gt;</span>acceptCount<span class="tag">&lt;/<span class="name">code</span>&gt;</span> will solve that problem.</span><br><span class="line">    Increasing this value may also be beneficial when a large amount of send file</span><br><span class="line">    operations are going on.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">attribute</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>由此可知，<code>acceptorThreadCount</code>用于设定接受连接的线程数。 在多CPU机器上增加这个值，虽然你可能真的不需要超过2个。哪怕有很多非keep alive连接，你也可能想要增加这个值。 其默认值为1。<br><code>pollerThreadCount</code>用于为轮询事件运行的线程数。默认值为每个处理器1个但不要超过2个(上面的优化配置里的设定为2)。接受socket时，操作系统将保持全局锁定。 因此，超过2个线程的好处迅速减少。 当系统拥有多个该类型线程，它可以非常快速地接受连接。 尽管增加acceptCount就可以解决这个问题。但当正在进行大量发送文件操作时，增加此值也可能是有益的。</p><h3 id="Acceptor和Poller的工作方式"><a href="#Acceptor和Poller的工作方式" class="headerlink" title="Acceptor和Poller的工作方式"></a>Acceptor和Poller的工作方式</h3><p>我们先来看一张NioEndpoint处理的的时序图:</p><p><img src="https://github.com/muyinchen/woker/blob/master/mypics/NioEndpoint%E5%A4%84%E7%90%86%E7%9A%84%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png?raw=true" alt=""></p><h4 id="Acceptor工作方式"><a href="#Acceptor工作方式" class="headerlink" title="Acceptor工作方式"></a>Acceptor工作方式</h4><p>我们由前面可知，Acceptor和Poller都实现了Runnable接口，所以其主要工作流程就在其实现的run方法内，这里我们先来看Acceptor对于run方法的实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.tomcat.util.net.NioEndpoint.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SocketChannel <span class="title">serverSocketAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serverSock.accept();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//org.apache.tomcat.util.net.Acceptor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span>&lt;<span class="title">U</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Acceptor.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StringManager sm = StringManager.getManager(Acceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_ERROR_DELAY = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ERROR_DELAY = <span class="number">1600</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractEndpoint&lt;?,U&gt; endpoint;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> AcceptorState state = AcceptorState.NEW;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(AbstractEndpoint&lt;?,U&gt; endpoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.endpoint = endpoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AcceptorState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setThreadName</span><span class="params">(<span class="keyword">final</span> String threadName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> String <span class="title">getThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop until we receive a shutdown command</span></span><br><span class="line">        <span class="keyword">while</span> (endpoint.isRunning()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Loop if endpoint is paused</span></span><br><span class="line">            <span class="keyword">while</span> (endpoint.isPaused() &amp;&amp; endpoint.isRunning()) &#123;</span><br><span class="line">                state = AcceptorState.PAUSED;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!endpoint.isRunning()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            state = AcceptorState.RUNNING;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//if we have reached max connections, wait</span></span><br><span class="line">                endpoint.countUpOrAwaitConnection();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Endpoint might have been paused while waiting for latch</span></span><br><span class="line">                <span class="comment">// If that is the case, don't accept new connections</span></span><br><span class="line">                <span class="keyword">if</span> (endpoint.isPaused()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                U socket = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Accept the next incoming connection from the server</span></span><br><span class="line">                    <span class="comment">// socket</span></span><br><span class="line">                    <span class="comment">// 创建一个socketChannel，接收下一个从服务器进来的连接  </span></span><br><span class="line">                    socket = endpoint.serverSocketAccept();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ioe) &#123;</span><br><span class="line">                    <span class="comment">// We didn't get a socket</span></span><br><span class="line">                    endpoint.countDownConnection();</span><br><span class="line">                    <span class="keyword">if</span> (endpoint.isRunning()) &#123;</span><br><span class="line">                        <span class="comment">// Introduce delay if necessary</span></span><br><span class="line">                        errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">                        <span class="comment">// re-throw</span></span><br><span class="line">                        <span class="keyword">throw</span> ioe;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Successful accept, reset the error delay</span></span><br><span class="line">                errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Configure the socket</span></span><br><span class="line">                <span class="comment">// 如果EndPoint处于running状态并且没有没暂停</span></span><br><span class="line">                <span class="keyword">if</span> (endpoint.isRunning() &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line">                    <span class="comment">// setSocketOptions() will hand the socket off to</span></span><br><span class="line">                    <span class="comment">// an appropriate processor if successful</span></span><br><span class="line">                    <span class="keyword">if</span> (!endpoint.setSocketOptions(socket)) &#123;</span><br><span class="line">                        endpoint.closeSocket(socket);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    endpoint.destroySocket(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">                String msg = sm.getString(<span class="string">"endpoint.accept.fail"</span>);</span><br><span class="line">                <span class="comment">// APR specific.</span></span><br><span class="line">                <span class="comment">// Could push this down but not sure it is worth the trouble.</span></span><br><span class="line">                <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    Error e = (Error) t;</span><br><span class="line">                    <span class="keyword">if</span> (e.getError() == <span class="number">233</span>) &#123;</span><br><span class="line">                        <span class="comment">// Not an error on HP-UX so log as a warning</span></span><br><span class="line">                        <span class="comment">// so it can be filtered out on that platform</span></span><br><span class="line">                        <span class="comment">// See bug 50273</span></span><br><span class="line">                        log.warn(msg, t);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(msg, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(msg, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state = AcceptorState.ENDED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> AcceptorState &#123;</span><br><span class="line">        NEW, RUNNING, PAUSED, ENDED</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面run方法可以看到，<code>Acceptor</code>使用<code>serverSock.accept()</code>阻塞的监听端口，如果有连接进来，拿到了<code>socket</code>，并且<code>EndPoint</code>处于正常运行状态，则调用<code>NioEndPoint</code>的<code>setSocketOptions</code>方法，对于<code>setSocketOptions</code>，概括来讲就是根据<code>socket</code>构建一个<code>NioChannel</code>，然后把这个的<code>NioChannel</code>注册到<code>Poller</code>的事件列表里面，等待<code>poller</code>轮询:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.apache.tomcat.util.net.NioEndpoint.java</span></span><br><span class="line"><span class="comment">* Process the specified connection.</span></span><br><span class="line"><span class="comment">* 处理指定的连接</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> socket The socket channel</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &lt;code&gt;true&lt;/code&gt; if the socket was correctly configured</span></span><br><span class="line"><span class="comment">*  and processing may continue, &lt;code&gt;false&lt;/code&gt; if the socket needs to be</span></span><br><span class="line"><span class="comment">*  close immediately</span></span><br><span class="line"><span class="comment">* 如果socket配置正确，并且可能会继续处理，返回true </span></span><br><span class="line"><span class="comment">* 如果socket需要立即关闭，则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setSocketOptions</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Process the connection</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//disable blocking, APR style, we are gonna be polling it</span></span><br><span class="line">        socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Socket sock = socket.socket();</span><br><span class="line">        socketProperties.setProperties(sock);</span><br><span class="line">    <span class="comment">//从缓存中拿一个nioChannel  若没有，则创建一个。将socket传进去</span></span><br><span class="line">        NioChannel channel = nioChannels.pop();</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            SocketBufferHandler bufhandler = <span class="keyword">new</span> SocketBufferHandler(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="keyword">if</span> (isSSLEnabled()) &#123;</span><br><span class="line">                channel = <span class="keyword">new</span> SecureNioChannel(socket, bufhandler, selectorPool, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel = <span class="keyword">new</span> NioChannel(socket, bufhandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.setIOChannel(socket);</span><br><span class="line">            channel.reset();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//从pollers数组中获取一个Poller对象，注册这个nioChannel</span></span><br><span class="line">        getPoller0().register(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"endpoint.socketOptionsError"</span>), t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(tt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Tell to close the socket</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return an available poller in true round robin fashion.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> The next poller in sequence</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Poller <span class="title">getPoller0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = Math.abs(pollerRotater.incrementAndGet()) % pollers.length;</span><br><span class="line">    <span class="keyword">return</span> pollers[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于<code>getPoller0()</code>，默认情况下， 由前面可知，这个pollers数组里只有一个元素，这点要注意。我们来看NioEndPoint中的Poller实现的register方法，主要做的就是在Poller注册新创建的套接字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Registers a newly created socket with the poller.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> socket    The newly created socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> NioChannel socket)</span> </span>&#123;</span><br><span class="line">    socket.setPoller(<span class="keyword">this</span>);</span><br><span class="line">    NioSocketWrapper ka = <span class="keyword">new</span> NioSocketWrapper(socket, NioEndpoint.<span class="keyword">this</span>);</span><br><span class="line">    socket.setSocketWrapper(ka);</span><br><span class="line">    ka.setPoller(<span class="keyword">this</span>);</span><br><span class="line">    ka.setReadTimeout(getConnectionTimeout());</span><br><span class="line">    ka.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">    ka.setKeepAliveLeft(NioEndpoint.<span class="keyword">this</span>.getMaxKeepAliveRequests());</span><br><span class="line">    ka.setSecure(isSSLEnabled());</span><br><span class="line">    <span class="comment">//从缓存中取出一个PollerEvent对象，若没有则创建一个。将socket和NioSocketWrapper设置进去</span></span><br><span class="line">    PollerEvent r = eventCache.pop();</span><br><span class="line">    ka.interestOps(SelectionKey.OP_READ);<span class="comment">//this is what OP_REGISTER turns into.</span></span><br><span class="line">    <span class="keyword">if</span> ( r==<span class="keyword">null</span>) r = <span class="keyword">new</span> PollerEvent(socket,ka,OP_REGISTER);</span><br><span class="line">    <span class="keyword">else</span> r.reset(socket,ka,OP_REGISTER);</span><br><span class="line">    <span class="comment">//添到到该Poller的事件列表</span></span><br><span class="line">    addEvent(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上过程进行一下总结：</p><p>从Acceptor接收到请求，它做了如下工作：</p><ul><li>如果达到了最大连接数，则等待。否则，阻塞监听端口。</li><li>监听到有连接，则创建一个socketChannel。若服务正常运行，则把socket传递给适当的处理器。如果成功，会关闭socket。</li></ul><p>在这里，会调用NioEndPoint的setSocketOptions方法，处理指定的连接：</p><ul><li>将socket设置为非阻塞</li><li>从缓存中拿一个nioChannel  若没有，则创建一个。将socket传进去。</li><li>从pollers数组中获取一个Poller对象，把nioChannel注册到该Poller中。</li></ul><p>其中最后一步注册的过程，是调用Poller的register()方法：</p><ul><li>创建一个NioSocketWrapper，包装socket。然后配置相关属性，设置interestOps为SelectionKey.OP_READ</li><li>从缓存中取出一个PollerEvent对象，若没有则创建一个。初始化或者重置此Event对象，会将其interestOps设置为OP_REGISTER (Poller轮询时会用到)</li><li>将新的PollerEvent添加到这个Poller的事件列表events，等待Poller线程轮询。</li></ul><h4 id="Poller工作方式"><a href="#Poller工作方式" class="headerlink" title="Poller工作方式"></a>Poller工作方式</h4><p>由前面可知，poller也实现了Runnable接口，并在start的这部分生命周期执行的过程中创建对应工作线程并加入其中，所以，我们来通过其run方法来看下其工作机制。</p><p>其实上面已经提到了Poller将一个事件注册到事件队列的过程。接下来Poller线程要做的事情其实就是如何处理这些事件。</p><p>Poller在run方法中会轮询事件队列events，将每个PollerEvent中的SocketChannel的interestOps注册到Selector中，然后将PollerEvent从队列里移除。之后就是SocketChanel通过Selector调度来进行非阻塞的读写数据了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Poller class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Selector selector;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> SynchronizedQueue&lt;PollerEvent&gt; events =</span><br><span class="line">               <span class="keyword">new</span> SynchronizedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> nextExpiration = <span class="number">0</span>;<span class="comment">//optimize expiration handling</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> AtomicLong wakeupCounter = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> keyCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Poller</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKeyCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> keyCount; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Selector <span class="title">getSelector</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> selector;&#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The background thread that adds sockets to the Poller, checks the</span></span><br><span class="line"><span class="comment">        * poller for triggered events and hands the associated socket off to an</span></span><br><span class="line"><span class="comment">        * appropriate processor as events occur.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// Loop until destroy() is called</span></span><br><span class="line">            <span class="comment">// 循环直到 destroy() 被调用</span></span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">boolean</span> hasEvents = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!close) &#123;</span><br><span class="line">                       <span class="comment">//遍历events，将每个事件中的Channel的interestOps注册到Selector中</span></span><br><span class="line">                       hasEvents = events();</span><br><span class="line">                       <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">//if we are here, means we have other stuff to do</span></span><br><span class="line">                           <span class="comment">//do a non blocking select</span></span><br><span class="line">                           <span class="comment">//如果走到了这里，代表已经有就绪的IO Channel</span></span><br><span class="line">                           <span class="comment">//调用非阻塞的select方法，直接返回就绪Channel的数量</span></span><br><span class="line">                           keyCount = selector.selectNow();</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">//阻塞等待操作系统返回 数据已经就绪的Channel，然后被唤醒</span></span><br><span class="line">                           keyCount = selector.select(selectorTimeout);</span><br><span class="line">                       &#125;</span><br><span class="line">                       wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                       events();</span><br><span class="line">                       timeout(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           selector.close();</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                           log.error(sm.getString(<span class="string">"endpoint.nio.selectorCloseFail"</span>), ioe);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                   ExceptionUtils.handleThrowable(x);</span><br><span class="line">                   log.error(sm.getString(<span class="string">"endpoint.nio.selectorLoopError"</span>), x);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//either we timed out or we woke up, process events first</span></span><br><span class="line">               <span class="comment">//如果上面select方法超时，或者被唤醒，先将events队列中的Channel注册到Selector上。</span></span><br><span class="line">               <span class="keyword">if</span> ( keyCount == <span class="number">0</span> ) hasEvents = (hasEvents | events());</span><br><span class="line"></span><br><span class="line">               Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">                   keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line">               <span class="comment">// any active event.</span></span><br><span class="line">                <span class="comment">// 遍历已就绪的Channel，并调用processKey来处理该Socket的IO。</span></span><br><span class="line">               <span class="keyword">while</span> (iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">                   SelectionKey sk = iterator.next();</span><br><span class="line">                   NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">                   <span class="comment">// Attachment may be null if another thread has called</span></span><br><span class="line">                   <span class="comment">// cancelledKey()</span></span><br><span class="line">                   <span class="comment">// 如果其它线程已调用，则Attachment可能为空</span></span><br><span class="line">                   <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       iterator.remove();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       iterator.remove();</span><br><span class="line">                   <span class="comment">//创建一个SocketProcessor，放入Tomcat线程池去执行</span></span><br><span class="line">                       processKey(sk, attachment);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//process timeouts</span></span><br><span class="line">               timeout(keyCount,hasEvents);</span><br><span class="line">           &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">           getStopLatch().countDown();</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>上面读取已就绪Channel的部分，是十分常见的Java NIO的用法，即 Selector调用selectedKeys()，获取IO数据已经就绪的Channel，遍历并调用processKey方法来处理每一个Channel就绪的事件。而processKey方法会创建一个SocketProcessor，然后丢到Tomcat线程池中去执行。</p><p>这里还需要注意的一个点是，events()方法，用来处理PollerEvent事件，执行PollerEvent.run()，然后将PollerEvent重置再次放入缓存中，以便对象复用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Processes events in the event queue of the Poller.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &lt;code&gt;true&lt;/code&gt; if some events were processed,</span></span><br><span class="line"><span class="comment">*   &lt;code&gt;false&lt;/code&gt; if queue was empty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">events</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    PollerEvent pe = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != <span class="keyword">null</span>; i++ ) &#123;</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//把SocketChannel的interestOps注册到Selector中</span></span><br><span class="line">            pe.run();</span><br><span class="line">            pe.reset();</span><br><span class="line">            <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                eventCache.push(pe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( Throwable x ) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"endpoint.nio.pollerEventError"</span>), x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，PollerEvent.run()方法才是我们关注的重点:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* PollerEvent, cacheable object for poller events to avoid GC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PollerEvent</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NioChannel socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interestOps;</span><br><span class="line">    <span class="keyword">private</span> NioSocketWrapper socketWrapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PollerEvent</span><span class="params">(NioChannel ch, NioSocketWrapper w, <span class="keyword">int</span> intOps)</span> </span>&#123;</span><br><span class="line">        reset(ch, w, intOps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(NioChannel ch, NioSocketWrapper w, <span class="keyword">int</span> intOps)</span> </span>&#123;</span><br><span class="line">        socket = ch;</span><br><span class="line">        interestOps = intOps;</span><br><span class="line">        socketWrapper = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reset(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Acceptor调用Poller.register()方法时，创建的PollerEvent的interestOps为OP_REGISTER，因此走这个分支</span></span><br><span class="line">        <span class="keyword">if</span> (interestOps == OP_REGISTER) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.getIOChannel().register(</span><br><span class="line">                        socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">"endpoint.nio.registerFail"</span>), x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The key was cancelled (e.g. due to socket closure)</span></span><br><span class="line">                    <span class="comment">// and removed from the selector while it was being</span></span><br><span class="line">                    <span class="comment">// processed. Count down the connections at this point</span></span><br><span class="line">                    <span class="comment">// since it won't have been counted down when the socket</span></span><br><span class="line">                    <span class="comment">// closed.</span></span><br><span class="line">                    socket.socketWrapper.getEndpoint().countDownConnection();</span><br><span class="line">                    ((NioSocketWrapper) socket.socketWrapper).closed = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> NioSocketWrapper socketWrapper = (NioSocketWrapper) key.attachment();</span><br><span class="line">                    <span class="keyword">if</span> (socketWrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//we are registering the key to start with, reset the fairness counter.</span></span><br><span class="line">                        <span class="keyword">int</span> ops = key.interestOps() | interestOps;</span><br><span class="line">                        socketWrapper.interestOps(ops);</span><br><span class="line">                        key.interestOps(ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        socket.getPoller().cancelledKey(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.getPoller().cancelledKey(key);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Poller event: socket ["</span> + socket + <span class="string">"], socketWrapper ["</span> + socketWrapper +</span><br><span class="line">                <span class="string">"], interestOps ["</span> + interestOps + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，可以看出Poller线程的作用</p><ul><li>将Acceptor接收到的请求注册到Poller的事件队列中</li><li>Poller轮询事件队列中，处理到达的事件，将PollerEvent中的通道注册到Poller的Selector中</li><li>轮询已就绪的通道，对每个就绪通道创建一个SocketProcessor，交由Tomcat线程池去处理</li></ul><p>剩下的事情，就是SocketProcessor怎么适配客户端发来请求的数据、然后怎样交给Servlet容器去处理了。</p><p>即Poller的run方法中最后调用的<code>processKey(sk, attachment);</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper attachment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( close ) &#123;</span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( sk.isValid() &amp;&amp; attachment != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sk.isReadable() || sk.isWritable() ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( attachment.getSendfileData() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                    processSendfile(sk,attachment, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unreg(sk, attachment, sk.readyOps());</span><br><span class="line">                    <span class="keyword">boolean</span> closeSocket = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// Read goes before write</span></span><br><span class="line">                    <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_READ, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_WRITE, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (closeSocket) &#123;</span><br><span class="line">                        cancelledKey(sk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//invalid key</span></span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( CancelledKeyException ckx ) &#123;</span><br><span class="line">        cancelledKey(sk);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        log.error(sm.getString(<span class="string">"endpoint.nio.keyProcessingError"</span>), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即从<code>processSocket</code>这个方法中会用到<code>SocketProcessor</code>来处理请求:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Process the given SocketWrapper with the given status. Used to trigger</span></span><br><span class="line"><span class="comment">    * processing as if the Poller (for those endpoints that have one)</span></span><br><span class="line"><span class="comment">    * selected the socket.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> socketWrapper The socket wrapper to process</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> event         The socket event to be processed</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dispatch      Should the processing be performed on a new</span></span><br><span class="line"><span class="comment">    *                          container thread</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> if processing was triggered successfully</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">        SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (socketWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.reset(socketWrapper, event);</span><br><span class="line">        &#125;</span><br><span class="line">        Executor executor = getExecutor();</span><br><span class="line">        <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(sc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">        getLog().warn(sm.getString(<span class="string">"endpoint.executor.fail"</span>, socketWrapper) , ree);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="comment">// This means we got an OOM or similar creating a thread, or that</span></span><br><span class="line">        <span class="comment">// the pool and its queue are full</span></span><br><span class="line">        getLog().error(sm.getString(<span class="string">"endpoint.process.fail"</span>), t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SocketProcessor处理请求"><a href="#SocketProcessor处理请求" class="headerlink" title="SocketProcessor处理请求"></a>SocketProcessor处理请求</h3><p>这里简单提一下<code>SocketProcessor</code>的处理过程，帮助大家对接到Servlet容器处理上。通过上面可以知道，具体处理一个请求，是在SocketProcessor通过线程池去执行的，这里，我们来看其执行一次请求的时序图:<br><img src="https://github.com/muyinchen/woker/blob/master/mypics/%E4%BB%8ESocketProcessor%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png?raw=true" alt=""></p><p>由图中可以看到，<code>SocketProcessor</code>中通过<code>Http11ConnectionHandler</code>，拿到<code>Htpp11Processor</code>，然后<code>Htpp11Processor</code>会调用<code>prepareRequest</code>方法来准备好请求数据。接着调用<code>CoyoteAdapter</code>的<code>service</code>方法进行<code>request</code>和<code>response</code>的适配，之后交给<code>Tomcat</code>容器进行处理。</p><p> 下面通过一个系列调用来表示下过程:</p><p><code>connector.getService().getContainer().getPipeline().getFirst().invoke(request,response);</code></p><p>  这里首先从Connector 中获取到Service ( Connector 在initInternal 方法中创建CoyoteAdapter的时候已经将自己设置到了CoyoteAdapter 中)，然后从Service 中获取Container ，接着获取管道，再获取管道的第一个Value，最后调用invoke 方法执行请求。Service 中保存的是最顶层的容器，当调用最顶层容器管道的invoke 方法时，管道将逐层调用各层容器的管道中Value 的invoke 方法，直到最后调用Wrapper 的管道中的BaseValue ( StandardWrapperValve)来处理Filter 和Servlet。</p><p>将请求交给Tomcat容器处理后，然后将请求一层一层传递到Engine、Host、Context、Wrapper，最终经过一系列Filter，来到了Servlet，执行我们自己具体的代码逻辑。</p><p>至此关于Connector的一些东西就算涉及差不多了，剩下的假如以后有精力的话，继续探究下，接着分享Webflux的解读去。</p><p>补充:<br>感谢零度大佬(博客:<a href="http://www.jiangxinlingdu.com)的提问，这里我将自己的一些额外的问题理解进行内容补充" target="_blank" rel="noopener">http://www.jiangxinlingdu.com)的提问，这里我将自己的一些额外的问题理解进行内容补充</a>:</p><p>这里对于其中<code>NioEndpoint</code>中其有关生命周期部分的实现所涉及的<code>initServerSocket()</code>再来关注下细节:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Separated out to make it easier for folks that extend NioEndpoint to</span></span><br><span class="line"><span class="comment">// implement custom [server]sockets</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initServerSocket</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">        serverSock = ServerSocketChannel.open();</span><br><span class="line">        socketProperties.setProperties(serverSock.socket());</span><br><span class="line">        InetSocketAddress addr = <span class="keyword">new</span> InetSocketAddress(getAddress(), getPortWithOffset());</span><br><span class="line">        serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Retrieve the channel provided by the OS</span></span><br><span class="line">        Channel ic = System.inheritedChannel();</span><br><span class="line">        <span class="keyword">if</span> (ic <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">            serverSock = (ServerSocketChannel) ic;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (serverSock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">"endpoint.init.bind.inherited"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其最后一句，为什么tomcat这个不设置非阻塞？这会儿是刚初始化的时候，设定为阻塞状态，阻塞也只是阻塞在这个线程上，即<code>Acceptor</code>在一条线程内执行其run方法的时候，会调用<code>endpoint.serverSocketAccept()</code>来创建一个<code>socketChannel</code>，接收下一个从服务器进来的连接。当成功接收到，重新对此<code>socket</code>进行配置，即会调用<code>endpoint.setSocketOptions(socket)</code>，在这个方法内，会调用 <code>socket.configureBlocking(false);</code>，此时，会开启<code>SocketChannel</code>在非阻塞模式，具体代码请回顾本文前面细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;tomcat从启动到接轨Servlet二三事&quot;&gt;&lt;a href=&quot;#tomcat从启动到接轨Servlet二三事&quot; class=&quot;headerlink&quot; title=&quot;tomcat从启动到接轨Servlet二三事&quot;&gt;&lt;/a&gt;tomcat从启动到接轨Servlet二三事&lt;/h1&gt;&lt;h2 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;缘由&lt;/h2&gt;&lt;p&gt;也是因为之前自己的不谨慎，在写&lt;code&gt;Java编程方法论-Reactor与Webflux&lt;/code&gt;的时候，因觉得tomcat关于connector部分已经有不错的博文了，草草参考了下，并没有对源码进行深入分析，导致自己在录制分享视频的时候，发现自己文章内容展现的和源码并不一致，又通过搜索引擎搜索了一些中文博客的文章，并不尽如人意，索性，自己的就通过最新的源码来重新梳理一下关于tomcat connector部分内容，也是给自己一个警醒，凡事务必仔细仔细再仔细！&lt;br&gt;参考源码地址: &lt;a href=&quot;https://github.com/apache/tomcat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/apache/tomcat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;Java编程方法论-Reactor与Webflux&lt;/code&gt;的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:&lt;/p&gt;
&lt;p&gt;Rxjava源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av34537840&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av34537840&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Reactor源码解读与分享：&lt;a href=&quot;https://www.bilibili.com/video/av35326911&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av35326911&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="响应式" scheme="https://muyinchen.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
      <category term="Reactor Rxjava" scheme="https://muyinchen.github.io/tags/Reactor-Rxjava/"/>
    
  </entry>
  
  <entry>
    <title>Java编程方法论-响应式 之 Rxjava篇 视频解读</title>
    <link href="https://muyinchen.github.io/2018/11/02/Java%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%93%8D%E5%BA%94%E5%BC%8F%20%E4%B9%8B%20Rxjava%E7%AF%87%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    <id>https://muyinchen.github.io/2018/11/02/Java编程方法论-响应式 之 Rxjava篇 源码解读系列/</id>
    <published>2018-11-02T15:40:25.000Z</published>
    <updated>2018-11-02T15:11:28.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java编程方法论-响应式-之-Rxjava篇-视频解读"><a href="#Java编程方法论-响应式-之-Rxjava篇-视频解读" class="headerlink" title="Java编程方法论-响应式 之 Rxjava篇 视频解读"></a>Java编程方法论-响应式 之 Rxjava篇 视频解读</h1><p>最近给小伙伴分享了Rxjava的源码解读，并录制成视频，也是为了配合自己的未来出版的书，也是对书的内容的补充，将未能写进去的内容通过视频来展现，也加入了一些自己的理解。希望可以对大家有用。</p><p>以下为视频分享内容：</p><a id="more"></a><p>01 响应式入门：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D1" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=1</a></p><p>02 Java9中的响应式编程：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=2</a></p><p>03 Rxjava开篇：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>3</p><p>04 Rxjava中create方法的设计思想：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>4</p><p>05 Observables和Observable.cache()：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>5</p><p>06 无休止数据流与定时控制：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>6</p><p>07 Demo的设计初衷：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>7</p><p>08 Observable.cache()源码解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>8</p><p>09 ConnectableObservable与publish().refCount()解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>9</p><p>10 SubmissionPublisher 中订阅者状态的管理：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>10</p><p>11 RxJava中Subject解读：</p><p><a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>11</p><p>12 filter() map()深入解读与flatMap()初解：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=12</a></p><p>13 flatMap()与scan()深入解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>13</p><p>14 groupBy()进行分组：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>14</p><p>15 merge()的源码解读 上：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>15</p><p>16 merge()的源码解读 下：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>16</p><p>17 zip()的源码解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>17</p><p>18 combineLatest()的源码解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>18</p><p>19 withLatestFrom() 源码解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>19</p><p>20 amb() 操作源码解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=2</a>0</p><p>21 scan()操作的2次深入：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=2</a>1</p><p>22 reduce()源码解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=2</a>2</p><p>23 collect() 源码解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=2</a>3</p><p>24 distinct() distinctUntilChanged() compose() lift()及其他操作源码解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=2</a>4</p><p>25 Observable实战之Spring MVC返回值的响应式化改造：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=2</a>5</p><p>26 汇率查询的小服务及对于返回值处理抽取的前置知识讲解：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=2</a>6</p><p>27 写一个SpringMVC的响应式返回值处理组件springboot-starter：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=2</a>7</p><p>28 RxJava2中的多线程操作中调度器的引入：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=2</a>8</p><p>29 subscribeOn() observeOn() unsubscribeOn()操作源码解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=2</a>9</p><p>30 调度器Scheduler源码设计思路解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>30</p><p>31 调度器Scheduler源码解读补充1：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>31</p><p>32 调度器Scheduler源码解读补充2：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>32</p><p>33 调度器Scheduler源码解读补充3：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>33</p><p>34 背压回顾以及一些探究：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>34</p><p>35 rxjava中SpscLinkedArrayQueue无界队列的实现解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>35</p><p>36 从Observable到 Flowable 的设计思路 及Flowable.create() 中背压设计的解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>36</p><p>37 onBackpressureXXX()操作与Flowable.generate()解读：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>37</p><p>38 关于Rxjava解读简短的结束语：<a href="http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av34537840/%3Fp%3D2" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840/?p=</a>38</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java编程方法论-响应式-之-Rxjava篇-视频解读&quot;&gt;&lt;a href=&quot;#Java编程方法论-响应式-之-Rxjava篇-视频解读&quot; class=&quot;headerlink&quot; title=&quot;Java编程方法论-响应式 之 Rxjava篇 视频解读&quot;&gt;&lt;/a&gt;Java编程方法论-响应式 之 Rxjava篇 视频解读&lt;/h1&gt;&lt;p&gt;最近给小伙伴分享了Rxjava的源码解读，并录制成视频，也是为了配合自己的未来出版的书，也是对书的内容的补充，将未能写进去的内容通过视频来展现，也加入了一些自己的理解。希望可以对大家有用。&lt;/p&gt;
&lt;p&gt;以下为视频分享内容：&lt;/p&gt;
    
    </summary>
    
      <category term="响应式" scheme="https://muyinchen.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
      <category term="Reactor Rxjava" scheme="https://muyinchen.github.io/tags/Reactor-Rxjava/"/>
    
  </entry>
  
  <entry>
    <title>Java编程方法论-响应式 之 Rxjava篇 响应式入门</title>
    <link href="https://muyinchen.github.io/2018/10/26/Java%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%93%8D%E5%BA%94%E5%BC%8F%20%E4%B9%8B%20Rxjava%E7%AF%87%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
    <id>https://muyinchen.github.io/2018/10/26/Java编程方法论-响应式 之 Rxjava篇 响应式入门/</id>
    <published>2018-10-26T15:40:25.000Z</published>
    <updated>2018-10-26T08:46:51.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java编程方法论-响应式-之-Rxjava篇-响应式入门"><a href="#Java编程方法论-响应式-之-Rxjava篇-响应式入门" class="headerlink" title="Java编程方法论-响应式 之 Rxjava篇 响应式入门"></a>Java编程方法论-响应式 之 Rxjava篇 响应式入门</h1><div class="video-container"><iframe src="//player.bilibili.com/player.html?aid=34537840&cid=60510386&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><p>链接地址: <a href="https://www.bilibili.com/video/av34537840" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java编程方法论-响应式-之-Rxjava篇-响应式入门&quot;&gt;&lt;a href=&quot;#Java编程方法论-响应式-之-Rxjava篇-响应式入门&quot; class=&quot;headerlink&quot; title=&quot;Java编程方法论-响应式 之 Rxjava篇 响应式入门&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="响应式" scheme="https://muyinchen.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
      <category term="Reactor Rxjava" scheme="https://muyinchen.github.io/tags/Reactor-Rxjava/"/>
    
  </entry>
  
  <entry>
    <title>2018.9.10 响应式一些内容的分享总结</title>
    <link href="https://muyinchen.github.io/2018/09/12/2018.9.10%20%E5%93%8D%E5%BA%94%E5%BC%8F%E4%B8%80%E4%BA%9B%E5%86%85%E5%AE%B9%E7%9A%84%E5%88%86%E4%BA%AB%E6%80%BB%E7%BB%93/"/>
    <id>https://muyinchen.github.io/2018/09/12/2018.9.10 响应式一些内容的分享总结/</id>
    <published>2018-09-12T15:40:25.000Z</published>
    <updated>2018-09-12T16:18:17.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018-9-10-响应式一些内容的分享总结"><a href="#2018-9-10-响应式一些内容的分享总结" class="headerlink" title="2018.9.10 响应式一些内容的分享总结"></a>2018.9.10 响应式一些内容的分享总结</h1><h2 id="响应式到底是什么？"><a href="#响应式到底是什么？" class="headerlink" title="响应式到底是什么？"></a>响应式到底是什么？</h2><p>现实生活中，当我们听到有人喊我们的时候，我们会对其进行响应，也就是说，我们是基于事件驱动模式来进行的编程。<br>所以这个过程其实就是对于所产生事件的下发，我们的消费者对其进行的一系列的消费。<br>从这个角度，我们可以思考，整个代码的设计我们应该是针对于消费者来讲的，比如看电影，有些画面我们不想看，那就闭上眼睛，有些声音不想听，那就捂上耳朵，说白了，就是对于消费者的增强包装，我们将这些复杂的逻辑给其拆分，然后分割成一个个的小任务进行封装，于是就有了诸如ﬁlter、map、skip、limit等操作。而对于其中源码的设计逻辑，我们放在后面来讲。</p><a id="more"></a><h2 id="并发与并行的关系"><a href="#并发与并行的关系" class="headerlink" title="并发与并行的关系"></a>并发与并行的关系</h2><p>可以这么说，并发很好的利用了CPU时间片的特性，也就是操作系统选择并运行一个任务，接着在下一个时间片会运行另一个任务，并把前一个任务设置成等待状态。<br>其实这里想表达的是<strong>并发并不意味着并行</strong>。<br>具体来举几个情况:</p><ul><li><p>有时候多线程执行会提高应用程序的性能，而有时候反而会降低程序的性能。这在关于JDK中其Stream API的使用上体现的很明显，如果任务量很小，而我们又使用了并行流，反而降低了性能。</p></li><li><p>我们在多线程编程中可能会同时开启或者关闭多个线程，这会产生的很多性能开销，这也降低了程序性能。</p></li><li><p>当我们的线程同时都在等待IO过程，此时并发也就可能会阻塞CPU资源，其造成的后果不仅仅是用户在等待结果，同时会浪费CPU的计算资源。</p></li><li><p>如果几个线程共享了一个数据，情况就变得有些复杂了，我们需要考虑数据在各个线程中状态的一致性。为了达到这个目的，我们很可能会使用Synchronized或者是lock来解决。</p><p>现在，应该对并发有一定的认知了吧。并发是一个很好的东西，但并不一定会实现并行。并行是在多个CPU核心上的同一时间运行多个任务或者一个任务分为多块执行(如ForkJoin)。单核CPU的话就不要考虑了。<br>补充一点，实际上多线程就意味着并发，但是并行只发生在当这些线程在同一时间调度分配在不同CPU上执行。也就是说，并行是并发的一种特定的形式。往往我们一个任务里会产生很多元素，然而这些个元素在不做操作的情况下大都只能在当前线程中操作，要么我们就要对其进行ForkJoin，但这些对于我们很多程序员来讲有时候很不好操作控制，上手难度有些高，响应式的话，我们可以简单的通过其调度API就可以轻松做到事件元素的下发分配，其内部将每个元素包装成一个任务提交到线程池中，我们可以根据是否是计算型任务还是IO类型的任务来选择相应的线程池。<br>这里，需要<strong>强调</strong>一下：线程只是一个对象而已，不要把其想象成cpu中的某一个执行核心，这是很多人都在犯的错，cpu时间片切换执行这些个线程。</p></li></ul><h2 id="响应式中的背压到底是一种怎样的理解"><a href="#响应式中的背压到底是一种怎样的理解" class="headerlink" title="响应式中的背压到底是一种怎样的理解"></a>响应式中的背压到底是一种怎样的理解</h2><p>用一个不算很恰当的中国的成语来讲，就是承上启下。为了更好的解释，我们来看一个场景，大坝，在洪水时期，下游没有办法一下子消耗那么多水，大坝在此的作用就是拦截洪水，并根据下游的消耗情况酌情排放。再者，父亲的背，我们小时候，社会上很多的事情首先由父亲用自己的背来帮我们来扛起，然后根据我们自身的能力来适当的下发给我们压力，也就是说，背压应该写在连接元素生产者和消费者的一个地方，即生产者和消费者的连线者。然后，通过这里的描述，背压应该具有承载元素的能力，也就是其必须是一个容器的，而且元素的存储与下发应该具有先后的，那么使用队列则是最适合不过了。</p><h2 id="如何去看Rxjava或者Reactor的源码，根据源码的接口的设计我们可以得到一些什么启示"><a href="#如何去看Rxjava或者Reactor的源码，根据源码的接口的设计我们可以得到一些什么启示" class="headerlink" title="如何去看Rxjava或者Reactor的源码，根据源码的接口的设计我们可以得到一些什么启示"></a>如何去看Rxjava或者Reactor的源码，根据源码的接口的设计我们可以得到一些什么启示</h2><p>关于响应式的Rx标准已经写入了JDK中:<code>java.util.concurrent.Flow</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Publisher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T item)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt;, <span class="title">Publisher</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，Flow这个类中包含了这4个接口定义，<code>Publisher</code> 通过<code>subscribe</code>方法来和<code>Subscriber</code>产生订阅关系，而<code>Subscriber</code>依靠<code>onSubscribe</code>来首先和上游产生联系，这里就是靠<code>Subscription</code>来做到的，所以说，<code>Subscription</code>往往会作为生产者的内部类定义其中，其用来接收生产者所生产的元素，支持背压的话，<code>Subscription</code>应该首先将其放入到一个队列中，然后根据请求数量来调用<code>Subscriber</code>的<code>onNext</code>等方法进行下发。这个在Rx编程中都是统一的模式，我们通过Reactor中<code>reactor.core.publisher.Flux#fromArray</code>所涉及的<code>FluxArray</code>的源码来对此段内容进行理解:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FluxArray</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Flux</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Fuseable</span>, <span class="title">Scannable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> T[] array;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FluxArray</span><span class="params">(T... array)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.array = Objects.requireNonNull(array, <span class="string">"array"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; s, T[] array)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">Operators.complete(s);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s <span class="keyword">instanceof</span> ConditionalSubscriber) &#123;</span><br><span class="line">s.onSubscribe(<span class="keyword">new</span> ArrayConditionalSubscription&lt;&gt;((ConditionalSubscriber&lt;? <span class="keyword">super</span> T&gt;) s, array));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">s.onSubscribe(<span class="keyword">new</span> ArraySubscription&lt;&gt;(s, array));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; actual)</span> </span>&#123;</span><br><span class="line">subscribe(actual, array);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">scanUnsafe</span><span class="params">(Attr key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key == Attr.BUFFERED) <span class="keyword">return</span> array.length;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraySubscription</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">InnerProducer</span>&lt;<span class="title">T</span>&gt;, <span class="title">SynchronousSubscription</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; actual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> T[] array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> requested;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> AtomicLongFieldUpdater&lt;ArraySubscription&gt; REQUESTED =</span><br><span class="line">AtomicLongFieldUpdater.newUpdater(ArraySubscription.class, <span class="string">"requested"</span>);</span><br><span class="line"></span><br><span class="line">ArraySubscription(CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; actual, T[] array) &#123;</span><br><span class="line"><span class="keyword">this</span>.actual = actual;</span><br><span class="line"><span class="keyword">this</span>.array = array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Operators.validate(n)) &#123;</span><br><span class="line"><span class="keyword">if</span> (Operators.addCap(REQUESTED, <span class="keyword">this</span>, n) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (n == Long.MAX_VALUE) &#123;</span><br><span class="line">fastPath();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">slowPath(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slowPath</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> T[] a = array;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> len = a.length;</span><br><span class="line"><span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; s = actual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = index;</span><br><span class="line"><span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (cancelled) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i != len &amp;&amp; e != n) &#123;</span><br><span class="line">T t = a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">s.onError(<span class="keyword">new</span> NullPointerException(<span class="string">"The "</span> + i + <span class="string">"th array element was null"</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.onNext(t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cancelled) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">e++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == len) &#123;</span><br><span class="line">s.onComplete();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n = requested;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == e) &#123;</span><br><span class="line">index = i;</span><br><span class="line">n = REQUESTED.addAndGet(<span class="keyword">this</span>, -e);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fastPath</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayConditionalSubscription</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">InnerProducer</span>&lt;<span class="title">T</span>&gt;, <span class="title">SynchronousSubscription</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到之前文字在源码内部的表达。这里就不多说了。而对于各种中间操作的包装我们该如何去做，依据之前的接口定义，我们应该更注重功能的设定，而无论是filter，flatmap，map等这些常用的操作，其实都是消费动作，理应定义在消费者层面，想到这里，我们该如何去做？<br>这里，我们就要结合我们的设计模式，装饰模式，对<code>subscribe(Subscriber&lt;? super T&gt; subscriber)</code>所传入的<code>Subscriber</code>进行功能增强，即从<code>Subscriber</code>这个角度来讲，使用的是装饰增强模式，但从外面来看，其整体定义的依然是一个<code>Flux</code>或者<code>Mono</code>，这里<code>FluxArray</code>的话就是例子，这样，从这个角度来讲，其属于向上适配，也就是适配模式，这里的适配玩的比较有意思，完全就是靠对内部类的包装然后通过<code>subscribe(Subscriber&lt;? super T&gt; subscriber)</code>衔接来完成的。</p><p>所以，我们应该想到中国古代苏轼的题西林壁里有一句话:<code>横看成岭侧成峰 远近高低各不同</code>讲的就是从不同的角度去看待一个事物，就会得到不同的结果。同样，一百个人心中有一百个哈姆雷特，也是对于同一个事物的看法，从这里，我们应该能学到设计模式千万不要特别刻意的去绝对化！</p><p>我们可以结合<code>reactor.core.publisher.Flux#filter</code>涉及的<code>FluxFilter</code>来观察理解上述涉及的内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FluxFilter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">FluxOperator</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Predicate&lt;? <span class="keyword">super</span> T&gt; predicate;</span><br><span class="line"></span><br><span class="line">FluxFilter(Flux&lt;? extends T&gt; source, Predicate&lt;? <span class="keyword">super</span> T&gt; predicate) &#123;</span><br><span class="line"><span class="keyword">super</span>(source);</span><br><span class="line"><span class="keyword">this</span>.predicate = Objects.requireNonNull(predicate, <span class="string">"predicate"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; actual)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (actual <span class="keyword">instanceof</span> ConditionalSubscriber) &#123;</span><br><span class="line">source.subscribe(<span class="keyword">new</span> FilterConditionalSubscriber&lt;&gt;((ConditionalSubscriber&lt;? <span class="keyword">super</span> T&gt;) actual,</span><br><span class="line">predicate));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">source.subscribe(<span class="keyword">new</span> FilterSubscriber&lt;&gt;(actual, predicate));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterSubscriber</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">InnerOperator</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">           <span class="title">Fuseable</span>.<span class="title">ConditionalSubscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; actual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Predicate&lt;? <span class="keyword">super</span> T&gt; predicate;</span><br><span class="line"></span><br><span class="line">Subscription s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> done;</span><br><span class="line"></span><br><span class="line">FilterSubscriber(CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; actual, Predicate&lt;? <span class="keyword">super</span> T&gt; predicate) &#123;</span><br><span class="line"><span class="keyword">this</span>.actual = actual;</span><br><span class="line"><span class="keyword">this</span>.predicate = predicate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Operators.validate(<span class="keyword">this</span>.s, s)) &#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (done) &#123;</span><br><span class="line">Operators.onNextDropped(t, actual.currentContext());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">b = predicate.test(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">onError(Operators.onOperatorError(s, e, t, actual.currentContext()));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b) &#123;</span><br><span class="line">actual.onNext(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">s.request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryOnNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (done) &#123;</span><br><span class="line">Operators.onNextDropped(t, actual.currentContext());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">b = predicate.test(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">onError(Operators.onOperatorError(s, e, t, actual.currentContext()));</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b) &#123;</span><br><span class="line">actual.onNext(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (done) &#123;</span><br><span class="line">Operators.onErrorDropped(t, actual.currentContext());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">done = <span class="keyword">true</span>;</span><br><span class="line">actual.onError(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (done) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">done = <span class="keyword">true</span>;</span><br><span class="line">actual.onComplete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">scanUnsafe</span><span class="params">(Attr key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key == Attr.PARENT) <span class="keyword">return</span> s;</span><br><span class="line"><span class="keyword">if</span> (key == Attr.TERMINATED) <span class="keyword">return</span> done;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> InnerOperator.<span class="keyword">super</span>.scanUnsafe(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; actual() &#123;</span><br><span class="line"><span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">s.request(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">s.cancel();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConditionalSubscriber</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">InnerOperator</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">           <span class="title">Fuseable</span>.<span class="title">ConditionalSubscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这些设计，我们自己也是完全可以作为参考来通过一套api接口设计，可以衍生出很多规范逻辑的开发，比如我们看到的众多的Rx衍生操作API的设计实现，其都是按照一套模板来进行的，我们可以称之为代码层面的微服务设计。</p><h2 id="如何去看待众多函数表达式"><a href="#如何去看待众多函数表达式" class="headerlink" title="如何去看待众多函数表达式"></a>如何去看待众多函数表达式</h2><p>人类最擅长描述场景，比如一套动作，假如是舞蹈的话，可以讲是什么什么编舞，但是这个编舞又要在一定的框架之下，即有一定的规范，同样，我们施展一套拳法，也需要一个规范，不能踢一脚也叫拳法。而对于这个规范的实现，那就是一套动作，对于拳法来讲，可能就是一个很简单的左勾拳或者右勾拳，也可以是比较复杂的咏春拳，太极拳等，而且一套拳法可能有很多小套路组成，这些小套路也是遵循着这个规范进行的，那么依据这个思路，我们来看下面的函数式接口定义:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiConsumer</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> BiConsumer&lt;T, U&gt; <span class="title">andThen</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (l, r) -&gt; &#123;</span><br><span class="line">            accept(l, r);</span><br><span class="line">            after.accept(l, r);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到无论是条件判断表达式<code>Predicate</code>还是无返回值动作处理函数<code>BiConsumer</code>都遵循一个标准动作的设计定义思路，并通过<code>default</code>方法来对同类动作进行编排，以达到更加丰富的效果。所以，函数式的应用更加倾向于干净利落，凸显自己要做的事情就好，未来，我会在自己的<code>Java编程方法论- JDK篇</code>中花大量篇幅来解读函数式编程的各种奇特而实用的使用方法，来降低我们复杂接口的设计逻辑难度，做到知名见义，了然于胸的效果。这个在我的<code>Java编程方法论- Reactor与Spring webflux篇</code>中也是有涉及的。</p><h2 id="关于响应式的使用性能的考究"><a href="#关于响应式的使用性能的考究" class="headerlink" title="关于响应式的使用性能的考究"></a>关于响应式的使用性能的考究</h2><p>响应式编程知识一种模式，用的好与坏全看自己对于api的理解程度，不要想着会多么的降低性能，这个并没有进行什么过度包装这一说的，当讲到jdbc这里如何表现不行的时候，当前并没有一个开源的Reactor-jdbc的框架，也就造成的测试的不合理性，何况新的知识是需要大家一起共同来学习推动的，不好的地方我们推动就好，不需要上来就对其进行否定，mongodb有提供相应的响应式api，但其内部还是之前的方式，同样，关系型数据库也是一个道理，响应式编程注重的是中间过程的处理，关于生产元素的获取它没太多关系，更多的还是看元素生产者的性能，一家之言，可能有偏颇，希望理解，有问题提出就好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2018-9-10-响应式一些内容的分享总结&quot;&gt;&lt;a href=&quot;#2018-9-10-响应式一些内容的分享总结&quot; class=&quot;headerlink&quot; title=&quot;2018.9.10 响应式一些内容的分享总结&quot;&gt;&lt;/a&gt;2018.9.10 响应式一些内容的分享总结&lt;/h1&gt;&lt;h2 id=&quot;响应式到底是什么？&quot;&gt;&lt;a href=&quot;#响应式到底是什么？&quot; class=&quot;headerlink&quot; title=&quot;响应式到底是什么？&quot;&gt;&lt;/a&gt;响应式到底是什么？&lt;/h2&gt;&lt;p&gt;现实生活中，当我们听到有人喊我们的时候，我们会对其进行响应，也就是说，我们是基于事件驱动模式来进行的编程。&lt;br&gt;所以这个过程其实就是对于所产生事件的下发，我们的消费者对其进行的一系列的消费。&lt;br&gt;从这个角度，我们可以思考，整个代码的设计我们应该是针对于消费者来讲的，比如看电影，有些画面我们不想看，那就闭上眼睛，有些声音不想听，那就捂上耳朵，说白了，就是对于消费者的增强包装，我们将这些复杂的逻辑给其拆分，然后分割成一个个的小任务进行封装，于是就有了诸如ﬁlter、map、skip、limit等操作。而对于其中源码的设计逻辑，我们放在后面来讲。&lt;/p&gt;
    
    </summary>
    
      <category term="响应式" scheme="https://muyinchen.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    
      <category term="Reactor" scheme="https://muyinchen.github.io/tags/Reactor/"/>
    
  </entry>
  
  <entry>
    <title>关于CyclicBarrier与CountDownLatch的源码比较-CountDownLatch 使用场景</title>
    <link href="https://muyinchen.github.io/2018/05/11/%E5%85%B3%E4%BA%8ECyclicBarrier%E4%B8%8ECountDownLatch%E7%9A%84%E6%BA%90%E7%A0%81%E6%AF%94%E8%BE%83-CountDownLatch%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://muyinchen.github.io/2018/05/11/关于CyclicBarrier与CountDownLatch的源码比较-CountDownLatch 使用场景/</id>
    <published>2018-05-11T15:00:25.000Z</published>
    <updated>2018-05-11T15:31:24.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于CyclicBarrier与CountDownLatch的比较与使用场景的一些讨论"><a href="#关于CyclicBarrier与CountDownLatch的比较与使用场景的一些讨论" class="headerlink" title="关于CyclicBarrier与CountDownLatch的比较与使用场景的一些讨论"></a>关于CyclicBarrier与CountDownLatch的比较与使用场景的一些讨论</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  首先我们先针对于上一节讲的给出一个很重要的区别:<br>  <strong>CountDownLatch</strong> 很明显是可以不限制等待线程的数量，而会限制 <strong>countDown</strong>的操作数。<br>  <strong>CyclicBarrier</strong> 会限制等待线程的数量。</p><a id="more"></a><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>我们来看JDK给我们带来的两种用法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line">  </span><br><span class="line">    doSomethingElse();            <span class="comment">// don't let run yet &lt;1&gt;</span></span><br><span class="line">    startSignal.countDown();      <span class="comment">// let all threads proceed &lt;2&gt;</span></span><br><span class="line">    doSomethingElse();            <span class="comment">// &lt;3&gt;</span></span><br><span class="line">    doneSignal.await();           <span class="comment">// wait for all to finish &lt;4&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">  Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">    <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      startSignal.await(); <span class="comment">// &lt;5&gt;</span></span><br><span class="line">      doWork();</span><br><span class="line">      doneSignal.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>这里其实就是在传达信息，首先，这里定义了一个所传状态值为1的 <strong>startSignal</strong>和状态值为N的 <strong>doneSignal</strong>，然后通过for循环起了N个线程执行任务，但是在这些线程执行具体任务之前我主线程里有一波逻辑必须先行(因为有些变量的设定是子线程里共享的东西)，那么，我就可以在其内进行 <strong>startSignal.await()</strong>的设定，可以看到，我这里N可以是很大的一个数字，这也就是我们上面讲的 <strong>CountDownLatch</strong>的一个很强的特性的应用，接着，在我主线程的一波先行逻辑执行完后(请看<code>&lt;1&gt;</code>)，我就可以放行，于是就可以调用<code>&lt;2&gt;</code>处的 <strong>startSignal.countDown()</strong>，对各个线程进行解除挂起，这里<code>&lt;3&gt;</code>处的代码就和各个子线程里的任务没有什么冲突，也就没什么<code>happen-before</code>这种要求限定了，但我们其他线程就有担心你主线程执行完我任务没完成怎么办，使用sleep？我执行完主线程可能还在等待，这个时间真的不确定，那就在主线程里使用<code>&lt;4&gt;</code>处的代码 <strong>doneSignal.await()</strong>，这样，当我各个子线程都结束的时候，我就可以做到主线程在第一时间也可以结束掉省的浪费资源了，这里，有童鞋可能会说主线程里也可以调用<code>XxxThread.join()</code>，但要注意的是，当一个线程调用之后，主线程就休眠了，剩下的<code>join()</code>操作也就无从谈起了，也就是说其他线程结束的时候会调用一下 <strong>this.notifyAll</strong>但仅针对于这个要结束的线程，所以主线程可能会经历休眠启动，再休眠，再启动，这就浪费性能了。</p><p>我们接着看<code>JDK</code>给我们提供的第二个常用使用场景例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">     Executor e = ...</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">       e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">     doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">   WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">     <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">     <span class="keyword">this</span>.i = i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       doWork(i);</span><br><span class="line">       doneSignal.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure></p><p> 这里就实现了一个<code>分治算法</code>应用，首先，我们可以将要做的工作进行策略分割，也就是 <strong>doWork()</strong>方法实现，里面可以根据所传参数进行策略执行，因为任务要放到线程中执行，而且这里还涉及到了一个策略分配，往往，我们的任务在大局上可以很快的进行策略分块操作，然后，每一个块内我们可以根据情况假如复杂再进行一个forkJoin的一个应用，这里我们无须去考虑那么多，我们通过实现一个 <strong>Runnable</strong>来适配<code>Thread</code>需求，这里，为了适应子线程和主线程的等待执行关系，使用了<code>CountDownLatch</code>来实现，通过上一个例子，大家应该很清楚了，主线程传入一个定义的 <strong>CountDownLatch</strong>对象，子线程调用，在其 <strong>Runnable.run</strong>方法的最后调用 <strong>doneSignal.countDown()</strong>。主线程在其最后调用 <strong>doneSignal.await()</strong>，这都是固定套路，记住就好。<br> 最后，在 <strong>doWork()</strong>中根据策略得到的任务很复杂的话，就可以使用 <strong>forkJoin</strong>策略进行二次分治了，这样就可以做到，分模块，有计算型的模块，也有IO型的模块，而且这些模块彼此不影响，每个模块内部的话可能会有共享数据的情况，就需要根据并发的其他知识进行解决了，这里就不多讲了，具体情况具体分析。</p><p>本文配套分享视频:</p><p><a href="http://v.youku.com/v_show/id_XMzYwMDE3ODA3Ng==.html?spm=a2h3j.8428770.3416059.1" target="_blank" rel="noopener">http://v.youku.com/v_show/id_XMzYwMDE3ODA3Ng==.html?spm=a2h3j.8428770.3416059.1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于CyclicBarrier与CountDownLatch的比较与使用场景的一些讨论&quot;&gt;&lt;a href=&quot;#关于CyclicBarrier与CountDownLatch的比较与使用场景的一些讨论&quot; class=&quot;headerlink&quot; title=&quot;关于CyclicBarrier与CountDownLatch的比较与使用场景的一些讨论&quot;&gt;&lt;/a&gt;关于CyclicBarrier与CountDownLatch的比较与使用场景的一些讨论&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;  首先我们先针对于上一节讲的给出一个很重要的区别:&lt;br&gt;  &lt;strong&gt;CountDownLatch&lt;/strong&gt; 很明显是可以不限制等待线程的数量，而会限制 &lt;strong&gt;countDown&lt;/strong&gt;的操作数。&lt;br&gt;  &lt;strong&gt;CyclicBarrier&lt;/strong&gt; 会限制等待线程的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="Java9" scheme="https://muyinchen.github.io/categories/Java9/"/>
    
    
      <category term="Java" scheme="https://muyinchen.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于CyclicBarrier与CountDownLatch的源码比较-CountDownLatch 源码解读</title>
    <link href="https://muyinchen.github.io/2018/05/09/%E5%85%B3%E4%BA%8ECyclicBarrier%E4%B8%8ECountDownLatch%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A8%E8%AE%BA-CountDownLatch%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://muyinchen.github.io/2018/05/09/关于CyclicBarrier与CountDownLatch的比较与使用场景的一些讨论-CountDownLatch 源码解读/</id>
    <published>2018-05-09T15:00:25.000Z</published>
    <updated>2018-05-11T15:01:53.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人的观点也不一定正确，仅供读者参考。<br><a id="more"></a></p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>我们先来读下<strong>CountDownLatch</strong>这个类的注释:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A synchronization aid that allows one or more threads to wait until</span></span><br><span class="line"><span class="comment"> * a set of operations being performed in other threads completes.</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure></p><p>此处说明了其使用场景允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。这里有两个关键点:<strong>等待</strong>，<strong>一组操作完成</strong>。这里要强调的是，<strong>等待</strong>并不意味着线程一定挂起，<strong>一组操作完成</strong>并不意味着其中一个操作所在的线程就会结束，这是两码事。<br>接着来看第二段注释:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;A &#123;<span class="doctag">@code</span> CountDownLatch&#125; is initialized with a given &lt;em&gt;count&lt;/em&gt;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #await await&#125; methods block until the current count reaches</span></span><br><span class="line"><span class="comment"> * zero due to invocations of the &#123;<span class="doctag">@link</span> #countDown&#125; method, after which</span></span><br><span class="line"><span class="comment"> * all waiting threads are released and any subsequent invocations of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #await await&#125; return immediately.  This is a one-shot phenomenon</span></span><br><span class="line"><span class="comment"> * -- the count cannot be reset.  If you need a version that resets the</span></span><br><span class="line"><span class="comment"> * count, consider using a &#123;<span class="doctag">@link</span> CyclicBarrier&#125;.</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure></p><p>从此处可以知道，<strong>CountDownLatch</strong>用给定的<strong>count</strong>进行初始化。 调用await方法会产生阻塞，直到当前计数count由于调用countDown方法而减至零，此后所有等待的线程被释放，并且后续无论是哪个线程再次进行await调用都会立即返回，不会产生其他动作。 也就是说，这是一次性使用的工具，其计数无法重置。 如果你需要重置计数的版本，请考虑使用CyclicBarrier。<br>这里，我们可以结合下源码来进一步解读，我们首先会看到，<strong>CountDownLatch</strong>只定义了一个<strong>private final Sync sync;</strong>字段，其是final类型，一旦赋值就不可变。</p><h3 id="CountDownLatch的初始化"><a href="#CountDownLatch的初始化" class="headerlink" title="CountDownLatch的初始化"></a><strong>CountDownLatch</strong>的初始化</h3><p>我们先来说<strong>CountDownLatch</strong>的初始化:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这里主要还是创建了一个<code>Sync</code>实例，而这也是这个类的核心所在，它是一个针对于<strong>CountDownLatch</strong>而专门设计的一个实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Synchronization control For CountDownLatch.</span></span><br><span class="line"><span class="comment"> * Uses AQS state to represent count.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其主要还是利用<strong>AQS</strong>的<strong>volatile</strong>字段state来进行状态的控制，这也是我们可以进行<strong>CAS</strong>操作的核心所在。</p><h3 id="共享与独占的区别"><a href="#共享与独占的区别" class="headerlink" title="共享与独占的区别"></a>共享与独占的区别</h3><p>我们在前面知道，调用await方法会产生阻塞，那么这里我们就来看下await:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.CountDownLatch#await()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireSharedInterruptibly</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里，我们看到了<code>Shared</code>，我们仔细追寻，在<code>AQS</code>的的内部类node中，有定义字段<strong>EXCLUSIVE</strong>和<strong>SHARED</strong>这俩就代表了两种情况的使用，独占和共享。其主要还是针对于资源的使用情况来讲的，前者，是对资源，这里就是这个state状态值，单个线程独占这个资源，不为0，不放弃。后者主要是将state状态值共享出来，几个线程都可以操作。而两者应用最大的区别就在于<strong>tryAcquire</strong>和<strong>tryAcquireShared</strong>的实现。这里，我并不会对ReentrantLock中的<strong>tryAcquire</strong>进行讲解。其他地方基本一致，差别点就在于<code>addWaiter(Node.XXX)</code>传入的类型不同，<code>acquireQueued</code>与<code>doAcquireSharedInterruptibly</code>实现思路大致相仿，只是会根据自己实际实现略作调整。这里，我们就专门针对于<strong>CountDownLatch</strong>所涉及到的进行解读。<br>题外话:我们通过知道独占与共享的设计区别，我们就可以很轻松的设计出属于自己的一些特有逻辑的实现，主要还是在于我们首先确定api选型，然后重写相应重点方法即可。</p><h3 id="acquireSharedInterruptibly"><a href="#acquireSharedInterruptibly" class="headerlink" title="acquireSharedInterruptibly"></a>acquireSharedInterruptibly</h3><p>从<strong>acquireSharedInterruptibly</strong>方法名称可以知道，其是可打断的，而且每一个调用<code>await</code>正常来讲都是在一个独立的线程中的，那么这个独立的线程在整个过程中都有可能被打断掉。<br>我们参考上面<strong>CountDownLatch中Sync</strong>的<strong>tryAcquireShared</strong>实现，状态不为0就进入<strong>doAcquireSharedInterruptibly</strong>方法中去，这个方法就是，首先先构造个节点，这个节点有绑定当前所在线程，然后让你进个队列，接着，我们的任务就是无限循环找我们前置节点到底是不是头节点，是的话，就再试着获取下状态值，当看到大于0了，对于<strong>CountDownLatch中Sync</strong>里的实现就是1，那就进入<strong>setHeadAndPropagate(node, r);</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment"> * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment"> * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) <span class="comment">/*之前的节点设定类型在这里就用上了*/</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的都能看懂，这里要强调的是，因为你是<strong>Shared</strong>，还有一点我们需要思考的是，什么时候才会发生tryAcquireShared(1)&gt;0 (这里的参数1在<strong>CountDownLatch中Sync</strong>的<strong>tryAcquireShared</strong>实现里没有什么意义)?就是在状态值为0的时候，也就是产生释放的时候，即调用<strong>java.util.concurrent.CountDownLatch#countDown</strong>将状态值减为0的时候，然后激活头节点，所以我们这里首先释放的其实就是头节点，那读者可能会有疑问，那pre节点是什么，这也是我要强调的，pre节点并不一定是头节点，但是头节点的pre节点绝对就是自身，<br>下面我将三者的源码给出，可以很轻易的看到，假如是头节点，那么在for循环下，就再进行一次其pre节点的设定，初次设定的时候头尾都是自身。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#addWaiter</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node oldTail = tail;</span><br><span class="line">            <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.setPrevRelaxed(oldTail);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                    oldTail.next = node;</span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                initializeSyncQueue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//java.util.concurrent.locks.AbstractQueuedSynchronizer.Node#predecessor</span></span><br><span class="line">     <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#initializeSyncQueue</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes head and tail fields on first contention.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node h;</span><br><span class="line">        <span class="keyword">if</span> (HEAD.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</span><br><span class="line">            tail = h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们知道，在<strong>CountDownLatch</strong>作释放为0的时候，会率先激活头节点，然后后面的逻辑就是依次将自己设定成头节点，并将自身节点的线程状态由需要SIGNAL变为0，即属于正常运行状态，这样，我们方便在<strong>unparkSuccessor</strong>方法中激活下一个节点的所绑定的线程，而当下一个节点为空或者这个节点的线程状态标识位大于0也就是<strong>CANCELLED</strong>的时候，这里就可以根据最后一个节点的来获取线程还未激活的最靠前的那个节点，接下来就是激活这个节点的线程了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!h.compareAndSetWaitStatus(Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !h.compareAndSetWaitStatus(<span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        node.compareAndSetWaitStatus(ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">            <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，我们再次回到<strong>doAcquireSharedInterruptibly</strong>中，这里，我们来看其在最初调用await方法时候所进行的动作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br></pre></td></tr></table></figure></p><p>这是for循环最后所进行的一个操作，if判断里，前者设定了该node所绑定线程需要进行singal的标志位的设定，接着对其所属线程进行线程挂起操作。代码如下，省的大家找了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience method to park and then check if interrupted.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>对于<strong>shouldParkAfterFailedAcquire</strong>里面的代码，这里需要我给大家解惑的是，在我已确定我要挂起的情况下，因为当我是头节点的情况下，<code>tryAcquireShared</code>返回的是-1，何况后面非头结点直接进入这个if语句中。但是，这个await方法的调用可能前后很快，第一次设定状态的时候依然会返回一次false，并不会进行线程挂起，所以就需要那个do while语句来判断waitStatus标志位，这样，我们就可以找到最靠近头结点的那个未将标志位设定singal的那个节点所在。<br>对于<strong>parkAndCheckInterrupt</strong>，我们关心的是<strong>LockSupport.park(this);</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.concurrent.locks.LockSupport#park(java.lang.Object)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        U.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里首先将线程和所传对象进行<strong>setBlocker</strong>绑定，告诉我们这里是因为谁而线程挂起的，方便一但出现异常，我们好通过日志确认，然后进行挂起，在挂起结束后就解除标记对象。</p><p>至此关于<strong>CountDownLatch</strong>涉及完毕。</p><p>本文配套分享视频地址:</p><p><a href="http://v.youku.com/v_show/id_XMzU5Nzc5NjI0NA==.html?spm=a2h3j.8428770.3416059.1" target="_blank" rel="noopener">http://v.youku.com/v_show/id_XMzU5Nzc5NjI0NA==.html?spm=a2h3j.8428770.3416059.1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本人的观点也不一定正确，仅供读者参考。&lt;br&gt;
    
    </summary>
    
      <category term="Java9" scheme="https://muyinchen.github.io/categories/Java9/"/>
    
    
      <category term="Java" scheme="https://muyinchen.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JPA&amp;Hibernate---SessionFactory和EntityManagerFactory之间的区别</title>
    <link href="https://muyinchen.github.io/2017/11/16/JPA&amp;Hibernate---SessionFactory%E5%92%8CEntityManagerFactory%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://muyinchen.github.io/2017/11/16/JPA&amp;Hibernate---SessionFactory和EntityManagerFactory之间的区别/</id>
    <published>2017-11-16T04:00:25.000Z</published>
    <updated>2017-11-16T16:06:26.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JPA-amp-Hibernate—SessionFactory和EntityManagerFactory之间的区别"><a href="#JPA-amp-Hibernate—SessionFactory和EntityManagerFactory之间的区别" class="headerlink" title="JPA&amp;Hibernate—SessionFactory和EntityManagerFactory之间的区别"></a>JPA&amp;Hibernate—SessionFactory和EntityManagerFactory之间的区别</h1><blockquote><p>在谈Spring Data之前，要先讲讲JPA，讲JPA，又不免会说到Hibernate，那就从Hibernate开始说起吧。</p><p>因为很多人都喜欢把JPA和Hibernate混为一谈，这个系列文章会把这个问题讲明白。</p><p>有两种方法来处理Hibernate中的持久性:会话(session)和实体管理器。通过这篇文章，我们将分析这两种机制的区别。<br><a id="more"></a></p></blockquote><h2 id="JPA是一个标准"><a href="#JPA是一个标准" class="headerlink" title="JPA是一个标准"></a>JPA是一个标准</h2><p>实体管理器是JPA规范的一部分，而Hibernate是基于Session对象来实现自己的解决方案，也就是处理持久性。我们已经看到他们中的一个(JPA)是一个标准。我们需要记住的是，JPA是“独立出来的”API，它是一个标准，它描述了如何以标准化的方式处理对象持久化。它可以有多个实现。因此，如果你的应用程序基于JPA的实现，则可以随时在不同的实现之间切换。但对于Hibernate来说却不是这样，它可以但不一定与其他持久性解决方案兼容。</p><h2 id="Hibernate可以在JPA中使用"><a href="#Hibernate可以在JPA中使用" class="headerlink" title="Hibernate可以在JPA中使用"></a>Hibernate可以在JPA中使用</h2><p>下一个区别是用于管理持久性的类。在JPA中，我们查找EntityManagerFactory，EntityManager，可以发现它们都位于<strong>javax.persistence</strong>包中。Hibernate使用它自己的类来表示持久性上下文:<code>SessionFactory</code>，<code>Session</code>。由于JPA所在包(<code>hibernate-jpa-2.1-api</code>中的<code>javax.persistence包</code>)定义的基本都是接口，所以他们的实现可以是不同的(也就说所也可以是基于Hibernate来进行实现的)。</p><p>在使用Hibernate作为JPA实现的情况下，我们可以使用一些Hibernate所特有的功能。实际上，Hibernate的EntityManager实现调用了Session对象。我们可以从一些异常日志中观测到它，例如在关于<code>Hibernate/JPA中的锁</code>(下一篇文章，到时再补链接)的这篇文章中，我们可以看到:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">javax.persistence.RollbackException: Error <span class="keyword">while</span> committing the transaction</span><br><span class="line">  at org.hibernate.ejb.TransactionImpl.commit(TransactionImpl.java:<span class="number">92</span>)</span><br><span class="line">  at com.sandboxWebapp.hibernate.locking.LockingSample.pessimisticReadWithWrite(LockingSample.java:<span class="number">117</span>)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">57</span>)</span><br><span class="line">  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:<span class="number">606</span>)</span><br><span class="line">  at org.junit.runners.model.FrameworkMethod$<span class="number">1</span>.runReflectiveCall(FrameworkMethod.java:<span class="number">44</span>)</span><br><span class="line">  at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:<span class="number">15</span>)</span><br><span class="line">  at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:<span class="number">41</span>)</span><br><span class="line">  at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:<span class="number">20</span>)</span><br><span class="line">  at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:<span class="number">76</span>)</span><br><span class="line">  at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:<span class="number">50</span>)</span><br><span class="line">  at org.junit.runners.ParentRunner$<span class="number">3</span>.run(ParentRunner.java:<span class="number">193</span>)</span><br><span class="line">  at org.junit.runners.ParentRunner$<span class="number">1</span>.schedule(ParentRunner.java:<span class="number">52</span>)</span><br><span class="line">  at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:<span class="number">191</span>)</span><br><span class="line">  at org.junit.runners.ParentRunner.access$<span class="number">000</span>(ParentRunner.java:<span class="number">42</span>)</span><br><span class="line">  at org.junit.runners.ParentRunner$<span class="number">2</span>.evaluate(ParentRunner.java:<span class="number">184</span>)</span><br><span class="line">  at org.junit.runners.ParentRunner.run(ParentRunner.java:<span class="number">236</span>)</span><br><span class="line">  at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:<span class="number">264</span>)</span><br><span class="line">  at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:<span class="number">153</span>)</span><br><span class="line">  at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:<span class="number">124</span>)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">57</span>)</span><br><span class="line">  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:<span class="number">606</span>)</span><br><span class="line">  at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray2(ReflectionUtils.java:<span class="number">208</span>)</span><br><span class="line">  at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:<span class="number">159</span>)</span><br><span class="line">  at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:<span class="number">87</span>)</span><br><span class="line">  at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:<span class="number">153</span>)</span><br><span class="line">  at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:<span class="number">95</span>)</span><br><span class="line">Caused by: javax.persistence.LockTimeoutException: could not execute statement</span><br><span class="line">  at org.hibernate.ejb.AbstractEntityManagerImpl.wrapLockException(AbstractEntityManagerImpl.java:<span class="number">1440</span>)</span><br><span class="line">  at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:<span class="number">1339</span>)</span><br><span class="line">  at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:<span class="number">1310</span>)</span><br><span class="line">  at org.hibernate.ejb.TransactionImpl.commit(TransactionImpl.java:<span class="number">80</span>)</span><br><span class="line">  ... <span class="number">29</span> more</span><br><span class="line">Caused by: org.hibernate.exception.LockTimeoutException: could not execute statement</span><br><span class="line">  at org.hibernate.dialect.MySQLDialect$<span class="number">1</span>.convert(MySQLDialect.java:<span class="number">408</span>)</span><br><span class="line">  at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:<span class="number">49</span>)</span><br><span class="line">  at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:<span class="number">125</span>)</span><br><span class="line">  at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:<span class="number">110</span>)</span><br><span class="line">  at org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.executeUpdate(ResultSetReturnImpl.java:<span class="number">136</span>)</span><br><span class="line">  at org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch.addToBatch(NonBatchingBatch.java:<span class="number">58</span>)</span><br><span class="line">  at org.hibernate.persister.entity.AbstractEntityPersister.update(AbstractEntityPersister.java:<span class="number">3238</span>)</span><br><span class="line">  at org.hibernate.persister.entity.AbstractEntityPersister.updateOrInsert(AbstractEntityPersister.java:<span class="number">3140</span>)</span><br><span class="line">  at org.hibernate.persister.entity.AbstractEntityPersister.update(AbstractEntityPersister.java:<span class="number">3470</span>)</span><br><span class="line">  at org.hibernate.action.internal.EntityUpdateAction.execute(EntityUpdateAction.java:<span class="number">140</span>)</span><br><span class="line">  at org.hibernate.engine.spi.ActionQueue.execute(ActionQueue.java:<span class="number">393</span>)</span><br><span class="line">  at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:<span class="number">385</span>)</span><br><span class="line">  at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:<span class="number">302</span>)</span><br><span class="line">  at org.hibernate.event.internal.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:<span class="number">339</span>)</span><br><span class="line">  at org.hibernate.event.internal.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:<span class="number">52</span>)</span><br><span class="line">  <span class="comment">//请看此处</span></span><br><span class="line">  at org.hibernate.internal.SessionImpl.flush(SessionImpl.java:<span class="number">1240</span>)</span><br><span class="line">  at org.hibernate.internal.SessionImpl.managedFlush(SessionImpl.java:<span class="number">404</span>)</span><br><span class="line">  at org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction.beforeTransactionCommit(JdbcTransaction.java:<span class="number">101</span>)</span><br><span class="line">  at org.hibernate.engine.transaction.spi.AbstractTransactionImpl.commit(AbstractTransactionImpl.java:<span class="number">175</span>)</span><br><span class="line">  at org.hibernate.ejb.TransactionImpl.commit(TransactionImpl.java:<span class="number">75</span>)</span><br><span class="line">  ... <span class="number">29</span> more</span><br><span class="line">Caused by: java.sql.SQLException: Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br><span class="line">  at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:<span class="number">1055</span>)</span><br><span class="line">  at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:<span class="number">956</span>)</span><br><span class="line">  at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:<span class="number">3491</span>)</span><br><span class="line">  at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:<span class="number">3423</span>)</span><br><span class="line">  at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:<span class="number">1936</span>)</span><br><span class="line">  at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:<span class="number">2060</span>)</span><br><span class="line">  at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:<span class="number">2542</span>)</span><br><span class="line">  at com.mysql.jdbc.PreparedStatement.executeInternal(PreparedStatement.java:<span class="number">1734</span>)</span><br><span class="line">  at com.mysql.jdbc.PreparedStatement.executeUpdate(PreparedStatement.java:<span class="number">2019</span>)</span><br><span class="line">  at com.mysql.jdbc.PreparedStatement.executeUpdate(PreparedStatement.java:<span class="number">1937</span>)</span><br><span class="line">  at com.mysql.jdbc.PreparedStatement.executeUpdate(PreparedStatement.java:<span class="number">1922</span>)</span><br><span class="line">  at org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.executeUpdate(ResultSetReturnImpl.java:<span class="number">133</span>)</span><br><span class="line">  ... <span class="number">44</span> more</span><br></pre></td></tr></table></figure><p>这个异常代表一个锁超时，并使用Hibernate的会话(<code>Session</code>)来管理持久性。我们可以在下面的输出片段中观察它:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at org.hibernate.internal.SessionImpl.flush(SessionImpl.java:<span class="number">1240</span>)</span><br><span class="line">at org.hibernate.internal.SessionImpl.managedFlush(SessionImpl.java:<span class="number">404</span>)</span><br></pre></td></tr></table></figure><p>想要从Hibernate的EntityManager实现中获取Session，通过下面简单的调用就能拿到了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Session session = entityManager.unwrap(Session.class);</span><br></pre></td></tr></table></figure><p>通过log日志记录这个<code>session</code>对象应该返回以下输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate<span class="string">'s session is :SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])</span></span><br></pre></td></tr></table></figure><h2 id="Hibernate和JPA方法比较"><a href="#Hibernate和JPA方法比较" class="headerlink" title="Hibernate和JPA方法比较"></a>Hibernate和JPA方法比较</h2><p>这两者不仅只有以上的差异。有一些方法双方都有，但是名称不同。我们首先<strong>通过标识符</strong>来<strong>获取一个实体</strong>。Hibernate的<code>Session</code>使用一个称为<strong>get</strong>的方法，而JPA所使用的方法称为<strong>find。</strong>(源码 就不截取了，请自行建立环境去验证的)，本文所使用Hibernate版本为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了<strong>从持久化上下文中分离出一个实体</strong>(也就是我们通常说的游离态)，Hibernate使用<strong>evict</strong>方法。JPA与更通用的函数命名:<strong>detach</strong> (分离)。两个方案都有通过<strong>persist</strong>方法<strong>将对象附加到持久化上下文</strong>。两者都可以用<strong>refresh</strong>方法刷新 实体(entity)的状态。Hibernate和JPA有另一个相似之处。他们可以通过调用 <strong>clear()方法</strong> 来清除持久化上下文。<strong>调用这个clear()方法会导致其中所有的实体分离(也就是游离化)。关于Session和EntityManager方法的区别，我们应该注意到Session有更多的方法来分析它的内部状态。</strong>关于内部状态，它们有一个通用方法称为<code>isOpen</code>，并允许检查<code>Session</code>或<code>EntityManager</code>是否处于打开状态。此外，Hibernate通过Session，我们可以检查它是否连接(isConnected)，是否包含脏(损坏的)数据(isDirty)，或者判断所处理对象(实体或代理)是否处于只读模式(isReadOnly)。关于对象状态的例子就不再次累述了，请参考<a href="http://blog.csdn.net/u014087286/article/details/47039349博文所述。" target="_blank" rel="noopener">http://blog.csdn.net/u014087286/article/details/47039349博文所述。</a></p><blockquote><p><strong>NOTE:Hibernate save()与persist()区别</strong></p><p>Hibernate 之所以提供与save()功能几乎完全类似的persist()方法，一方面是为了照顾JPA的用法习惯。另一方面，save()和 persist()方法还有一个区别:使用 save() 方法保存持久化对象时，该方法返回该持久化对象的标识属性值(即对应记录的主键值)；但使用 persist() 方法来保存持久化对象时，该方法没有任何返回值。因为 save() 方法需要立即返回持久化对象的标识属性，所以程序执行 save() 会立即将持久化对象对应的数据插入数据库；而 persist() 则保证当它在一个事物外部被调用时，并不立即转换成 insert 语句， 这个功能是很有用的，尤其当我们封装一个长会话流程的时候，persist() 方法就显得尤为重要了。</p><p>主要内容区别： </p><p>1，persist把一个瞬态的实例持久化，但是并”不保证”标识符(identifier主键对应的属性)被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时候。</p><p>2，save, 把一个瞬态的实例持久化标识符，及时的产生,它要返回标识符，所以它会立即执行Sql insert</p></blockquote><p>同样，关于<strong>查询对象</strong>，两者也是有名字不同但作用相同的方法。JPA 通过调用<strong>getSingleResult</strong>来<strong>获取单行</strong>和通过<strong>getResultList</strong>得到<strong>一个结果列表</strong>。Hibernate分别使<strong>uniqueResult</strong>和<strong>list</strong>方法来达到相同效果。在Hibernate5.2之前还有一些额外的方法来<strong>指定查询参数</strong>。通过它提供的<code>setters</code>，我们可以设置一个BigInteger，BigDecimal，二进制，布尔，字节，字符串或日期。在Hibernate5.2之后，和JPA规范进行统一化，统一调用<code>setParameter</code>这个方法来达到相应目的。</p><p>这篇简短的文章描述了JPA和Hibernate的Session持久化机制之间的差异和相似之处。两者都被用来做同样的事情，将Java对象持久化到数据库中去。他们分别通过EntityManager(JPA)和Session(Hibernate)对象管理持久化上下文(persistence context)来实现它。但他们在工作过程中也有一些相似之处。两者都可以通过<code>persist</code>来持久化实体和通过<code>clear</code>方法从持久化上下文分离实体(使之 游离化)。一般来说，更抽象和标准化的解决方案对于应用程序的可移植性来说更好。而使用Hibernate，我们不能轻易地将其转移到另一个持久性框架中。通过在Hibernate中使用JPA的实现(不使用Hibernate特有的功能)，可以更容易实现代码的可移植性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JPA-amp-Hibernate—SessionFactory和EntityManagerFactory之间的区别&quot;&gt;&lt;a href=&quot;#JPA-amp-Hibernate—SessionFactory和EntityManagerFactory之间的区别&quot; class=&quot;headerlink&quot; title=&quot;JPA&amp;amp;Hibernate—SessionFactory和EntityManagerFactory之间的区别&quot;&gt;&lt;/a&gt;JPA&amp;amp;Hibernate—SessionFactory和EntityManagerFactory之间的区别&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在谈Spring Data之前，要先讲讲JPA，讲JPA，又不免会说到Hibernate，那就从Hibernate开始说起吧。&lt;/p&gt;
&lt;p&gt;因为很多人都喜欢把JPA和Hibernate混为一谈，这个系列文章会把这个问题讲明白。&lt;/p&gt;
&lt;p&gt;有两种方法来处理Hibernate中的持久性:会话(session)和实体管理器。通过这篇文章，我们将分析这两种机制的区别。&lt;br&gt;
    
    </summary>
    
      <category term="基础" scheme="https://muyinchen.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JPA" scheme="https://muyinchen.github.io/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>Refresh your Java skills--面对Java学习过程中的一些迷茫</title>
    <link href="https://muyinchen.github.io/2017/11/14/Refresh%20your%20Java%20skills--%E9%9D%A2%E5%AF%B9Java%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%B7%E8%8C%AB/"/>
    <id>https://muyinchen.github.io/2017/11/14/Refresh your Java skills--面对Java学习过程中的一些迷茫/</id>
    <published>2017-11-14T10:46:25.000Z</published>
    <updated>2017-11-14T10:07:52.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Refresh-your-Java-skills–面对Java学习过程中的一些迷茫"><a href="#Refresh-your-Java-skills–面对Java学习过程中的一些迷茫" class="headerlink" title="Refresh your Java skills–面对Java学习过程中的一些迷茫"></a>Refresh your Java skills–面对Java学习过程中的一些迷茫</h1><p>很多时候，我们学习Java，开始的时候觉得很容易，越到后面，内容越多，反而心烦气躁起来，学了忘，忘了学，依然会忘，总是摸不到窍门，再看到社会上和身边都是搞Java的，竞争压力可想一般，看到github上人家写的牛逼哄哄的程序，自己又什么都不会，只会一些简单的Demo，更复杂的逻辑想想都头大，当学到框架之后，自己慢慢变得只会套用框架，玩玩CRUD，导致很多人认为，只要会crud，只要会写关于crud之类的业务就可以了，其他都是在 一味的调用api来完成各种组合。于是，你慢慢就害怕咯，后来者学的太快，而且还是全新的知识，自己只会所谓的业务，这些业务的生命周期，不过就是几年光景，当自己想跳槽的时候，一点底气都没。</p><p>将话题回归，面对日益更新的编程行业，每天都会有全新的概念，全新的技术诞生，如何立之于不败，其实大家都懂，以不变应万变，以静制动。就好比我们高中时做题一样，无论题型如何变，如何复杂，不都还是书中的那些基础知识，于是我们老师一直在给我们强调基础的重要性，我们也在一遍一遍的通过做题来加强我们对于基础的理解。这些基础就是不变的东西，也是静物。</p><p>同样，对于编程语言来讲，其首先是一门语言，我很纳闷国内大学为什么不把编译原理放在大二的时候就开始讲的，哪怕讲的简单一点，可以让学生知道你们是在学习和汉语英语一样的东西，都有词法分析，语法分析，语义分析。而语言是用来表达思想的，没有思想，你只能是一个行尸走肉，这就是国人学习编程最可悲的地方，无视算法的重要性，它是我们组织逻辑的基础，我们的思维需要这些逻辑和相应的语言来表达，而国内太多的培训机构两者皆可抛，大学教育同样如此，只是大家都知道重要，都不去做，因为知道，它不能给你带来短期快速收益，它在你看来不是前沿的东西，殊不知，这些才是最前沿的，经久不衰，各种技术换汤不换药，用的都是他们。</p><p>总结出来，论数据结构和算法的重要性，论基础的重要性，有时候自己迷茫的时候，回归下算法，回归下基础，Java的话，我们可以深入一些我们平时使用的API,其内部用了什么样的算法，一个小程序内部是算法，几个类组成的大点的程序，可能是按照设计模式来进行的，而设计模式，又何尝不是一种别样的算法，属于我们抽象出来的解决事情的标准。不扯更多了，沉淀自己，坚持学习，就这么简单，仅此而已。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Refresh-your-Java-skills–面对Java学习过程中的一些迷茫&quot;&gt;&lt;a href=&quot;#Refresh-your-Java-skills–面对Java学习过程中的一些迷茫&quot; class=&quot;headerlink&quot; title=&quot;Refresh yo
      
    
    </summary>
    
      <category term="Java9" scheme="https://muyinchen.github.io/categories/Java9/"/>
    
    
      <category term="Java" scheme="https://muyinchen.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Refresh your Java skills--聊聊Java9 中模块化所基于的文件系统 JRTFS</title>
    <link href="https://muyinchen.github.io/2017/11/12/Refresh%20your%20Java%20skills--%E8%81%8A%E8%81%8AJava9%20%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%80%E5%9F%BA%E4%BA%8E%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20JRTFS/"/>
    <id>https://muyinchen.github.io/2017/11/12/Refresh your Java skills--聊聊Java9 中模块化所基于的文件系统 JRTFS/</id>
    <published>2017-11-12T08:46:25.000Z</published>
    <updated>2017-11-12T08:55:33.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Refresh-your-Java-skills–聊聊Java9-中模块化所基于的文件系统-JRTFS"><a href="#Refresh-your-Java-skills–聊聊Java9-中模块化所基于的文件系统-JRTFS" class="headerlink" title="Refresh your Java skills–聊聊Java9 中模块化所基于的文件系统 JRTFS"></a>Refresh your Java skills–聊聊Java9 中模块化所基于的文件系统 JRTFS</h1><p>说到文件系统我们很容易就想到Linux，windows操作系统的文件系统，对应到我们的生活中，我们想去一所学校找到某个学生，假如你不了解学号所代表的意义，那就只能是一点一点的找了，不过绝对知道这个学生是几年级，然后一个班一个班的找，假如了解学号的意义的话我们就可以直接定位到哪一栋楼，哪一间教室。</p><p>说的再直白点，不就是是个找啊找啊找朋友的游戏么。这也就是我们排序查找的算法了，而面向大量有用数据最好的实践就是用树形结构来统筹，于是我们的数据库的索引，我们的zookeeper的节点管理，小到我们Java里使用的红黑树，以及对hashmap的优化等等，就是因为其复杂度可以降到最低，只需要凭借树的高度就可以快速找到我们所要找的数据了。</p><p>说了这么多，就是想要表达的是，我们的Java9中所设计的全新的JRTFS也是基于树来表达的。<br><a id="more"></a></p><h2 id="文件系统的设计"><a href="#文件系统的设计" class="headerlink" title="文件系统的设计"></a>文件系统的设计</h2><p>我们往往会将一堆数据分析其成分，然后抽取出结构来对其组织，往往我们碰到的最多的是表结构和其数据，结构定义和数据要分开存放，这里我们首先对其进行结构的定义，接着我们要将每一份数据进行穿针引线，做成一个体系，其实就是一个索引体系，我们要做的就是对其每一个节点的管理。而最后所建立起的索引系统可以作为一个专门的文件来存放(windows系统下面的话请参照<code>C:\Program Files\Java\jdk-9.0.1\lib\modules</code>这个文件)，我们的结构定义作为一个专门的jar文件来存放(windows系统下面的话请参照<code>C:\Program Files\Java\jdk-9.0.1\lib\jrt-fs.jar</code>)</p><h3 id="组织结构定义中基本文件的设计"><a href="#组织结构定义中基本文件的设计" class="headerlink" title="组织结构定义中基本文件的设计"></a>组织结构定义中基本文件的设计</h3><p>我们可以参考Linux文件系统，其一个文件应该包含什么样的基本属性:<code>name</code>,可读性，创建时间，最后修改时间，最后访问时间。</p><p>我们把我们的目光转向<code>jdk.internal.jrtfs</code>这个包下。找到<code>jdk.internal.jrtfs.JrtFileAttributes</code>,因为Java9要兼容Java8的东西，所以势必要做两种不一样的考虑，那么此处就应该开始做一个岔路口。里面定义了上面所说的这些基本属性。同样，我们可以看到它是基于树的节点控制来做到的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * File attributes implementation for jrt image file system.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implNote</span> This class needs to maintain JDK 8 source compatibility.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is used internally in the JDK to implement jimage/jrtfs access,</span></span><br><span class="line"><span class="comment"> * but also compiled and delivered as part of the jrtfs.jar to support access</span></span><br><span class="line"><span class="comment"> * to the jimage file provided by the shipped JDK by tools running on JDK 8.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JrtFileAttributes</span>  <span class="keyword">implements</span> <span class="title">BasicFileAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node node;</span><br><span class="line"></span><br><span class="line">    JrtFileAttributes(Node node) &#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////// basic attributes ///////////</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileTime <span class="title">creationTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.creationTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.isDirectory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOther</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRegularFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !isDirectory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileTime <span class="title">lastAccessTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.lastAccessTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileTime <span class="title">lastModifiedTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.lastModifiedTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymbolicLink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.isLink();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">fileKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.resolveLink(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////// jrtfs specific attributes ///////////</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compressed resource file. If not available or not applicable, 0L is</span></span><br><span class="line"><span class="comment">     * returned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the compressed resource size for compressed resources.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">compressedSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.compressedSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * "file" extension of a file resource.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension string for the file resource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">extension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.extension();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> (Formatter fm = <span class="keyword">new</span> Formatter(sb)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (creationTime() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fm.format(<span class="string">"    creationTime    : %tc%n"</span>, creationTime().toMillis());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fm.format(<span class="string">"    creationTime    : null%n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lastAccessTime() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fm.format(<span class="string">"    lastAccessTime  : %tc%n"</span>, lastAccessTime().toMillis());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fm.format(<span class="string">"    lastAccessTime  : null%n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fm.format(<span class="string">"    lastModifiedTime: %tc%n"</span>, lastModifiedTime().toMillis());</span><br><span class="line">            fm.format(<span class="string">"    isRegularFile   : %b%n"</span>, isRegularFile());</span><br><span class="line">            fm.format(<span class="string">"    isDirectory     : %b%n"</span>, isDirectory());</span><br><span class="line">            fm.format(<span class="string">"    isSymbolicLink  : %b%n"</span>, isSymbolicLink());</span><br><span class="line">            fm.format(<span class="string">"    isOther         : %b%n"</span>, isOther());</span><br><span class="line">            fm.format(<span class="string">"    fileKey         : %s%n"</span>, fileKey());</span><br><span class="line">            fm.format(<span class="string">"    size            : %d%n"</span>, size());</span><br><span class="line">            fm.format(<span class="string">"    compressedSize  : %d%n"</span>, compressedSize());</span><br><span class="line">            fm.format(<span class="string">"    extension       : %s%n"</span>, extension());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以有组成一个树形文件系统的节点定义了。</p><h3 id="文件系统镜像的入口设定"><a href="#文件系统镜像的入口设定" class="headerlink" title="文件系统镜像的入口设定"></a>文件系统镜像的入口设定</h3><p>接着通过<code>jdk.internal.jrtfs.SystemImage</code>来作为文件系统的加载入口，在初始化这个类的时候，会首先把静态代码块给执行，接着，我们会在<code>jdk.internal.jrtfs.JrtFileSystem</code> 其构造函数中发现其调用了<code>SystemImage.open()</code>方法，可以知道其首先会检查<code>C:\Program Files\Java\jdk-9.0.1\lib\modules</code>这个文件是否存在，存在，就使用<code>jdk.internal.jimage.ImageReader</code>中的静态内部类<code>jdk.internal.jimage.ImageReader.SharedImageReader</code>来对此文件的进行读取然后建立相应的文件系统镜像:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemImage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Node <span class="title">findNode</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">byte</span>[] getResource(Node node) <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SystemImage <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modulesImageExists) &#123;</span><br><span class="line">            <span class="comment">// open a .jimage and build directory structure</span></span><br><span class="line">            <span class="keyword">final</span> ImageReader image = ImageReader.open(moduleImageFile);</span><br><span class="line">            image.getRootDirectory();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SystemImage() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function">Node <span class="title">findNode</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> image.findNode(path);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">byte</span>[] getResource(Node node) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    <span class="keyword">return</span> image.getResource(node);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    image.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Files.notExists(explodedModulesDir))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileSystemNotFoundException(explodedModulesDir.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExplodedImage(explodedModulesDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RUNTIME_HOME;</span><br><span class="line">    <span class="comment">// "modules" jimage file Path</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Path moduleImageFile;</span><br><span class="line">    <span class="comment">// "modules" jimage exists or not?</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">boolean</span> modulesImageExists;</span><br><span class="line">    <span class="comment">// &lt;JAVA_HOME&gt;/modules directory Path</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Path explodedModulesDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;String&gt; pa = SystemImage::findHome;</span><br><span class="line">        RUNTIME_HOME = AccessController.doPrivileged(pa);</span><br><span class="line"></span><br><span class="line">        FileSystem fs = FileSystems.getDefault();</span><br><span class="line">        moduleImageFile = fs.getPath(RUNTIME_HOME, <span class="string">"lib"</span>, <span class="string">"modules"</span>);</span><br><span class="line">        explodedModulesDir = fs.getPath(RUNTIME_HOME, <span class="string">"modules"</span>);</span><br><span class="line"></span><br><span class="line">        modulesImageExists = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Files.isRegularFile(moduleImageFile);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the appropriate JDK home for this usage of the FileSystemProvider.</span></span><br><span class="line"><span class="comment">     * When the CodeSource is null (null loader) then jrt:/ is the current runtime,</span></span><br><span class="line"><span class="comment">     * otherwise the JDK home is located relative to jrt-fs.jar.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">findHome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CodeSource cs = SystemImage.class.getProtectionDomain().getCodeSource();</span><br><span class="line">        <span class="keyword">if</span> (cs == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> System.getProperty(<span class="string">"java.home"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assume loaded from $TARGETJDK/lib/jrt-fs.jar</span></span><br><span class="line">        URL url = cs.getLocation();</span><br><span class="line">        <span class="keyword">if</span> (!url.getProtocol().equalsIgnoreCase(<span class="string">"file"</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(url + <span class="string">" loaded in unexpected way"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Path lib = Paths.get(url.toURI()).getParent();</span><br><span class="line">            <span class="keyword">if</span> (!lib.getFileName().toString().equals(<span class="string">"lib"</span>))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(url + <span class="string">" unexpected path"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lib.getParent().toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，上面这个类的定义，我们可以把启动封装一个open方法，最后在大一统实现文件系统的时候集中调用，每个类做好自己那份事情就好。</p><p><code>jdk.internal.jrtfs.JrtFileSystem</code>的构造器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JrtFileSystem</span> <span class="keyword">extends</span> <span class="title">FileSystem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JrtFileSystemProvider provider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JrtPath rootPath = <span class="keyword">new</span> JrtPath(<span class="keyword">this</span>, <span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isOpen;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isClosable;</span><br><span class="line">    <span class="keyword">private</span> SystemImage image;</span><br><span class="line"></span><br><span class="line">    JrtFileSystem(JrtFileSystemProvider provider, Map&lt;String, ?&gt; env)</span><br><span class="line">            <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.provider = provider;</span><br><span class="line">        <span class="keyword">this</span>.image = SystemImage.open();  <span class="comment">// open image file</span></span><br><span class="line">        <span class="keyword">this</span>.isOpen = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.isClosable = env != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提供结构定义并设定加载文件系统入口"><a href="#提供结构定义并设定加载文件系统入口" class="headerlink" title="提供结构定义并设定加载文件系统入口"></a>提供结构定义并设定加载文件系统入口</h3><p>通过前面提到的索引数据和结构定义数据分开的可以知道，我们的结构定义也是需要有的，那么，走进<code>jdk.internal.jrtfs.JrtFileSystemProvider</code>来看看其内在乾坤，从下面的源码中可以知道，<code>JrtFileSystemProvider</code> 会判断区分当前的环境状态(这里要求必须存在<code>C:\Program Files\Java\jdk-9.0.1\lib\jrt-fs.jar</code>)，首先拿到<code>jrt-fs.jar</code>的路径，其实通过<code>URLClassLoader.loadClass(String name, boolean resolve)</code>得到Classloader实例，加载完这些结构定义之后，返回一个<code>FileSystem</code>实例(<code>return new JrtFileSystem(this, env);</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JrtFileSystemProvider</span> <span class="keyword">extends</span> <span class="title">FileSystemProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> FileSystem theFileSystem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JrtFileSystemProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"jrt"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Need RuntimePermission "accessSystemModules" to create or get jrt:/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimePermission perm = <span class="keyword">new</span> RuntimePermission(<span class="string">"accessSystemModules"</span>);</span><br><span class="line">            sm.checkPermission(perm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileSystem <span class="title">newFileSystem</span><span class="params">(URI uri, Map&lt;String, ?&gt; env)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Objects.requireNonNull(env);</span><br><span class="line">        checkPermission();</span><br><span class="line">        checkUri(uri);</span><br><span class="line">        <span class="keyword">if</span> (env.containsKey(<span class="string">"java.home"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> newFileSystem((String)env.get(<span class="string">"java.home"</span>), uri, env);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JrtFileSystem(<span class="keyword">this</span>, env);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JRT_FS_JAR = <span class="string">"jrt-fs.jar"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> FileSystem <span class="title">newFileSystem</span><span class="params">(String targetHome, URI uri, Map&lt;String, ?&gt; env)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Objects.requireNonNull(targetHome);</span><br><span class="line">        Path jrtfs = FileSystems.getDefault().getPath(targetHome, <span class="string">"lib"</span>, JRT_FS_JAR);</span><br><span class="line">        <span class="keyword">if</span> (Files.notExists(jrtfs)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(jrtfs.toString() + <span class="string">" not exist"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String,?&gt; newEnv = <span class="keyword">new</span> HashMap&lt;&gt;(env);</span><br><span class="line">        newEnv.remove(<span class="string">"java.home"</span>);</span><br><span class="line">        ClassLoader cl = newJrtFsLoader(jrtfs);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(JrtFileSystemProvider.class.getName(), <span class="keyword">false</span>, cl);</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">            Object tmp = c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> ((FileSystemProvider)tmp).newFileSystem(uri, newEnv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException |</span><br><span class="line">                 IllegalAccessException |</span><br><span class="line">                 InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件系统路径定义"><a href="#文件系统路径定义" class="headerlink" title="文件系统路径定义"></a>文件系统路径定义</h3><p>既然是文件系统，路径这块总要有定义的，就好像Linux使用<code>/</code>作为根，对于Jrtfs来说，同样要有相应定义的。<code>jdk.internal.jrtfs.JrtPath</code> 就是<code>jrt file systems</code>关于<code>Path</code>的基本实现类。</p><p>作为一个<code>Path</code>其解析的肯定是一个URI字符串路径，对于操作字符串，我们用的比较多的有切分，而且字符串内部用的比较多的同样有<code>offset</code>，和判断<code>/home/abc/ddd</code>一样，我们通过确认<code>/</code>这个约定来对文件系统进行分层，确定父子 关系，就好像我们的<code>/Base/A模块/B模块/C模块</code>,要获取某些操作，我们都需要先对这个路径以<code>/</code>做偏移量操作，以方便快速获取到某模块的名字。而我们的很多方法刚开始都会调用<code>initOffsets();</code>,那我们来看看这个方法的具体操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create offset list if not already created</span></span><br><span class="line"><span class="comment">//首先确定`/`的字符数量，来确定模块数量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initOffsets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.offsets == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = path.length();</span><br><span class="line">            <span class="comment">// count names</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (off &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = path.charAt(off++);</span><br><span class="line">              <span class="comment">//排除多个"//..."相连的情况，两个，三个等等，当"/"后面是其他的时候，说明就是一个模块</span></span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">'/'</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    off = path.indexOf(<span class="string">'/'</span>, off);</span><br><span class="line">                    <span class="keyword">if</span> (off == -<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// populate offsets</span></span><br><span class="line">          <span class="comment">//计算这个模块路径上，每个模块所在的偏移量位置，方便快速拿到</span></span><br><span class="line">            <span class="keyword">int</span>[] offsets = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            off = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (off &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = path.charAt(off);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    off++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    offsets[count++] = off++;</span><br><span class="line">                    off = path.indexOf(<span class="string">'/'</span>, off);</span><br><span class="line">                    <span class="keyword">if</span> (off == -<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.offsets = offsets;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后再加入一个<code>JrtFileSystem</code>,自然很多事情就可以做到了，此处就不再多说了。</p><h3 id="Jrt文件系统的文件存储实现"><a href="#Jrt文件系统的文件存储实现" class="headerlink" title="Jrt文件系统的文件存储实现"></a>Jrt文件系统的文件存储实现</h3><p>其实<code>Jrt  file systems</code>的文件存储实现很简单，可以说没什么内容，因为是内存里建立起来的镜像文件系统，它也只提供了一些基本的约束，如，文件系统应该以什么为开头等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JrtFileStore</span> <span class="keyword">extends</span> <span class="title">FileStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> FileSystem jrtfs;</span><br><span class="line"></span><br><span class="line">    JrtFileStore(JrtPath jrtPath) &#123;</span><br><span class="line">        <span class="keyword">this</span>.jrtfs = jrtPath.getFileSystem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jrtfs.toString()<span class="comment">/*"jrt:/"*/</span> + <span class="string">"/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"jrtfs"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//JRT文件系统的话，返回的是true</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jrtfs.isReadOnly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsFileAttributeView</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.equals(<span class="string">"basic"</span>) || name.equals(<span class="string">"jrt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jrtfs中文件属性视图的设定"><a href="#Jrtfs中文件属性视图的设定" class="headerlink" title="Jrtfs中文件属性视图的设定"></a>Jrtfs中文件属性视图的设定</h3><p>我们在写web项目的时候，往往会使用DTO来展示这些公开的数据，对于文件系统中的文件也是，这就出现了文件属性视图的需求，包括读取和对这些公开属性的设定，比如文件的创建修改时间。</p><p>我们找到<code>java.nio.file.attribute.BasicFileAttributeView</code>这个接口，里面定义了上面所说的这些基本属性。然后我们通过<code>jdk.internal.jrtfs.JrtFileAttributeView</code>来对其进行实现。</p><p>我们可以通过文件系统类的类型是否相等来判断到底是使用老版本的通过classpath来加载的方式，还是通过Jrtfs的方式来加载。请看如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// Cast to V</span></span><br><span class="line">   <span class="keyword">static</span> &lt;V extends FileAttributeView&gt; <span class="function">V <span class="title">get</span><span class="params">(JrtPath path, Class&lt;V&gt; type, LinkOption... options)</span> </span>&#123;</span><br><span class="line">       Objects.requireNonNull(type);</span><br><span class="line">       <span class="keyword">if</span> (type == BasicFileAttributeView.class) &#123;</span><br><span class="line">           <span class="keyword">return</span> (V) <span class="keyword">new</span> JrtFileAttributeView(path, <span class="keyword">false</span>, options);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (type == JrtFileAttributeView.class) &#123;</span><br><span class="line">           <span class="keyword">return</span> (V) <span class="keyword">new</span> JrtFileAttributeView(path, <span class="keyword">true</span>, options);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>也可以通过一个<code>String</code>关键字来判断:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> JrtFileAttributeView <span class="title">get</span><span class="params">(JrtPath path, String type, LinkOption... options)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(type);</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"basic"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JrtFileAttributeView(path, <span class="keyword">false</span>, options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"jrt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JrtFileAttributeView(path, <span class="keyword">true</span>, options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isJrtView ? <span class="string">"jrt"</span> : <span class="string">"basic"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>基本属性的话，首先对所操作属性进行判断了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">attribute</span><span class="params">(AttrID id, JrtFileAttributes jrtfas, <span class="keyword">boolean</span> isJrtView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (id) &#123;</span><br><span class="line">            <span class="keyword">case</span> size:</span><br><span class="line">                <span class="keyword">return</span> jrtfas.size();</span><br><span class="line">            <span class="keyword">case</span> creationTime:</span><br><span class="line">                <span class="keyword">return</span> jrtfas.creationTime();</span><br><span class="line">            <span class="keyword">case</span> lastAccessTime:</span><br><span class="line">                <span class="keyword">return</span> jrtfas.lastAccessTime();</span><br><span class="line">            <span class="keyword">case</span> lastModifiedTime:</span><br><span class="line">                <span class="keyword">return</span> jrtfas.lastModifiedTime();</span><br><span class="line">            <span class="keyword">case</span> isDirectory:</span><br><span class="line">                <span class="keyword">return</span> jrtfas.isDirectory();</span><br><span class="line">            <span class="keyword">case</span> isRegularFile:</span><br><span class="line">                <span class="keyword">return</span> jrtfas.isRegularFile();</span><br><span class="line">            <span class="keyword">case</span> isSymbolicLink:</span><br><span class="line">                <span class="keyword">return</span> jrtfas.isSymbolicLink();</span><br><span class="line">            <span class="keyword">case</span> isOther:</span><br><span class="line">                <span class="keyword">return</span> jrtfas.isOther();</span><br><span class="line">            <span class="keyword">case</span> fileKey:</span><br><span class="line">                <span class="keyword">return</span> jrtfas.fileKey();</span><br><span class="line">            <span class="keyword">case</span> compressedSize:</span><br><span class="line">                <span class="keyword">if</span> (isJrtView) &#123;</span><br><span class="line">                    <span class="keyword">return</span> jrtfas.compressedSize();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> extension:</span><br><span class="line">                <span class="keyword">if</span> (isJrtView) &#123;</span><br><span class="line">                    <span class="keyword">return</span> jrtfas.extension();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的枚举类型，也是我们这个类中定义的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> AttrID &#123;</span><br><span class="line">       size,</span><br><span class="line">       creationTime,</span><br><span class="line">       lastAccessTime,</span><br><span class="line">       lastModifiedTime,</span><br><span class="line">       isDirectory,</span><br><span class="line">       isRegularFile,</span><br><span class="line">       isSymbolicLink,</span><br><span class="line">       isOther,</span><br><span class="line">       fileKey,</span><br><span class="line">       compressedSize,</span><br><span class="line">       extension</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>就到此吧，关于更多对模块的解读，留在下一篇去说。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Refresh-your-Java-skills–聊聊Java9-中模块化所基于的文件系统-JRTFS&quot;&gt;&lt;a href=&quot;#Refresh-your-Java-skills–聊聊Java9-中模块化所基于的文件系统-JRTFS&quot; class=&quot;headerlink&quot; title=&quot;Refresh your Java skills–聊聊Java9 中模块化所基于的文件系统 JRTFS&quot;&gt;&lt;/a&gt;Refresh your Java skills–聊聊Java9 中模块化所基于的文件系统 JRTFS&lt;/h1&gt;&lt;p&gt;说到文件系统我们很容易就想到Linux，windows操作系统的文件系统，对应到我们的生活中，我们想去一所学校找到某个学生，假如你不了解学号所代表的意义，那就只能是一点一点的找了，不过绝对知道这个学生是几年级，然后一个班一个班的找，假如了解学号的意义的话我们就可以直接定位到哪一栋楼，哪一间教室。&lt;/p&gt;
&lt;p&gt;说的再直白点，不就是是个找啊找啊找朋友的游戏么。这也就是我们排序查找的算法了，而面向大量有用数据最好的实践就是用树形结构来统筹，于是我们的数据库的索引，我们的zookeeper的节点管理，小到我们Java里使用的红黑树，以及对hashmap的优化等等，就是因为其复杂度可以降到最低，只需要凭借树的高度就可以快速找到我们所要找的数据了。&lt;/p&gt;
&lt;p&gt;说了这么多，就是想要表达的是，我们的Java9中所设计的全新的JRTFS也是基于树来表达的。&lt;br&gt;
    
    </summary>
    
      <category term="Java9" scheme="https://muyinchen.github.io/categories/Java9/"/>
    
    
      <category term="Java" scheme="https://muyinchen.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Refresh your Java skills--聊聊Java9 中模块化设计是如何实现类似IOC依赖注入效果及与其区别</title>
    <link href="https://muyinchen.github.io/2017/11/07/Refresh%20your%20Java%20skills--%E8%81%8A%E8%81%8AJava9%20%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0IOC%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%95%88%E6%9E%9C%E7%9A%84/"/>
    <id>https://muyinchen.github.io/2017/11/07/Refresh your Java skills--聊聊Java9 中模块化设计是如何实现IOC依赖注入效果的/</id>
    <published>2017-11-07T12:00:25.000Z</published>
    <updated>2017-11-12T08:47:54.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Refresh-your-Java-skills–聊聊Java9-中模块化设计是如何实现类似IOC依赖注入效果及与其区别"><a href="#Refresh-your-Java-skills–聊聊Java9-中模块化设计是如何实现类似IOC依赖注入效果及与其区别" class="headerlink" title="Refresh your Java skills–聊聊Java9 中模块化设计是如何实现类似IOC依赖注入效果及与其区别"></a>Refresh your Java skills–聊聊Java9 中模块化设计是如何实现类似IOC依赖注入效果及与其区别</h1><h2 id="场景引入"><a href="#场景引入" class="headerlink" title="场景引入"></a>场景引入</h2><p>如何实现IOC的效果，我们可以来想想，无非就是一个隐式实现，而想要做到，总不能什么都没有，来个巧妇难为无米之炊的境地吧，所以说，米必须要有滴，在Spring中就是一个bean，也就是说，容器里得有米，再官话点就是上下文中得存在所需要的bean。同样模块化中两个互相隔离的模块想要达到这种效果，也要先往jvm里扔个对象进去的，然后<strong>who use ，who get</strong> 就可以了。<br><a id="more"></a><br>请看例子(可以认为是我们平常写的SpringMVC项目中的service-&gt;serviceImpl-&gt;controller):</p><h3 id="service接口化模块"><a href="#service接口化模块" class="headerlink" title="service接口化模块"></a>service接口化模块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.api;</span><br><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CodecFactory</span> </span>&#123;</span><br><span class="line">          <span class="function">Encoder <span class="title">getEncoder</span><span class="params">(String encodingName)</span></span>;</span><br><span class="line">          <span class="function">Decoder <span class="title">getDecoder</span><span class="params">(String encodingName)</span></span>;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>上面这个接口所在的模块定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> migo.codec.api &#123;</span><br><span class="line">   <span class="keyword">exports</span> com.example.api;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serviceImpl化模块"><a href="#serviceImpl化模块" class="headerlink" title="serviceImpl化模块"></a>serviceImpl化模块</h3><p>接着，我们定义一个实现模块:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> migo.codec.service &#123;</span><br><span class="line">   <span class="keyword">requires</span> com.example.api;</span><br><span class="line"></span><br><span class="line">   provides com.example.api.CodecFactory with com.example.service.codec.CodecFactoryImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现就省略了。</p><h3 id="controller化模块"><a href="#controller化模块" class="headerlink" title="controller化模块"></a>controller化模块</h3><p>最后我们在最上层的模块内使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> migo.codec.controller &#123;</span><br><span class="line">   <span class="keyword">requires</span> migo.codec.api;</span><br><span class="line"></span><br><span class="line">   uses com.example.api.CodecFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的controller模块内使用的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;CodecFactory&gt; loader = ServiceLoader.load(CodecFactory.class);</span><br><span class="line">      <span class="keyword">for</span> (CodecFactory factory : loader) &#123;</span><br><span class="line">          Encoder enc = factory.getEncoder(<span class="string">"PNG"</span>);</span><br><span class="line">          <span class="keyword">if</span> (enc != <span class="keyword">null</span>)</span><br><span class="line">              ... use enc to encode a PNG file</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    CodecFactory cf =</span><br><span class="line">      ServiceLoader.load(CodecFactory.class)</span><br><span class="line">                   .findFirst()</span><br><span class="line">                   .orElse(getFallBack());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(cf == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Using a fallback"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Found a service"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> CodecFactory <span class="title">getFallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>亦或者假如有很多服务实现的提供者，而某个提供服务实现的provider(也就是serviceImpl)上面有添加注解<code>@PNG</code>，而我们想使用带有这个注解的实例，可以使用以下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;CodecFactory&gt; loader = ServiceLoader.load(CodecFactory.class);</span><br><span class="line">      Set&lt;CodecFactory&gt; pngFactories = loader</span><br><span class="line">             .stream()                                              </span><br><span class="line">             .filter(p -&gt; p.type().isAnnotationPresent(PNG.class))  </span><br><span class="line">             .map(Provider::get)                                   </span><br><span class="line">             .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><h2 id="内部工作机制原理"><a href="#内部工作机制原理" class="headerlink" title="内部工作机制原理"></a>内部工作机制原理</h2><h3 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路:"></a>具体思路:</h3><p>通过在模块定义里面的<strong>provides aaa with aaaImpl</strong> 这个功能，可以很容易的想到<code>key value</code>组合<br>当我们碰到这对关键字的时候，我们就会解析并将<code>aaa</code>做为<code>key</code>，<code>aaaImpl</code>添加到一个<code>list</code>中并将这个<code>list</code>作为<code>value</code>，并添加到一个<code>Map&lt;String,list&gt;</code>中<br>在我们碰到<code>uses</code>关键字（源码里面<code>acc</code>会去确定这个权限），并通过<code>ServiceLoader.load(key)</code>来找到这个key所对应的一个包含了实现类具体地址的list，可能有多个，那么，拓展功能，我们使用一个装饰模式，也就是继承了<code>Iterable</code>这个接口，可以达到遍历并生成具体实例来达到要求。</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h3 id="确定米粒的路径"><a href="#确定米粒的路径" class="headerlink" title="确定米粒的路径"></a>确定米粒的路径</h3><p>那么按照这个思路，我们反着来找下，这里只列关键代码:</p><p>从上面的Demo中，我们可以看到，通过类的class字节码来加载:</p><p>之前有说，巧妇难为无米之炊，所以这个上下文很重要，我们的类加载器也是要讲究上下文的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new service loader for the given service type, using the</span></span><br><span class="line"><span class="comment">    * current thread's &#123;<span class="doctag">@linkplain</span> java.lang.Thread#getContextClassLoader</span></span><br><span class="line"><span class="comment">    * context class loader&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt; An invocation of this convenience method of the form</span></span><br><span class="line"><span class="comment">    * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    *     ServiceLoader.load(service)</span></span><br><span class="line"><span class="comment">    * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * is equivalent to</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    *     ServiceLoader.load(service, Thread.currentThread().getContextClassLoader())</span></span><br><span class="line"><span class="comment">    * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiNote</span> Service loader objects obtained with this method should not be</span></span><br><span class="line"><span class="comment">    * cached VM-wide. For example, different applications in the same VM may</span></span><br><span class="line"><span class="comment">    * have different thread context class loaders. A lookup by one application</span></span><br><span class="line"><span class="comment">    * may locate a service provider that is only visible via its thread</span></span><br><span class="line"><span class="comment">    * context class loader and so is not suitable to be located by the other</span></span><br><span class="line"><span class="comment">    * application. Memory leaks can also arise. A thread local may be suited</span></span><br><span class="line"><span class="comment">    * to some applications.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  &lt;S&gt; the class of the service type</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  service</span></span><br><span class="line"><span class="comment">    *         The interface or abstract class representing the service</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> A new service loader</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ServiceConfigurationError</span></span><br><span class="line"><span class="comment">    *         if the service type is not accessible to the caller or the</span></span><br><span class="line"><span class="comment">    *         caller is in an explicit module and its module descriptor does</span></span><br><span class="line"><span class="comment">    *         not declare that it uses &#123;<span class="doctag">@code</span> service&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@revised</span> 9</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@spec</span> JPMS</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">       ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(Reflection.getCallerClass(), service, cl);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们进去这个<code>ServiceLoader</code>，其实无非就是一个构造器而已了，关键代码我截下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.service = svc;</span><br><span class="line">      <span class="keyword">this</span>.serviceName = svc.getName();</span><br><span class="line">      <span class="keyword">this</span>.layer = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.loader = cl;</span><br><span class="line">      <span class="keyword">this</span>.acc = (System.getSecurityManager() != <span class="keyword">null</span>)</span><br><span class="line">              ? AccessController.getContext()</span><br><span class="line">              : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>有了这个加载器之后，其实我们就拿到了上下文和访问权限的一些东西，我们再来看看这个类的字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// The class or interface representing the service being loaded</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The class of the service type</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The module layer used to locate providers; null when locating</span></span><br><span class="line">    <span class="comment">// providers using a class loader</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ModuleLayer layer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The class loader used to locate, load, and instantiate providers;</span></span><br><span class="line">    <span class="comment">// null when locating provider using a module layer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The access control context taken when the ServiceLoader is created</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The lazy-lookup iterator for iterator operations</span></span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Provider&lt;S&gt;&gt; lookupIterator1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;S&gt; instantiatedProviders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The lazy-lookup iterator for stream operations</span></span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Provider&lt;S&gt;&gt; lookupIterator2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Provider&lt;S&gt;&gt; loadedProviders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> loadedAllProviders; <span class="comment">// true when all providers loaded</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Incremented when reload is called</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> reloadCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JavaLangAccess LANG_ACCESS;</span><br></pre></td></tr></table></figure><p>可以看到，它实现了按照我们分析的<code>Iterable</code>接口，这样我们就可以多了很多操作，而且我们也看到了下面这几个东西，这样我们就可以做事情了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Iterator&lt;Provider&lt;S&gt;&gt; lookupIterator2;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Provider&lt;S&gt;&gt; loadedProviders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> loadedAllProviders; <span class="comment">// true when all providers loaded</span></span><br></pre></td></tr></table></figure><p>我们走进<code>findFirst</code>这个方法来看看:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;S&gt; <span class="title">findFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator&lt;S&gt; iterator = iterator();</span><br><span class="line">        <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.of(iterator.next());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们看到了<code>iterator()</code>这个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// create lookup iterator if needed</span></span><br><span class="line">       <span class="keyword">if</span> (lookupIterator1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">           lookupIterator1 = newLookupIterator();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// record reload count</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> expectedReloadCount = ServiceLoader.<span class="keyword">this</span>.reloadCount;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>现在<code>newLookupIterator()</code>进入到我们的视野中，没有条件创建条件，刚开始我们可没有拿到米，现在去找米去:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a new lookup iterator.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Iterator&lt;Provider&lt;S&gt;&gt; newLookupIterator() &#123;</span><br><span class="line">       <span class="keyword">assert</span> layer == <span class="keyword">null</span> || loader == <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (layer != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> LayerLookupIterator&lt;&gt;();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Iterator&lt;Provider&lt;S&gt;&gt; first = <span class="keyword">new</span> ModuleServicesLookupIterator&lt;&gt;();</span><br><span class="line">           Iterator&lt;Provider&lt;S&gt;&gt; second = <span class="keyword">new</span> LazyClassPathLookupIterator&lt;&gt;();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Provider&lt;S&gt;&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> (first.hasNext() || second.hasNext());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Provider&lt;S&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">if</span> (first.hasNext()) &#123;</span><br><span class="line">                       <span class="keyword">return</span> first.next();</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (second.hasNext()) &#123;</span><br><span class="line">                       <span class="keyword">return</span> second.next();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里抛开其他我们来看<code>ModuleServicesLookupIterator()</code>这个构造函数 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ModuleServicesLookupIterator() &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentLoader = loader;</span><br><span class="line">            <span class="keyword">this</span>.iterator = iteratorFor(loader);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>映入眼帘的是<code>iteratorFor(ClassLoader loader)</code>这个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns an iterator to iterate over the implementations of &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">         * service&#125; in modules defined to the given class loader or in custom</span></span><br><span class="line"><span class="comment">         * layers with a module defined to this class loader.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Iterator&lt;ServiceProvider&gt; <span class="title">iteratorFor</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// modules defined to the class loader</span></span><br><span class="line">            ServicesCatalog catalog;</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                catalog = BootLoader.getServicesCatalog();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                catalog = ServicesCatalog.getServicesCatalogOrNull(loader);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//此处往下到我中文标记结束就是我们的正主了</span></span><br><span class="line">            List&lt;ServiceProvider&gt; providers;</span><br><span class="line">            <span class="keyword">if</span> (catalog == <span class="keyword">null</span>) &#123;</span><br><span class="line">                providers = List.of();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                providers = catalog.findServices(serviceName);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//结束</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// modules in layers that define modules to the class loader</span></span><br><span class="line">            ClassLoader platformClassLoader = ClassLoaders.platformClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span> || loader == platformClassLoader) &#123;</span><br><span class="line">                <span class="keyword">return</span> providers.iterator();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;ServiceProvider&gt; allProviders = <span class="keyword">new</span> ArrayList&lt;&gt;(providers);</span><br><span class="line">                Iterator&lt;ModuleLayer&gt; iterator = LANG_ACCESS.layers(loader).iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    ModuleLayer layer = iterator.next();</span><br><span class="line">                    <span class="keyword">for</span> (ServiceProvider sp : providers(layer)) &#123;</span><br><span class="line">                        ClassLoader l = loaderFor(sp.<span class="keyword">module</span>());</span><br><span class="line">                        <span class="keyword">if</span> (l != <span class="keyword">null</span> &amp;&amp; l != platformClassLoader) &#123;</span><br><span class="line">                            allProviders.add(sp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> allProviders.iterator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里终于找到了<code>findServices(String service)</code>这个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the (possibly empty) list of service providers that implement</span></span><br><span class="line"><span class="comment">    * the given service type.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;ServiceProvider&gt; <span class="title">findServices</span><span class="params">(String service)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> map.getOrDefault(service, Collections.emptyList());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结合<code>getOrDefault</code>的源码可知:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">       V v;</span><br><span class="line">       <span class="keyword">return</span> (((v = get(key)) != <span class="keyword">null</span>) || containsKey(key))</span><br><span class="line">           ? v</span><br><span class="line">           : defaultValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>是不是和我们的具体思路接上轨了</p><h3 id="拿到我们想要的大米"><a href="#拿到我们想要的大米" class="headerlink" title="拿到我们想要的大米"></a>拿到我们想要的大米</h3><p>而我们的<code>provider</code>实例从何而来，请容我娓娓道来咯：</p><p>我们从<code>jdk.internal.module.Modules</code>这个模块定义类中可以找到<code>addProvides</code>这个方法，也就是说在我们加载这个模块的时候，这个动作就已经要干活了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Updates module m to provide a service</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addProvides</span><span class="params">(Module m, Class&lt;?&gt; service, Class&lt;?&gt; impl)</span> </span>&#123;</span><br><span class="line">      ModuleLayer layer = m.getLayer();</span><br><span class="line"></span><br><span class="line">      PrivilegedAction&lt;ClassLoader&gt; pa = m::getClassLoader;</span><br><span class="line">      ClassLoader loader = AccessController.doPrivileged(pa);</span><br><span class="line"></span><br><span class="line">      ClassLoader platformClassLoader = ClassLoaders.platformClassLoader();</span><br><span class="line">      <span class="keyword">if</span> (layer == <span class="keyword">null</span> || loader == <span class="keyword">null</span> || loader == platformClassLoader) &#123;</span><br><span class="line">          <span class="comment">// update ClassLoader catalog</span></span><br><span class="line">          ServicesCatalog catalog;</span><br><span class="line">          <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">              catalog = BootLoader.getServicesCatalog();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              catalog = ServicesCatalog.getServicesCatalog(loader);</span><br><span class="line">          &#125;</span><br><span class="line">          catalog.addProvider(m, service, impl);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (layer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// update Layer catalog</span></span><br><span class="line">          JLA.getServicesCatalog(layer).addProvider(m, service, impl);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后我们可以从<code>sun.instrument.InstrumentationImpl</code>这个类来看到其工作方式(通过其注释就可以看到这个类和JVM相关):</p><p>在加载模块的时候就执行了下面的代码，看下面<code>update provides</code>这个注释的代码可以知道其调用了上面的<code>addProvides</code>这个方法，而最后也是调用了<code>addProvider(m, service, impl)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Java side of the JPLIS implementation. Works in concert with a native JVMTI agent</span></span><br><span class="line"><span class="comment"> * to implement the JPLIS API set. Provides both the Java API implementation of</span></span><br><span class="line"><span class="comment"> * the Instrumentation interface and utility Java routines to support the native code.</span></span><br><span class="line"><span class="comment"> * Keeps a pointer to the native data structure in a scalar field to allow native</span></span><br><span class="line"><span class="comment"> * processing behind native methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationImpl</span> <span class="keyword">implements</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redefineModule</span><span class="params">(Module <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Set&lt;Module&gt; extraReads,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Map&lt;String, Set&lt;Module&gt;&gt; extraExports,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Map&lt;String, Set&lt;Module&gt;&gt; extraOpens,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Set&lt;Class&lt;?&gt;&gt; extraUses,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; extraProvides)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">module</span>.isNamed())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isModifiableModule(<span class="keyword">module</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnmodifiableModuleException(<span class="keyword">module</span>.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy and check reads</span></span><br><span class="line">        extraReads = <span class="keyword">new</span> HashSet&lt;&gt;(extraReads);</span><br><span class="line">        <span class="keyword">if</span> (extraReads.contains(<span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"'extraReads' contains null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy and check exports and opens</span></span><br><span class="line">        extraExports = cloneAndCheckMap(<span class="keyword">module</span>, extraExports);</span><br><span class="line">        extraOpens = cloneAndCheckMap(<span class="keyword">module</span>, extraOpens);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy and check uses</span></span><br><span class="line">        extraUses = <span class="keyword">new</span> HashSet&lt;&gt;(extraUses);</span><br><span class="line">        <span class="keyword">if</span> (extraUses.contains(<span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"'extraUses' contains null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy and check provides</span></span><br><span class="line">        Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; tmpProvides = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; e : extraProvides.entrySet()) &#123;</span><br><span class="line">            Class&lt;?&gt; service = e.getKey();</span><br><span class="line">            <span class="keyword">if</span> (service == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"'extraProvides' contains null"</span>);</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; providers = <span class="keyword">new</span> ArrayList&lt;&gt;(e.getValue());</span><br><span class="line">            <span class="keyword">if</span> (providers.isEmpty())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"list of providers is empty"</span>);</span><br><span class="line">            providers.forEach(p -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.getModule() != <span class="keyword">module</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(p + <span class="string">" not in "</span> + <span class="keyword">module</span>);</span><br><span class="line">                <span class="keyword">if</span> (!service.isAssignableFrom(p))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(p + <span class="string">" is not a "</span> + service);</span><br><span class="line">            &#125;);</span><br><span class="line">            tmpProvides.put(service, providers);</span><br><span class="line">        &#125;</span><br><span class="line">        extraProvides = tmpProvides;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// update reads</span></span><br><span class="line">        extraReads.forEach(m -&gt; Modules.addReads(<span class="keyword">module</span>, m));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update exports</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;Module&gt;&gt; e : extraExports.entrySet()) &#123;</span><br><span class="line">            String pkg = e.getKey();</span><br><span class="line">            Set&lt;Module&gt; targets = e.getValue();</span><br><span class="line">            targets.forEach(m -&gt; Modules.addExports(<span class="keyword">module</span>, pkg, m));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update opens</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;Module&gt;&gt; e : extraOpens.entrySet()) &#123;</span><br><span class="line">            String pkg = e.getKey();</span><br><span class="line">            Set&lt;Module&gt; targets = e.getValue();</span><br><span class="line">            targets.forEach(m -&gt; Modules.addOpens(<span class="keyword">module</span>, pkg, m));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update uses</span></span><br><span class="line">        extraUses.forEach(service -&gt; Modules.addUses(<span class="keyword">module</span>, service));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update provides</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; e : extraProvides.entrySet()) &#123;</span><br><span class="line">            Class&lt;?&gt; service = e.getKey();</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; providers = e.getValue();</span><br><span class="line">            providers.forEach(p -&gt; Modules.addProvides(<span class="keyword">module</span>, service, p));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Instrumentation</code>接口有一段很重要的注释，大家自己看吧，就不多说了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class provides services needed to instrument Java</span></span><br><span class="line"><span class="comment"> * programming language code.</span></span><br><span class="line"><span class="comment"> * Instrumentation is the addition of byte-codes to methods for the</span></span><br><span class="line"><span class="comment"> * purpose of gathering data to be utilized by tools.</span></span><br><span class="line"><span class="comment"> * Since the changes are purely additive, these tools do not modify</span></span><br><span class="line"><span class="comment"> * application state or behavior.</span></span><br><span class="line"><span class="comment"> * Examples of such benign tools include monitoring agents, profilers,</span></span><br><span class="line"><span class="comment"> * coverage analyzers, and event loggers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;P&gt;</span></span><br><span class="line"><span class="comment"> * There are two ways to obtain an instance of the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Instrumentation&lt;/code&gt; interface:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; When a JVM is launched in a way that indicates an agent</span></span><br><span class="line"><span class="comment"> *     class. In that case an &lt;code&gt;Instrumentation&lt;/code&gt; instance</span></span><br><span class="line"><span class="comment"> *     is passed to the &lt;code&gt;premain&lt;/code&gt; method of the agent class.</span></span><br><span class="line"><span class="comment"> *     &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; When a JVM provides a mechanism to start agents sometime</span></span><br><span class="line"><span class="comment"> *     after the JVM is launched. In that case an &lt;code&gt;Instrumentation&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> *     instance is passed to the &lt;code&gt;agentmain&lt;/code&gt; method of the</span></span><br><span class="line"><span class="comment"> *     agent code. &lt;/p&gt; &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * These mechanisms are described in the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> java.lang.instrument package specification&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Once an agent acquires an &lt;code&gt;Instrumentation&lt;/code&gt; instance,</span></span><br><span class="line"><span class="comment"> * the agent may call methods on the instance at any time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们最后，走入<code>addProvider(m, service, impl)</code>这个方法中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add a provider in the given module to this services catalog</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiNote</span> This method is for use by java.lang.instrument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProvider</span><span class="params">(Module <span class="keyword">module</span>, Class&lt;?&gt; service, Class&lt;?&gt; impl)</span> </span>&#123;</span><br><span class="line">        List&lt;ServiceProvider&gt; list = providers(service.getName());</span><br><span class="line">        list.add(<span class="keyword">new</span> ServiceProvider(<span class="keyword">module</span>, impl.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Module <span class="keyword">module</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String providerName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceProvider</span><span class="params">(Module <span class="keyword">module</span>, String providerName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">module</span> = <span class="keyword">module</span>;</span><br><span class="line">            <span class="keyword">this</span>.providerName = providerName;</span><br><span class="line">        &#125;</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再经过了这么曲曲折折的过程，终于拿到了<code>ServiceProvider</code>,里面包括了我们所要调用实现类的地址信息</p><p>于是，看下ServiceLoader这个类定义的<code>Provider</code>静态内部接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Represents a service provider located by &#123;<span class="doctag">@code</span> ServiceLoader&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; When using a loader's &#123;<span class="doctag">@link</span> ServiceLoader#stream() stream()&#125; method</span></span><br><span class="line"><span class="comment">   * then the elements are of type &#123;<span class="doctag">@code</span> Provider&#125;. This allows processing</span></span><br><span class="line"><span class="comment">   * to select or filter on the provider class without instantiating the</span></span><br><span class="line"><span class="comment">   * provider. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  &lt;S&gt; The service type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@spec</span> JPMS</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span>&lt;<span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">Supplier</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Returns the provider type. There is no guarantee that this type is</span></span><br><span class="line"><span class="comment">       * accessible or that it has a public no-args constructor. The &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">       * #get() get()&#125; method should be used to obtain the provider instance.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;p&gt; When a module declares that the provider class is created by a</span></span><br><span class="line"><span class="comment">       * provider factory then this method returns the return type of its</span></span><br><span class="line"><span class="comment">       * public static "&#123;<span class="doctag">@code</span> provider()&#125;" method.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> The provider type</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      Class&lt;? extends S&gt; type();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Returns an instance of the provider.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> An instance of the provider.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@throws</span> ServiceConfigurationError</span></span><br><span class="line"><span class="comment">       *         If the service provider cannot be instantiated, or in the</span></span><br><span class="line"><span class="comment">       *         case of a provider factory, the public static</span></span><br><span class="line"><span class="comment">       *         "&#123;<span class="doctag">@code</span> provider()&#125;" method returns &#123;<span class="doctag">@code</span> null&#125; or throws</span></span><br><span class="line"><span class="comment">       *         an error or exception. The &#123;<span class="doctag">@code</span> ServiceConfigurationError&#125;</span></span><br><span class="line"><span class="comment">       *         will carry an appropriate cause where possible.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Override</span> <span class="function">S <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后我们回到之前追到的<code>iteratorFor</code>方法，知道其返回的是 <code>Iterator&lt;ServiceProvider&gt;</code>类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns an iterator to iterate over the implementations of &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">        * service&#125; in modules defined to the given class loader or in custom</span></span><br><span class="line"><span class="comment">        * layers with a module defined to this class loader.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> Iterator&lt;ServiceProvider&gt; <span class="title">iteratorFor</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// modules defined to the class loader</span></span><br><span class="line">           ServicesCatalog catalog;</span><br><span class="line">           <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">               catalog = BootLoader.getServicesCatalog();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               catalog = ServicesCatalog.getServicesCatalogOrNull(loader);</span><br><span class="line">           &#125;</span><br><span class="line">           List&lt;ServiceProvider&gt; providers;</span><br><span class="line">           <span class="keyword">if</span> (catalog == <span class="keyword">null</span>) &#123;</span><br><span class="line">               providers = List.of();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               providers = catalog.findServices(serviceName);</span><br><span class="line">           &#125;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p> 然后回到<code>ModuleServicesLookupIterator()</code>这个构造函数，直接看这个内部类,也就是调用这个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements lazy service provider lookup of service providers that</span></span><br><span class="line"><span class="comment">    * are provided by modules defined to a class loader or to modules in</span></span><br><span class="line"><span class="comment">    * layers with a module defined to the class loader.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleServicesLookupIterator</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Provider</span>&lt;<span class="title">T</span>&gt;&gt;</span></span><br><span class="line"><span class="class">   </span>&#123;</span><br><span class="line">       ClassLoader currentLoader;</span><br><span class="line">       Iterator&lt;ServiceProvider&gt; iterator;</span><br><span class="line"></span><br><span class="line">       Provider&lt;T&gt; nextProvider;</span><br><span class="line">       ServiceConfigurationError nextError;</span><br><span class="line"></span><br><span class="line">       ModuleServicesLookupIterator() &#123;</span><br><span class="line">           <span class="keyword">this</span>.currentLoader = loader;</span><br><span class="line">           <span class="keyword">this</span>.iterator = iteratorFor(loader);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>newLookupIterator</code>这个方法中得到<code>ModuleServicesLookupIterator</code>的实例<code>first</code>,并调用其<code>hasNext</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a new lookup iterator.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Iterator&lt;Provider&lt;S&gt;&gt; newLookupIterator() &#123;</span><br><span class="line">       <span class="keyword">assert</span> layer == <span class="keyword">null</span> || loader == <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (layer != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> LayerLookupIterator&lt;&gt;();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Iterator&lt;Provider&lt;S&gt;&gt; first = <span class="keyword">new</span> ModuleServicesLookupIterator&lt;&gt;();</span><br><span class="line">           Iterator&lt;Provider&lt;S&gt;&gt; second = <span class="keyword">new</span> LazyClassPathLookupIterator&lt;&gt;();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Provider&lt;S&gt;&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> (first.hasNext() || second.hasNext());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Provider&lt;S&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">if</span> (first.hasNext()) &#123;</span><br><span class="line">                       <span class="keyword">return</span> first.next();</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (second.hasNext()) &#123;</span><br><span class="line">                       <span class="keyword">return</span> second.next();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>我们来进入这个<code>hasNext</code>方法，也就是在这里，调用了<code>loadProvider</code>生成了一个bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (nextProvider == <span class="keyword">null</span> &amp;&amp; nextError == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// get next provider to load</span></span><br><span class="line">            <span class="keyword">while</span> (!iterator.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    currentLoader = currentLoader.getParent();</span><br><span class="line">                    iterator = iteratorFor(currentLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// attempt to load provider</span></span><br><span class="line">            ServiceProvider provider = iterator.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Provider&lt;T&gt; next = (Provider&lt;T&gt;) loadProvider(provider);</span><br><span class="line">                nextProvider = next;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ServiceConfigurationError e) &#123;</span><br><span class="line">                nextError = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Provider&lt;T&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        Provider&lt;T&gt; provider = nextProvider;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextProvider = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ServiceConfigurationError e = nextError;</span><br><span class="line">            <span class="keyword">assert</span> e != <span class="keyword">null</span>;</span><br><span class="line">            nextError = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>走进这个<code>loadProvider</code>方法,抛开前面所有，我们只看最后返回为:<code>new ProviderImpl&lt;S&gt;(service, type, ctor, acc)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Loads a service provider in a module.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> null&#125; if the service provider's module doesn't read</span></span><br><span class="line"><span class="comment">     * the module with the service type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServiceConfigurationError if the class cannot be loaded or</span></span><br><span class="line"><span class="comment">     *         isn't the expected sub-type (or doesn't define a provider</span></span><br><span class="line"><span class="comment">     *         factory method that returns the expected type)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Provider&lt;S&gt; <span class="title">loadProvider</span><span class="params">(ServiceProvider provider)</span> </span>&#123;</span><br><span class="line">        Module <span class="keyword">module</span> = provider.<span class="keyword">module</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">module</span>.canRead(service.getModule())) &#123;</span><br><span class="line">            <span class="comment">// module does not read the module with the service type</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String cn = provider.providerName();</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(<span class="keyword">module</span>, cn);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LinkageError e) &#123;</span><br><span class="line">                fail(service, <span class="string">"Unable to load "</span> + cn, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt; pa = () -&gt; Class.forName(<span class="keyword">module</span>, cn);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = AccessController.doPrivileged(pa);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                Throwable x = pae.getCause();</span><br><span class="line">                fail(service, <span class="string">"Unable to load "</span> + cn, x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mods = clazz.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(mods)) &#123;</span><br><span class="line">            fail(service, clazz + <span class="string">" is not public"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if provider in explicit module then check for static factory method</span></span><br><span class="line">        <span class="keyword">if</span> (inExplicitModule(clazz)) &#123;</span><br><span class="line">            Method factoryMethod = findStaticProviderMethod(clazz);</span><br><span class="line">            <span class="keyword">if</span> (factoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; returnType = factoryMethod.getReturnType();</span><br><span class="line">                <span class="keyword">if</span> (!service.isAssignableFrom(returnType)) &#123;</span><br><span class="line">                    fail(service, factoryMethod + <span class="string">" return type not a subtype"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Class&lt;? extends S&gt; type = (Class&lt;? extends S&gt;) returnType;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProviderImpl&lt;S&gt;(service, type, factoryMethod, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// no factory method so must be a subtype</span></span><br><span class="line">        <span class="keyword">if</span> (!service.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            fail(service, clazz.getName() + <span class="string">" not a subtype"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Class&lt;? extends S&gt; type = (Class&lt;? extends S&gt;) clazz;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Constructor&lt;? extends S&gt; ctor = (Constructor&lt;? extends S&gt; ) getConstructor(clazz);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProviderImpl&lt;S&gt;(service, type, ctor, acc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后，我们通过查看这个<code>ProviderImpl</code>类终于得到了我们想要得到的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A Provider implementation that supports invoking, with reduced</span></span><br><span class="line"><span class="comment">    * permissions, the static factory to obtain the provider or the</span></span><br><span class="line"><span class="comment">    * provider's no-arg constructor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderImpl</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line">       <span class="keyword">final</span> Class&lt;? extends S&gt; type;</span><br><span class="line">       <span class="keyword">final</span> Method factoryMethod;  <span class="comment">// factory method or null</span></span><br><span class="line">       <span class="keyword">final</span> Constructor&lt;? extends S&gt; ctor; <span class="comment">// public no-args constructor or null</span></span><br><span class="line">       <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">       ProviderImpl(Class&lt;S&gt; service,</span><br><span class="line">                    Class&lt;? extends S&gt; type,</span><br><span class="line">                    Method factoryMethod,</span><br><span class="line">                    AccessControlContext acc) &#123;</span><br><span class="line">           <span class="keyword">this</span>.service = service;</span><br><span class="line">           <span class="keyword">this</span>.type = type;</span><br><span class="line">           <span class="keyword">this</span>.factoryMethod = factoryMethod;</span><br><span class="line">           <span class="keyword">this</span>.ctor = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">this</span>.acc = acc;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ProviderImpl(Class&lt;S&gt; service,</span><br><span class="line">                    Class&lt;? extends S&gt; type,</span><br><span class="line">                    Constructor&lt;? extends S&gt; ctor,</span><br><span class="line">                    AccessControlContext acc) &#123;</span><br><span class="line">           <span class="keyword">this</span>.service = service;</span><br><span class="line">           <span class="keyword">this</span>.type = type;</span><br><span class="line">           <span class="keyword">this</span>.factoryMethod = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">this</span>.ctor = ctor;</span><br><span class="line">           <span class="keyword">this</span>.acc = acc;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Class&lt;? extends S&gt; type() &#123;</span><br><span class="line">           <span class="keyword">return</span> type;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> S <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (factoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> invokeFactoryMethod();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> newInstance();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>IOC和模块化所提供的类似效果的最大的区别就是，前者是提供了实例化的bean(即便是通过AOP实现的，这点很重要，Java9模块化在使用Spring的时候会有特别的设置)，而且是基于Spring容器的单例的存在(多例注入的问题请参考我这方面的Spring源码解析)，后者是提供了class字节码所在的路径，用的时候内部会自行生成实例，所以是多例的。</p><p>其实整个过程，Java的模块化文件系统起了很大的作用(这块看情况假如篇幅比较长久不放在我的书里了)，然后自己追源码的思路也在这里给大家展现了一番，希望可以对大家有所帮助，看源码不要上来就瞎找的。另外，最重要的一点就是，不要因为源码很多，很复杂就轻言放弃，看的多了，看的久了，自然就有一套属于自己的方法论了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Refresh-your-Java-skills–聊聊Java9-中模块化设计是如何实现类似IOC依赖注入效果及与其区别&quot;&gt;&lt;a href=&quot;#Refresh-your-Java-skills–聊聊Java9-中模块化设计是如何实现类似IOC依赖注入效果及与其区别&quot; class=&quot;headerlink&quot; title=&quot;Refresh your Java skills–聊聊Java9 中模块化设计是如何实现类似IOC依赖注入效果及与其区别&quot;&gt;&lt;/a&gt;Refresh your Java skills–聊聊Java9 中模块化设计是如何实现类似IOC依赖注入效果及与其区别&lt;/h1&gt;&lt;h2 id=&quot;场景引入&quot;&gt;&lt;a href=&quot;#场景引入&quot; class=&quot;headerlink&quot; title=&quot;场景引入&quot;&gt;&lt;/a&gt;场景引入&lt;/h2&gt;&lt;p&gt;如何实现IOC的效果，我们可以来想想，无非就是一个隐式实现，而想要做到，总不能什么都没有，来个巧妇难为无米之炊的境地吧，所以说，米必须要有滴，在Spring中就是一个bean，也就是说，容器里得有米，再官话点就是上下文中得存在所需要的bean。同样模块化中两个互相隔离的模块想要达到这种效果，也要先往jvm里扔个对象进去的，然后&lt;strong&gt;who use ，who get&lt;/strong&gt; 就可以了。&lt;br&gt;
    
    </summary>
    
      <category term="Java9" scheme="https://muyinchen.github.io/categories/Java9/"/>
    
    
      <category term="Java" scheme="https://muyinchen.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring5源码解析-Spring中的异步和计划任务</title>
    <link href="https://muyinchen.github.io/2017/10/17/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"/>
    <id>https://muyinchen.github.io/2017/10/17/Spring5源码解析-Spring中的异步和计划任务/</id>
    <published>2017-10-16T17:10:25.000Z</published>
    <updated>2017-10-16T17:16:47.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring5源码解析-Spring中的异步和计划任务"><a href="#Spring5源码解析-Spring中的异步和计划任务" class="headerlink" title="Spring5源码解析-Spring中的异步和计划任务"></a>Spring5源码解析-Spring中的异步和计划任务</h1><p>Java提供了许多创建线程池的方式，并得到一个Future实例来作为任务结果。对于Spring同样小菜一碟，通过其<code>scheduling</code>包就可以做到将任务线程中后台执行。</p><p>在本文的第一部分中，我们将讨论下Spring中执行计划任务的一些基础知识。之后，我们将解释这些类是如何一起协作来启动并执行计划任务的。下一部分将介绍计划和异步任务的配置。最后，我们来写个Demo，看看如何通过单元测试来编排计划任务。<br><a id="more"></a></p><h2 id="什么是Spring中的异步任务？"><a href="#什么是Spring中的异步任务？" class="headerlink" title="什么是Spring中的异步任务？"></a>什么是Spring中的异步任务？</h2><p>在我们正式的进入话题之前，对于Spring，我们需要理解下它实现的两个不同的概念：异步任务和调度任务。显然，两者有一个很大的共同点：都在后台工作。但是，它们之间存在了很大差异。调度任务与异步不同，其作用与Linux中的<code>CRON job</code>完全相同(windows里面也有计划任务)。举个栗子，有一个任务必须每40分钟执行一次，那么，可以通过XML文件或者注解来进行此配置。简单的异步任务在后台执行就好，无需配置执行频率。</p><p>因为它们是两种不同的任务类型，它们两个的执行者自然也就不同。第一个看起来有点像Java的并发执行器(<code>concurrency executor</code>)，这里会有专门去写一篇关于Java中的执行器来具体了解。根据<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#scheduling" target="_blank" rel="noopener">Spring文档</a><strong>TaskExecutor</strong>所述，它提供了基于Spring的抽象来处理线程池，这点，也可以通过其类的注释去了解。另一个抽象接口是<strong>TaskScheduler</strong>，它用于在将来给定的时间点来安排任务，并执行一次或定期执行。</p><p>在分析源码的过程中，发现另一个比较有趣的点是触发器。它存在两种类型：<strong>CronTrigger</strong>或<strong>PeriodTrigger</strong>。第一个模拟CRON任务的行为。所以我们可以在将来确切时间点提交一个任务的执行。另一个触发器可用于定期执行任务。</p><h2 id="Spring的异步任务类"><a href="#Spring的异步任务类" class="headerlink" title="Spring的异步任务类"></a>Spring的异步任务类</h2><p>让我们从<strong>org.springframework.core.task.TaskExecutor</strong>类的分析开始。你会发现，其简单的不行，它是一个扩展Java的Executor接口的接口。它的唯一方法也就是是<strong>执行</strong>，在参数中使用Runnable类型的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple task executor interface that abstracts the execution</span></span><br><span class="line"><span class="comment"> * of a &#123;<span class="doctag">@link</span> Runnable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations can use all sorts of different execution strategies,</span></span><br><span class="line"><span class="comment"> * such as: synchronous, asynchronous, using a thread pool, and more.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Equivalent to JDK 1.5's &#123;<span class="doctag">@link</span> java.util.concurrent.Executor&#125;</span></span><br><span class="line"><span class="comment"> * interface; extending it now in Spring 3.0, so that clients may declare</span></span><br><span class="line"><span class="comment"> * a dependency on an Executor and receive any TaskExecutor implementation.</span></span><br><span class="line"><span class="comment"> * This interface remains separate from the standard Executor interface</span></span><br><span class="line"><span class="comment"> * mainly for backwards compatibility with JDK 1.4 in Spring 2.x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.util.concurrent.Executor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskExecutor</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the given &#123;<span class="doctag">@code</span> task&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The call might return immediately if the implementation uses</span></span><br><span class="line"><span class="comment"> * an asynchronous execution strategy, or might block in the case</span></span><br><span class="line"><span class="comment"> * of synchronous execution.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the &#123;<span class="doctag">@code</span> Runnable&#125; to execute (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> TaskRejectedException if the given task was not accepted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对来说，<strong>org.springframework.scheduling.TaskScheduler</strong>接口就有点复杂了。它定义了一组以schedule开头的名称的方法允许我们定义将来要执行的任务。所有 <strong>schedule* </strong>方法返回<strong>java.util.concurrent.ScheduledFuture</strong>实例。Spring5中对<code>scheduleAtFixedRate</code>方法做了进一步的充实，其实最终调用的还是<strong>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, long period);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskScheduler</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Schedule the given &#123;<span class="doctag">@link</span> Runnable&#125;, invoking it whenever the trigger</span></span><br><span class="line"><span class="comment"> * indicates a next execution time.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Execution will end once the scheduler shuts down or the returned</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ScheduledFuture&#125; gets cancelled.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the Runnable to execute whenever the trigger fires</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> trigger an implementation of the &#123;<span class="doctag">@link</span> Trigger&#125; interface,</span></span><br><span class="line"><span class="comment"> * e.g. a &#123;<span class="doctag">@link</span> org.springframework.scheduling.support.CronTrigger&#125; object</span></span><br><span class="line"><span class="comment"> * wrapping a cron expression</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> ScheduledFuture&#125; representing pending completion of the task,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if the given Trigger object never fires (i.e. returns</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; from &#123;<span class="doctag">@link</span> Trigger#nextExecutionTime&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> org.springframework.core.task.TaskRejectedException if the given task was not accepted</span></span><br><span class="line"><span class="comment"> * for internal reasons (e.g. a pool overload handling policy or a pool shutdown in progress)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.scheduling.support.CronTrigger</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">ScheduledFuture&lt;?&gt; schedule(Runnable task, Trigger trigger);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Schedule the given &#123;<span class="doctag">@link</span> Runnable&#125;, invoking it at the specified execution time.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Execution will end once the scheduler shuts down or the returned</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ScheduledFuture&#125; gets cancelled.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the Runnable to execute whenever the trigger fires</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startTime the desired execution time for the task</span></span><br><span class="line"><span class="comment"> * (if this is in the past, the task will be executed immediately, i.e. as soon as possible)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> ScheduledFuture&#125; representing pending completion of the task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> org.springframework.core.task.TaskRejectedException if the given task was not accepted</span></span><br><span class="line"><span class="comment"> * for internal reasons (e.g. a pool overload handling policy or a pool shutdown in progress)</span></span><br><span class="line"><span class="comment"> * 使用了默认实现，值得我们学习使用的，Java9中同样可以有私有实现的，从这里我们可以做到我只通过 * 一个接口你来实现，我把其他相应的功能默认实现下，最后调用你自定义实现的接口即可，使接口功能更  * 加一目了然</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #schedule(Runnable, Date)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> ScheduledFuture&lt;?&gt; schedule(Runnable task, Instant startTime) &#123;</span><br><span class="line"><span class="keyword">return</span> schedule(task, Date.from(startTime));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Schedule the given &#123;<span class="doctag">@link</span> Runnable&#125;, invoking it at the specified execution time.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Execution will end once the scheduler shuts down or the returned</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ScheduledFuture&#125; gets cancelled.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the Runnable to execute whenever the trigger fires</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startTime the desired execution time for the task</span></span><br><span class="line"><span class="comment"> * (if this is in the past, the task will be executed immediately, i.e. as soon as possible)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> ScheduledFuture&#125; representing pending completion of the task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> org.springframework.core.task.TaskRejectedException if the given task was not accepted</span></span><br><span class="line"><span class="comment"> * for internal reasons (e.g. a pool overload handling policy or a pool shutdown in progress)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScheduledFuture&lt;?&gt; schedule(Runnable task, Date startTime);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Schedule the given &#123;<span class="doctag">@link</span> Runnable&#125;, invoking it at the specified execution time</span></span><br><span class="line"><span class="comment"> * and subsequently with the given period.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Execution will end once the scheduler shuts down or the returned</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ScheduledFuture&#125; gets cancelled.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the Runnable to execute whenever the trigger fires</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startTime the desired first execution time for the task</span></span><br><span class="line"><span class="comment"> * (if this is in the past, the task will be executed immediately, i.e. as soon as possible)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> period the interval between successive executions of the task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> ScheduledFuture&#125; representing pending completion of the task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> org.springframework.core.task.TaskRejectedException if  the given task was not accepted</span></span><br><span class="line"><span class="comment"> * for internal reasons (e.g. a pool overload handling policy or a pool shutdown in progress)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #scheduleAtFixedRate(Runnable, Date, long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, Instant startTime, Duration period) &#123;</span><br><span class="line"><span class="keyword">return</span> scheduleAtFixedRate(task, Date.from(startTime), period.toMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Schedule the given &#123;<span class="doctag">@link</span> Runnable&#125;, invoking it at the specified execution time</span></span><br><span class="line"><span class="comment"> * and subsequently with the given period.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Execution will end once the scheduler shuts down or the returned</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ScheduledFuture&#125; gets cancelled.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the Runnable to execute whenever the trigger fires</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startTime the desired first execution time for the task</span></span><br><span class="line"><span class="comment"> * (if this is in the past, the task will be executed immediately, i.e. as soon as possible)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> period the interval between successive executions of the task (in milliseconds)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> ScheduledFuture&#125; representing pending completion of the task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> org.springframework.core.task.TaskRejectedException if  the given task was not accepted</span></span><br><span class="line"><span class="comment"> * for internal reasons (e.g. a pool overload handling policy or a pool shutdown in progress)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, Date startTime, <span class="keyword">long</span> period);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前提到两个触发器组件，都实现了<strong>org.springframework.scheduling.Trigger</strong>接口。这里，我们只需关注一个的方法<strong>nextExecutionTime</strong> ，其定义下一个触发任务的执行时间。它的两个实现，CronTrigger和PeriodicTrigger，由<strong>org.springframework.scheduling.TriggerContext</strong>来实现信息的存储，由此，我们可以很轻松获得一个任务的最后一个执行时间(<strong>lastScheduledExecutionTime</strong>)，给定任务的最后完成时间(<strong>lastCompletionTime</strong>)或最后一个实际执行时间(<strong>lastActualExecutionTime</strong>)。接下来，我们通过阅读源代码来简单的了解下这些东西。<strong>org.springframework.scheduling.concurrent.ConcurrentTaskScheduler</strong>包含一个私有类<code>EnterpriseConcurrentTriggerScheduler</code>。在这个<code>class</code>里面，我们可以找到schedule方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable task, <span class="keyword">final</span> Trigger trigger) &#123;</span><br><span class="line">  ManagedScheduledExecutorService executor = (ManagedScheduledExecutorService) scheduledExecutor;</span><br><span class="line">  <span class="keyword">return</span> executor.schedule(task, <span class="keyword">new</span> javax.enterprise.concurrent.Trigger() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getNextRunTime</span><span class="params">(LastExecution le, Date taskScheduledTime)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> trigger.nextExecutionTime(le != <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">new</span> SimpleTriggerContext(le.getScheduledStart(), le.getRunStart(), le.getRunEnd()) :</span><br><span class="line">        <span class="keyword">new</span> SimpleTriggerContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">skipRun</span><span class="params">(LastExecution lastExecution, Date scheduledRunTime)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleTriggerContext</code>从其名字就可以看到很多东西了，因为它实现了<code>TriggerContext</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple data holder implementation of the &#123;<span class="doctag">@link</span> TriggerContext&#125; interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTriggerContext</span> <span class="keyword">implements</span> <span class="title">TriggerContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Date lastScheduledExecutionTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Date lastActualExecutionTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Date lastCompletionTime;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a SimpleTriggerContext with the given time values.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lastScheduledExecutionTime last &lt;i&gt;scheduled&lt;/i&gt; execution time</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lastActualExecutionTime last &lt;i&gt;actual&lt;/i&gt; execution time</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lastCompletionTime last completion time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleTriggerContext</span><span class="params">(Date lastScheduledExecutionTime, Date lastActualExecutionTime, Date lastCompletionTime)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lastScheduledExecutionTime = lastScheduledExecutionTime;</span><br><span class="line"><span class="keyword">this</span>.lastActualExecutionTime = lastActualExecutionTime;</span><br><span class="line"><span class="keyword">this</span>.lastCompletionTime = lastCompletionTime;</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也正如你看到的，在构造函数中设置的时间值来自<strong>javax.enterprise.concurrent.LastExecution的</strong>实现，其中： </p><ul><li>getScheduledStart：返回上次开始执行任务的时间。它对应于TriggerContext的lastScheduledExecutionTime属性。 </li><li>getRunStart：返回给定任务开始运行的时间。在TriggerContext中，它对应于lastActualExecutionTime。 </li><li>getRunEnd：任务终止时返回。它用于在TriggerContext中设置lastCompletionTime。</li></ul><p>Spring调度和异步执行中的另一个重要类是<strong>org.springframework.core.task.support.TaskExecutorAdapter</strong>。它是一个将<strong>java.util.concurrent.Executor</strong>作为Spring基本的执行器的适配器(描述的有点拗口,看下面代码就明了了)，之前已经描述了<code>TaskExecutor</code>。实际上，它引用了Java的ExecutorService，它也是继承了<code>Executor</code>接口。此引用用于完成所有提交的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adapter that takes a JDK &#123;<span class="doctag">@code</span> java.util.concurrent.Executor&#125; and</span></span><br><span class="line"><span class="comment"> * exposes a Spring &#123;<span class="doctag">@link</span> org.springframework.core.task.TaskExecutor&#125; for it.</span></span><br><span class="line"><span class="comment"> * Also detects an extended &#123;<span class="doctag">@code</span> java.util.concurrent.ExecutorService 从此解释上面的说明&#125;, adapting</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> org.springframework.core.task.AsyncTaskExecutor&#125; interface accordingly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.util.concurrent.Executor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.util.concurrent.ExecutorService </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.util.concurrent.Executors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorAdapter</span> <span class="keyword">implements</span> <span class="title">AsyncListenableTaskExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor concurrentExecutor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> TaskDecorator taskDecorator;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new TaskExecutorAdapter,</span></span><br><span class="line"><span class="comment"> * using the given JDK concurrent executor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> concurrentExecutor the JDK concurrent executor to delegate to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TaskExecutorAdapter</span><span class="params">(Executor concurrentExecutor)</span> </span>&#123;</span><br><span class="line">Assert.notNull(concurrentExecutor, <span class="string">"Executor must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.concurrentExecutor = concurrentExecutor;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegates to the specified JDK concurrent executor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.util.concurrent.Executor#execute(Runnable)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">doExecute(<span class="keyword">this</span>.concurrentExecutor, <span class="keyword">this</span>.taskDecorator, task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(</span><br><span class="line"><span class="string">"Executor ["</span> + <span class="keyword">this</span>.concurrentExecutor + <span class="string">"] did not accept task: "</span> + task, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">long</span> startTimeout)</span> </span>&#123;</span><br><span class="line">execute(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.taskDecorator == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.concurrentExecutor <span class="keyword">instanceof</span> ExecutorService) &#123;</span><br><span class="line"><span class="keyword">return</span> ((ExecutorService) <span class="keyword">this</span>.concurrentExecutor).submit(task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">FutureTask&lt;Object&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(task, <span class="keyword">null</span>);</span><br><span class="line">doExecute(<span class="keyword">this</span>.concurrentExecutor, <span class="keyword">this</span>.taskDecorator, future);</span><br><span class="line"><span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(</span><br><span class="line"><span class="string">"Executor ["</span> + <span class="keyword">this</span>.concurrentExecutor + <span class="string">"] did not accept task: "</span> + task, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Spring中配置异步和计划任务"><a href="#在Spring中配置异步和计划任务" class="headerlink" title="在Spring中配置异步和计划任务"></a>在Spring中配置异步和计划任务</h2><p>下面我们通过代码的方式来实现异步任务。首先，我们需要通过注解来启用配置。它的XML配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"taskScheduler"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"taskExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"taskExecutor"</span> <span class="attr">scheduler</span>=<span class="string">"taskScheduler"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.migo.async"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过将<code>@EnableScheduling</code>和<code>@EnableAsync</code>注解添加到配置类(用@Configuration注解)来激活两者。完事，我们就可以开始着手实现调度和异步任务。为了实现调度任务，我们可以使用<code>@Scheduled</code>注解。我们可以从<strong>org.springframework.scheduling.annotation</strong>包中找到这个注解。它包含了以下几个属性： </p><ul><li><p><code>cron</code>：使用<code>CRON</code>风格(Linux配置定时任务的风格)的配置来配置需要启动的带注解的任务。 </p></li><li><p><code>zone</code>：要解析<code>CRON</code>表达式的时区。 </p></li><li><p><code>fixedDelay</code>或<code>fixedDelayString</code>：在固定延迟时间后执行任务。即任务将在最后一次调用结束和下一次调用的开始之间的这个固定时间段后执行。 </p></li><li><p><code>fixedRate</code>或<code>fixedRateString</code>：使用<code>fixedRate</code>注解的方法的调用将以固定的时间段(例如：每10秒钟)进行，与执行生命周期(开始，结束)无关。 </p></li><li><p><code>initialDelay</code>或<code>initialDelayString</code>：延迟首次执行调度方法的时间。请注意，所有值(<strong>fixedDelay </strong>，<strong>fixedRate </strong>，<strong>initialDelay</strong> <strong>)必须以毫秒表示。 </strong> <strong>需要特别记住的是</strong> ，用@Scheduled注解的方法不能接受任何参数，并且不返回任何内容(void)，如果有返回值，返回值也会被忽略掉的，没什么卵用。定时任务方法由容器管理，而不是由调用者在运行时调用。它们由 <strong>org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor</strong>来解析，其中包含以下方法来拒绝执行所有不正确定义的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processScheduled</span><span class="params">(Scheduled scheduled, Method method, Object bean)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Assert.isTrue(method.getParameterCount() == <span class="number">0</span>,</span><br><span class="line"><span class="string">"Only no-arg methods may be annotated with @Scheduled"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   之前的版本中直接把返回值非空的给拒掉了，在Spring 4.3 Spring5 的版本中就没那么严格了</span></span><br><span class="line"><span class="comment">    * Assert.isTrue(void.class.equals(method.getReturnType()),</span></span><br><span class="line"><span class="comment">     *               "Only void-returning methods may be annotated with <span class="doctag">@Scheduled</span>");</span></span><br><span class="line"><span class="comment">     **/</span>               </span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释很重要</span></span><br><span class="line"><span class="comment"> * An annotation that marks a method to be scheduled. Exactly one of</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #cron()&#125;, &#123;<span class="doctag">@link</span> #fixedDelay()&#125;, or &#123;<span class="doctag">@link</span> #fixedRate()&#125;</span></span><br><span class="line"><span class="comment"> * attributes must be specified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The annotated method must expect no arguments. It will typically have</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@code</span> void&#125; return type; if not, the returned value will be ignored</span></span><br><span class="line"><span class="comment"> * when called through the scheduler.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Processing of &#123;<span class="doctag">@code</span> <span class="doctag">@Scheduled</span>&#125; annotations is performed by</span></span><br><span class="line"><span class="comment"> * registering a &#123;<span class="doctag">@link</span> ScheduledAnnotationBeanPostProcessor&#125;. This can be</span></span><br><span class="line"><span class="comment"> * done manually or, more conveniently, through the &#123;<span class="doctag">@code</span> &lt;task:annotation-driven/&gt;&#125;</span></span><br><span class="line"><span class="comment"> * element or @&#123;<span class="doctag">@link</span> EnableScheduling&#125; annotation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This annotation may be used as a &lt;em&gt;meta-annotation&lt;/em&gt; to create custom</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;composed annotations&lt;/em&gt; with attribute overrides.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Fisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableScheduling</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ScheduledAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Schedules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Schedules.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scheduled &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul><p>使用<code>@Async</code>注解标记一个方法或一个类(通过标记一个类，我们自动将其所有方法标记为异步)。与<code>@Scheduled</code>不同，异步任务可以接受参数，并可能返回某些东西。</p><h2 id="写一个在Spring中执行异步任务的Demo"><a href="#写一个在Spring中执行异步任务的Demo" class="headerlink" title="写一个在Spring中执行异步任务的Demo"></a>写一个在Spring中执行异步任务的Demo</h2><p>有了上面这些知识，我们可以来编写异步和计划任务。我们将通过测试用例来展示。我们从不同的任务执行器(task executors)的测试开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations=&#123;<span class="string">"classpath:applicationContext-test.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorsTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpeAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * SimpleAsyncTaskExecutor creates new Thread for every task and executes it asynchronously. The threads aren't reused as in </span></span><br><span class="line"><span class="comment">      * native Java's thread pools.</span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * The number of concurrently executed threads can be specified through concurrencyLimit bean property </span></span><br><span class="line"><span class="comment">      * (concurrencyLimit XML attribute). Here it's more simple to invoke setConcurrencyLimit method. </span></span><br><span class="line"><span class="comment">      * Here the tasks will be executed by 2 simultaneous threads. Without specifying this value,</span></span><br><span class="line"><span class="comment">      * the number of executed threads will be indefinite.</span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * You can observe that only 2 tasks are executed at a given time - even if 3 are submitted to execution (lines 40-42).</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">    SimpleAsyncTaskExecutor executor = <span class="keyword">new</span> SimpleAsyncTaskExecutor(<span class="string">"thread_name_prefix_____"</span>);</span><br><span class="line">    executor.setConcurrencyLimit(<span class="number">2</span>);</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"SimpleAsyncTask-1"</span>, Counters.simpleAsyncTask, <span class="number">1000</span>));</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"SimpleAsyncTask-2"</span>, Counters.simpleAsyncTask, <span class="number">1000</span>));</span><br><span class="line"> </span><br><span class="line">    Thread.sleep(<span class="number">1050</span>);</span><br><span class="line">    assertTrue(<span class="string">"2 threads should be terminated, but "</span>+Counters.simpleAsyncTask.getNb()+<span class="string">" were instead"</span>, Counters.simpleAsyncTask.getNb() == <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"SimpleAsyncTask-3"</span>, Counters.simpleAsyncTask, <span class="number">1000</span>));</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"SimpleAsyncTask-4"</span>, Counters.simpleAsyncTask, <span class="number">1000</span>));</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"SimpleAsyncTask-5"</span>, Counters.simpleAsyncTask, <span class="number">2000</span>));</span><br><span class="line">     </span><br><span class="line">    Thread.sleep(<span class="number">1050</span>);</span><br><span class="line">    assertTrue(<span class="string">"4 threads should be terminated, but "</span>+Counters.simpleAsyncTask.getNb()+<span class="string">" were instead"</span>, Counters.simpleAsyncTask.getNb() == <span class="number">4</span>);</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"SimpleAsyncTask-6"</span>, Counters.simpleAsyncTask, <span class="number">1000</span>));</span><br><span class="line"> </span><br><span class="line">    Thread.sleep(<span class="number">1050</span>);</span><br><span class="line">    assertTrue(<span class="string">"6 threads should be terminated, but "</span>+Counters.simpleAsyncTask.getNb()+<span class="string">" were instead"</span>, </span><br><span class="line">      Counters.simpleAsyncTask.getNb() == <span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTaskTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * SyncTask works almost as Java's CountDownLatch. In fact, this executor is synchronous with the calling thread. In our case,</span></span><br><span class="line"><span class="comment">      * SyncTaskExecutor tasks will be synchronous with JUnit thread. It means that the testing thread will sleep 5 </span></span><br><span class="line"><span class="comment">      * seconds after executing the third task ('SyncTask-3'). To prove that, we check if the total execution time is ~5 seconds.</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    SyncTaskExecutor executor = <span class="keyword">new</span> SyncTaskExecutor();</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"SyncTask-1"</span>, Counters.syncTask, <span class="number">0</span>));</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"SyncTask-2"</span>, Counters.syncTask, <span class="number">0</span>));</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"SyncTask-3"</span>, Counters.syncTask, <span class="number">0</span>));</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"SyncTask-4"</span>, Counters.syncTask, <span class="number">5000</span>));</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"SyncTask-5"</span>, Counters.syncTask, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">int</span> execTime = Math.round((end-start)/<span class="number">1000</span>);</span><br><span class="line">    assertTrue(<span class="string">"Execution time should be 5 seconds but was "</span>+execTime+<span class="string">" seconds"</span>, execTime == <span class="number">5</span>); </span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadPoolTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * This executor can be used to expose Java's native ThreadPoolExecutor as Spring bean, with the </span></span><br><span class="line"><span class="comment">      * possibility to set core pool size, max pool size and queue capacity through bean properties.</span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * It works exactly as ThreadPoolExecutor from java.util.concurrent package. It means that our pool starts </span></span><br><span class="line"><span class="comment">      * with 2 threads (core pool size) and can be growth until 3 (max pool size).</span></span><br><span class="line"><span class="comment">      * In additionally, 1 task can be stored in the queue. This task will be treated </span></span><br><span class="line"><span class="comment">      * as soon as one from 3 threads ends to execute provided task. In our case, we try to execute 5 tasks</span></span><br><span class="line"><span class="comment">      * in 3 places pool and 1 place queue. So the 5th task should be rejected and TaskRejectedException should be thrown.</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">    ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">    executor.setCorePoolSize(<span class="number">2</span>);</span><br><span class="line">    executor.setMaxPoolSize(<span class="number">3</span>);</span><br><span class="line">    executor.setQueueCapacity(<span class="number">1</span>);</span><br><span class="line">    executor.initialize();</span><br><span class="line"> </span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"ThreadPoolTask-1"</span>, Counters.threadPool, <span class="number">1000</span>));</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"ThreadPoolTask-2"</span>, Counters.threadPool, <span class="number">1000</span>));</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"ThreadPoolTask-3"</span>, Counters.threadPool, <span class="number">1000</span>));</span><br><span class="line">    executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"ThreadPoolTask-4"</span>, Counters.threadPool, <span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">boolean</span> wasTre = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor.execute(<span class="keyword">new</span> SimpleTask(<span class="string">"ThreadPoolTask-5"</span>, Counters.threadPool, <span class="number">1000</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TaskRejectedException tre) &#123;</span><br><span class="line">      wasTre = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assertTrue(<span class="string">"The last task should throw a TaskRejectedException but it wasn't"</span>, wasTre);</span><br><span class="line"> </span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"> </span><br><span class="line">    assertTrue(<span class="string">"4 tasks should be terminated, but "</span>+Counters.threadPool.getNb()+<span class="string">" were instead"</span>, </span><br><span class="line">      Counters.threadPool.getNb()==<span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Counters counter;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sleepTime;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleTask</span><span class="params">(String name, Counters counter, <span class="keyword">int</span> sleepTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.counter = counter;</span><br><span class="line">    <span class="keyword">this</span>.sleepTime = sleepTime;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="keyword">this</span>.sleepTime);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.counter.increment();</span><br><span class="line">    System.out.println(<span class="string">"Running task '"</span>+<span class="keyword">this</span>.name+<span class="string">"' in Thread "</span>+Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"Task &#123;"</span>+<span class="keyword">this</span>.name+<span class="string">"&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> Counters &#123;</span><br><span class="line">         </span><br><span class="line">  simpleAsyncTask(<span class="number">0</span>),</span><br><span class="line">  syncTask(<span class="number">0</span>),</span><br><span class="line">  threadPool(<span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> nb;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.nb;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nb++;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Counters</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nb = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在过去，我们可以有更多的执行器可以使用(SimpleThreadPoolTaskExecutor，TimerTaskExecutor 这些都2.x 3.x的老古董了)。但都被弃用并由本地Java的执行器取代成为Spring的首选。看看输出的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Running task <span class="string">'SimpleAsyncTask-1'</span> in Thread thread_name_prefix_____1</span><br><span class="line">Running task <span class="string">'SimpleAsyncTask-2'</span> in Thread thread_name_prefix_____2</span><br><span class="line">Running task <span class="string">'SimpleAsyncTask-3'</span> in Thread thread_name_prefix_____3</span><br><span class="line">Running task <span class="string">'SimpleAsyncTask-4'</span> in Thread thread_name_prefix_____4</span><br><span class="line">Running task <span class="string">'SimpleAsyncTask-5'</span> in Thread thread_name_prefix_____5</span><br><span class="line">Running task <span class="string">'SimpleAsyncTask-6'</span> in Thread thread_name_prefix_____6</span><br><span class="line">Running task <span class="string">'SyncTask-1'</span> in Thread main</span><br><span class="line">Running task <span class="string">'SyncTask-2'</span> in Thread main</span><br><span class="line">Running task <span class="string">'SyncTask-3'</span> in Thread main</span><br><span class="line">Running task <span class="string">'SyncTask-4'</span> in Thread main</span><br><span class="line">Running task <span class="string">'SyncTask-5'</span> in Thread main</span><br><span class="line">Running task <span class="string">'ThreadPoolTask-2'</span> in Thread ThreadPoolTaskExecutor-<span class="number">2</span></span><br><span class="line">Running task <span class="string">'ThreadPoolTask-1'</span> in Thread ThreadPoolTaskExecutor-<span class="number">1</span></span><br><span class="line">Running task <span class="string">'ThreadPoolTask-4'</span> in Thread ThreadPoolTaskExecutor-<span class="number">3</span></span><br><span class="line">Running task <span class="string">'ThreadPoolTask-3'</span> in Thread ThreadPoolTaskExecutor-<span class="number">2</span></span><br></pre></td></tr></table></figure><p>以此我们可以推断出，第一个测试为每个任务创建新的线程。通过使用不同的线程名称，我们可以看到相应区别。第二个，同步执行器，应该执行所调用线程中的任务。这里可以看到’main’是主线程的名称，它的主线程调用执行同步所有任务。最后一种例子涉及最大可创建3个线程的线程池。从结果可以看到，他们也确实只有3个创建线程。</p><p>现在，我们将编写一些单元测试来看看@Async和@Scheduled实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations=&#123;<span class="string">"classpath:applicationContext-test.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> GenericApplicationContext context;</span><br><span class="line">         </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testScheduled</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">"Start sleeping"</span>);</span><br><span class="line">      Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">      System.out.println(<span class="string">"Wake up !"</span>);</span><br><span class="line"> </span><br><span class="line">      TestScheduledTask scheduledTask = (TestScheduledTask) context.getBean(<span class="string">"testScheduledTask"</span>);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Test fixed delay. It's executed every 6 seconds. The first execution is registered after application's context start. </span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">      assertTrue(<span class="string">"Scheduled task should be executed 2 times (1 before sleep in this method, 1 after the sleep), but was "</span>+scheduledTask.getFixedDelayCounter(), </span><br><span class="line">        scheduledTask.getFixedDelayCounter() == <span class="number">2</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Test fixed rate. It's executed every 6 seconds. The first execution is registered after application's context start. </span></span><br><span class="line"><span class="comment">        * Unlike fixed delay, a fixed rate configuration executes one task with specified time. For example, it will execute on </span></span><br><span class="line"><span class="comment">        * 6 seconds delayed task at 10:30:30, 10:30:36, 10:30:42 and so on - even if the task 10:30:30 taken 30 seconds to </span></span><br><span class="line"><span class="comment">        * be terminated. In teh case of fixed delay, if the first task takes 30 seconds, the next will be executed 6 seconds </span></span><br><span class="line"><span class="comment">        * after the first one, so the execution flow will be: 10:30:30, 10:31:06, 10:31:12.</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">      assertTrue(<span class="string">"Scheduled task should be executed 2 times (1 before sleep in this method, 1 after the sleep), but was "</span>+scheduledTask.getFixedRateCounter(), </span><br><span class="line">        scheduledTask.getFixedRateCounter() == <span class="number">2</span>);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Test fixed rate with initial delay attribute. The initialDelay attribute is set to 6 seconds. It causes that </span></span><br><span class="line"><span class="comment">        * scheduled method is executed 6 seconds after application's context start. In our case, it should be executed </span></span><br><span class="line"><span class="comment">        * only once because of previous Thread.sleep(6000) invocation.</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">      assertTrue(<span class="string">"Scheduled task should be executed 1 time (0 before sleep in this method, 1 after the sleep), but was "</span>+scheduledTask.getInitialDelayCounter(), scheduledTask.getInitialDelayCounter() == <span class="number">1</span>);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Test cron scheduled task. Cron is scheduled to be executed every 6 seconds. It's executed only once, </span></span><br><span class="line"><span class="comment">        * so we can deduce that it's not invoked directly before applications </span></span><br><span class="line"><span class="comment">        * context start, but only after configured time (6 seconds in our case).</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">      assertTrue(<span class="string">"Scheduled task should be executed 1 time (0 before sleep in this method, 1 after the sleep), but was "</span>+scheduledTask.getCronCounter(), scheduledTask.getCronCounter() == <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">         </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyc</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * To test <span class="doctag">@Async</span> annotation, we can create a bean in-the-fly. AsyncCounter bean is a</span></span><br><span class="line"><span class="comment">        * simple counter which value should be equals to 2 at the end of the test. A supplementary test</span></span><br><span class="line"><span class="comment">        * concerns threads which execute both of AsyncCounter methods: one which </span></span><br><span class="line"><span class="comment">        * isn't annotated with <span class="doctag">@Async</span> and another one which is annotated with it. For the first one, invoking</span></span><br><span class="line"><span class="comment">        * thread should have the same name as the main thread. For annotated method, it can't be executed in </span></span><br><span class="line"><span class="comment">        * the main thread. It must be executed asynchrounously in a new thread.</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">      context.registerBeanDefinition(<span class="string">"asyncCounter"</span>, <span class="keyword">new</span> RootBeanDefinition(AsyncCounter.class));</span><br><span class="line">       </span><br><span class="line">      String currentName = Thread.currentThread().getName();</span><br><span class="line">      AsyncCounter asyncCounter = context.getBean(<span class="string">"asyncCounter"</span>, AsyncCounter.class);</span><br><span class="line">      asyncCounter.incrementNormal();</span><br><span class="line">      assertTrue(<span class="string">"Thread executing normal increment should be the same as JUnit thread but it wasn't (expected '"</span>+currentName+<span class="string">"', got '"</span>+asyncCounter.getNormalThreadName()+<span class="string">"')"</span>,</span><br><span class="line">                      asyncCounter.getNormalThreadName().equals(currentName));</span><br><span class="line">      asyncCounter.incrementAsync();</span><br><span class="line">      <span class="comment">// sleep 50ms and give some time to AsyncCounter to update asyncThreadName value</span></span><br><span class="line">      Thread.sleep(<span class="number">50</span>);</span><br><span class="line"> </span><br><span class="line">      assertFalse(<span class="string">"Thread executing @Async increment shouldn't be the same as JUnit thread but it wasn (JUnit thread '"</span>+currentName+<span class="string">"', @Async thread '"</span>+asyncCounter.getAsyncThreadName()+<span class="string">"')"</span>,</span><br><span class="line">                      asyncCounter.getAsyncThreadName().equals(currentName));</span><br><span class="line">      System.out.println(<span class="string">"Main thread execution's name: "</span>+currentName);</span><br><span class="line">      System.out.println(<span class="string">"AsyncCounter normal increment thread execution's name: "</span>+asyncCounter.getNormalThreadName());</span><br><span class="line">      System.out.println(<span class="string">"AsyncCounter @Async increment thread execution's name: "</span>+asyncCounter.getAsyncThreadName());</span><br><span class="line">      assertTrue(<span class="string">"Counter should be 2, but was "</span>+asyncCounter.getCounter(), asyncCounter.getCounter()==<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncCounter</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> String normalThreadName;</span><br><span class="line">  <span class="keyword">private</span> String asyncThreadName;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    normalThreadName = Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">this</span>.counter++;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Async</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    asyncThreadName = Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">this</span>.counter++;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAsyncThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncThreadName;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNormalThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> normalThreadName;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.counter;</span><br><span class="line">  &#125;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们需要创建新的配置文件和一个包含定时任务方法的类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- imported configuration file first --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Activates various annotations to be detected in bean classes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- Scans the classpath for annotated components that will be auto-registered as Spring beans.</span></span><br><span class="line"><span class="comment"> For example @Controller and @Service. Make sure to set the correct base-package--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.migo.test.schedulers"</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"taskScheduler"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"taskExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"40"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"taskExecutor"</span> <span class="attr">scheduler</span>=<span class="string">"taskScheduler"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scheduled methods after, all are executed every 6 seconds (scheduledAtFixedRate and scheduledAtFixedDelay start to execute at</span></span><br><span class="line"><span class="comment">// application context start, two other methods begin 6 seconds after application's context start)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScheduledTask</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> fixedRateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> fixedDelayCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> initialDelayCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> cronCounter = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Scheduled</span>(fixedRate = <span class="number">6000</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledAtFixedRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"&lt;R&gt; Increment at fixed rate"</span>);</span><br><span class="line">    fixedRateCounter++;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">6000</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledAtFixedDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"&lt;D&gt; Incrementing at fixed delay"</span>);</span><br><span class="line">    fixedDelayCounter++;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">6000</span>, initialDelay = <span class="number">6000</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledWithInitialDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"&lt;DI&gt; Incrementing with initial delay"</span>);</span><br><span class="line">    initialDelayCounter++;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Scheduled</span>(cron = <span class="string">"**/6 ** ** ** ** **"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledWithCron</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"&lt;C&gt; Incrementing with cron"</span>);</span><br><span class="line">    cronCounter++;</span><br><span class="line">           </span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFixedRateCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fixedRateCounter;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFixedDelayCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fixedDelayCounter;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInitialDelayCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.initialDelayCounter;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCronCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cronCounter;</span><br><span class="line">  &#125;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该测试的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Increment at fixed rate</span><br><span class="line">&lt;D&gt; Incrementing at fixed delay</span><br><span class="line">Start sleeping</span><br><span class="line">&lt;C&gt; Incrementing with cron</span><br><span class="line">&lt;DI&gt; Incrementing with initial delay</span><br><span class="line">&lt;R&gt; Increment at fixed rate</span><br><span class="line">&lt;D&gt; Incrementing at fixed delay</span><br><span class="line">Wake up !</span><br><span class="line">Main thread execution<span class="string">'s name: main</span></span><br><span class="line"><span class="string">AsyncCounter normal increment thread execution'</span>s name: main</span><br><span class="line">AsyncCounter <span class="meta">@Async</span> increment thread execution<span class="string">'s name: taskExecutor-1</span></span><br></pre></td></tr></table></figure><p>本文向我们介绍了关于Spring框架另一个大家比较感兴趣的功能–定时任务。我们可以看到，与Linux CRON风格配置类似，这些任务同样可以按照固定的频率进行定时任务的设置。我们还通过例子证明了使用@Async注解的方法会在不同线程中执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring5源码解析-Spring中的异步和计划任务&quot;&gt;&lt;a href=&quot;#Spring5源码解析-Spring中的异步和计划任务&quot; class=&quot;headerlink&quot; title=&quot;Spring5源码解析-Spring中的异步和计划任务&quot;&gt;&lt;/a&gt;Spring5源码解析-Spring中的异步和计划任务&lt;/h1&gt;&lt;p&gt;Java提供了许多创建线程池的方式，并得到一个Future实例来作为任务结果。对于Spring同样小菜一碟，通过其&lt;code&gt;scheduling&lt;/code&gt;包就可以做到将任务线程中后台执行。&lt;/p&gt;
&lt;p&gt;在本文的第一部分中，我们将讨论下Spring中执行计划任务的一些基础知识。之后，我们将解释这些类是如何一起协作来启动并执行计划任务的。下一部分将介绍计划和异步任务的配置。最后，我们来写个Demo，看看如何通过单元测试来编排计划任务。&lt;br&gt;
    
    </summary>
    
      <category term="基础" scheme="https://muyinchen.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Spring" scheme="https://muyinchen.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Refresh your Java skills--Java中的即时编译(Just-in-time compilation)</title>
    <link href="https://muyinchen.github.io/2017/10/10/Refresh%20your%20Java%20skills--Java%E4%B8%AD%E7%9A%84%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/"/>
    <id>https://muyinchen.github.io/2017/10/10/Refresh your Java skills--Java中的即时编译/</id>
    <published>2017-10-10T10:00:25.000Z</published>
    <updated>2017-10-10T10:44:38.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Refresh-your-Java-skills–Java中的即时编译-Just-in-time-compilation"><a href="#Refresh-your-Java-skills–Java中的即时编译-Just-in-time-compilation" class="headerlink" title="Refresh your Java skills–Java中的即时编译(Just-in-time compilation)"></a>Refresh your Java skills–Java中的即时编译(Just-in-time compilation)</h1><p>因自己在写的关于Java9的新书因为篇幅和读者层次的原因并不能将能想到的东西都写进去，故接下来整理出一系列的博文来补充拓展。</p><p>像其他一些编程语言一样，Java通常也被称为“编译语言”。但有时你可能会感到困惑，尤其是当有人告诉你Java是JIT编译，并问你其中的一些小细节时。</p><p>本文就来说一说JIT编译的概念。在第一部分，我们将对不同类型的编译描述一番。第二部分来说说JIT编译。接下来，我们将深入一下JIT编译在Java中比较特别的地方。<br><a id="more"></a></p><h2 id="编译类型"><a href="#编译类型" class="headerlink" title="编译类型"></a>编译类型</h2><p>在讨论编译类型之前，我们需要了解什么是编译。这是一个将编程语言翻译成机器可理解的语言(也称为<strong>机器代码</strong>)的过程。机器语言由CPU执行的指令组成。这个语言是由0-1构成的，如在<a href="http://en.wikibooks.org/wiki/A-level_Computing/AQA/Computer_Components,_The_Stored_Program_Concept_and_the_Internet/Machine_Level_Architecture/Machine_code_and_processor_instruction_set" target="_blank" rel="noopener">wikibooks页面</a>上的这个片段所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0001</span> <span class="number">00000111</span></span><br><span class="line"><span class="number">0100</span> <span class="number">00001001</span></span><br><span class="line"><span class="number">0000</span> <span class="number">00011110</span></span><br></pre></td></tr></table></figure><h2 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h2><p>同样，我们知道，Java的<strong>javac</strong>指令不会生成机器代码，而是一些名为<strong>字节码的</strong>东西。而这不仅仅是一种语言会这么做(而这也是很多现代语言所发展的一个方向)。比如ActionScript(由ActionScript Virtual Machine执行)或CIL(由C#使用并在Common Language Runtime上执行)。</p><p>在这里，在我们的括号中所说的“执行”，也就是即时编译完成(即字节码编译成目标机器可执行的机器码)。这种特殊类型的编译发生在解释给定字节码的机器上，如ActionScript虚拟机或Java虚拟机(JVM)。字节码由他们在运行时( on runtime)编译成机器码。</p><p>这种编译带来了一些好处。第一个显着的优点是可以做到根据所运行机器参数来优化编译的代码。静态编译器为目标机器进行优化并一次生成机器代码。另一方面，JIT编译器提供了一种中间代码，它被转换和优化为特定于执行机器的机器代码。关于这里有一篇解释的比较通俗的文章<a href="http://www.cnblogs.com/csxf/p/3387365.html" target="_blank" rel="noopener">动态编译和静态编译及Java执行</a>，有兴趣可以看看</p><p>第二个优点是便携性。转换为字节码的代码可以在安装了虚拟机的任何计算机上运行。</p><h2 id="Java中的即时编译"><a href="#Java中的即时编译" class="headerlink" title="Java中的即时编译"></a>Java中的即时编译</h2><p>So，Java是即时编译为机器代码的。想要检查编译机器代码，我们可以启用多个JVM参数：</p><ul><li><p>-XX：+ PrintCompilation</p><p>通过这个参数，我们可以得到方法编译结果的输出。其输出的样例：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">71</span> <span class="number">1</span> java.lang.String :: indexOf(<span class="number">70</span> bytes)</span><br><span class="line"><span class="number">73</span> <span class="number">2</span> sun.nio.cs.UTF_8 $ Encoder :: encode(<span class="number">361</span> bytes)</span><br><span class="line"><span class="number">87</span> <span class="number">3</span> java.lang.String :: hashCode(<span class="number">55</span> bytes)</span><br></pre></td></tr></table></figure><ul><li><p>输出被格式化为列，第一列(例如71)是时间戳。第二列返回唯一的编译器任务ID(1，2，3 …)。之后我们可以看到编译的方法。在括号中指定了编译字节码的字节。我们可以看到indexOf方法的大小是70字节，encode 方法是361字节等等。</p></li><li><p>-XX：+ UnlockDiagnosticVMOptions</p><p>一个简单的标志，JVM诊断的补充选项。</p></li><li><p>-XX：+ PrintInlining</p><p>通过这个配置，我们可以看到编译方法的细节。内联是编译器优化编译代码重要的工作方式。请看以下方法：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  callAnotherMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过内联，函数<code>callAnotherMethod()</code>将被<code>callAnotherMethod</code>的内容替换。正因为如此，在运行时，机器不会从一个方法跳转到另一个方法，并能够以<code>内联方式</code>执行代码。JIT通过此操作用来避免在堆栈上放置参数的复杂情况。当我们启用此参数(+PrintInlining)并运行代码时，我们可以看到类似下面的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">75</span> <span class="number">1</span> java.lang.String :: indexOf(<span class="number">70</span> bytes)</span><br><span class="line"><span class="number">77</span> <span class="number">2</span> sun.nio.cs.UTF_8 $ Encoder :: encode(<span class="number">361</span> bytes)</span><br><span class="line">                    @ <span class="number">66</span> java.lang.String :: indexOfSupplementary(<span class="number">71</span> bytes) too big</span><br><span class="line">                    @ <span class="number">14</span> java.lang.Math :: min(<span class="number">11</span> bytes)(intrinsic)</span><br><span class="line">                    @ <span class="number">139</span> java.lang.Character :: isSurrogate(<span class="number">18</span> bytes) never executed</span><br><span class="line"><span class="number">89</span> <span class="number">3</span> java.lang.String :: hashCode(<span class="number">55</span> bytes)</span><br></pre></td></tr></table></figure><p>让我们回到理论层面面，Java中的JIT编译(这里说是动态编译)可以是(这里可以参考一篇文章<br> <a href="http://blog.csdn.net/sunxianghuang/article/details/52094859" target="_blank" rel="noopener">JVM即时编译（JIT）</a>，我这里用更加暴力通俗的方式说了下，能知道是个什么作用就可以)： </p><ul><li>lazy：只有真正使用的方法(在运行时调用)才会被编译成机器代码。 </li><li>adaptive(自适应)：整个程序被编译成一些脏机器代码。此代码仅针对非常常用的方法进行了优化。</li></ul><p>已经编译的字节码存储到<strong>代码缓存中</strong>。这是一个结构，所有编译的方法。当再次调用给定方法时，它不会从头开始编译，而是从代码缓存中加载。但是，当编译器认为可以更好地优化此方法时，缓存方法可以被覆盖。在优化技术中，我们可以通过以下区分： </p><ul><li>内联：在前面的描述中可以知道，可以避免方法跳跃。 </li><li>垃圾代码(称之死代码更恰当)：当某些对象存在于字节码中且不被使用时，编译器可以决定从机器代码中删除它们。 </li><li>循环优化：编译器可以组织并优化循环执行顺序或对尾递归优化成for循环等，以此来优化CPU所执行的代码。 </li><li>用实现方法替换接口方法：当给定接口的一个方法有且仅由一个对象实现时，编译器可以决定直接使用实现的方法，以避免在运行时绑定真正实现的方法所引起的开销。</li></ul><p>在本文中，我们解释了即时编译，即特定用于语言的编译代码(如Java的字节码)转换为CPU可以理解的语言(机器代码)。编译器不会进行简单的编译，因为它也对编译代码进行了一些优化。由于这些优化，机器代码尽可能地适应目标机器，另外，可以根据<a href="http://blog.csdn.net/opensure/article/details/46715675这篇文章中的两张图来更好的理解下上面所说的一些细节。" target="_blank" rel="noopener">http://blog.csdn.net/opensure/article/details/46715675这篇文章中的两张图来更好的理解下上面所说的一些细节。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Refresh-your-Java-skills–Java中的即时编译-Just-in-time-compilation&quot;&gt;&lt;a href=&quot;#Refresh-your-Java-skills–Java中的即时编译-Just-in-time-compilation&quot; class=&quot;headerlink&quot; title=&quot;Refresh your Java skills–Java中的即时编译(Just-in-time compilation)&quot;&gt;&lt;/a&gt;Refresh your Java skills–Java中的即时编译(Just-in-time compilation)&lt;/h1&gt;&lt;p&gt;因自己在写的关于Java9的新书因为篇幅和读者层次的原因并不能将能想到的东西都写进去，故接下来整理出一系列的博文来补充拓展。&lt;/p&gt;
&lt;p&gt;像其他一些编程语言一样，Java通常也被称为“编译语言”。但有时你可能会感到困惑，尤其是当有人告诉你Java是JIT编译，并问你其中的一些小细节时。&lt;/p&gt;
&lt;p&gt;本文就来说一说JIT编译的概念。在第一部分，我们将对不同类型的编译描述一番。第二部分来说说JIT编译。接下来，我们将深入一下JIT编译在Java中比较特别的地方。&lt;br&gt;
    
    </summary>
    
      <category term="Java9" scheme="https://muyinchen.github.io/categories/Java9/"/>
    
    
      <category term="Java" scheme="https://muyinchen.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring5源码解析-Spring中的异步事件</title>
    <link href="https://muyinchen.github.io/2017/09/28/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6/"/>
    <id>https://muyinchen.github.io/2017/09/28/Spring5源码解析-Spring中的异步事件/</id>
    <published>2017-09-28T04:00:25.000Z</published>
    <updated>2017-09-28T04:11:56.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring5源码解析-Spring中的异步事件"><a href="#Spring5源码解析-Spring中的异步事件" class="headerlink" title="Spring5源码解析-Spring中的异步事件"></a>Spring5源码解析-Spring中的异步事件</h1><p>上一篇 <a href="https://muyinchen.github.io/2017/09/27/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/">Spring框架中的事件和监听器</a>并未对Spring框架中的异步事件涉及太多，所以本篇是对其一个补充。</p><p>同步事件有一个主要缺点：它们在所调用线程的本地执行(也就是将所调用线程看成主线程的话，就是在主线程里依次执行)。如果监听器处理同步事件需要5秒钟的响应，则最终结果是用户将在至少5秒内无法看到响应(可以通过<a href="https://muyinchen.github.io/2017/09/27/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/">Spring框架中的事件和监听器</a>中的例子了解具体)。所以，我们可以通过一个替代方案来解决这个问题 - 异步事件。</p><p>接下来也就是介绍Spring框架中的异步事件。老规矩，第一部分深入框架源码，将描述主要组成部分以及它们如何一起协作的。在第二部分，我们将编写一些测试用例来检查异步事件的执行情况。</p><a id="more"></a><h2 id="Spring中的异步事件"><a href="#Spring中的异步事件" class="headerlink" title="Spring中的异步事件"></a>Spring中的异步事件</h2><p>在Spring中处理异步事件是基于本地的Java并发解决方案—任务执行器(可以了解下Java Executor框架的内容)。事件由<strong>multicastEvent</strong> 方法调度。它通过使用<strong>java.util.concurrent.Executor</strong>接口的实现将事件发送到专用的监听器。Multicaster会调用同步执行器，因为它是默认实现，这点在<a href="https://muyinchen.github.io/2017/09/27/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/">Spring框架中的事件和监听器</a>有明确的例子，从源码的角度也就是是否设置有<code>SyncTaskExecutor</code>实例。从<code>public void setTaskExecutor(@Nullable Executor taskExecutor)</code>其中，@Nullable 可看出Executor参数可为null，默认不设置的话，multicastEvent也就直接 跳过异步执行了</p><p><strong>org.springframework.context.event.SimpleApplicationEventMulticaster</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">multicastEvent(event, resolveDefaultEventType(event));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">Executor executor = getTaskExecutor();</span><br><span class="line"><span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ResolvableType <span class="title">resolveDefaultEventType</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ResolvableType.forInstance(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set a custom executor (typically a &#123;<span class="doctag">@link</span> org.springframework.core.task.TaskExecutor&#125;)</span></span><br><span class="line"><span class="comment"> * to invoke each listener with.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Default is equivalent to &#123;<span class="doctag">@link</span> org.springframework.core.task.SyncTaskExecutor&#125;,</span></span><br><span class="line"><span class="comment"> * executing all listeners synchronously in the calling thread.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Consider specifying an asynchronous task executor here to not block the</span></span><br><span class="line"><span class="comment"> * caller until all listeners have been executed. However, note that asynchronous</span></span><br><span class="line"><span class="comment"> * execution will not participate in the caller's thread context (class loader,</span></span><br><span class="line"><span class="comment"> * transaction association) unless the TaskExecutor explicitly supports this.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.task.SyncTaskExecutor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.task.SimpleAsyncTaskExecutor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Nullable</span> 可看出Executor参数可为null，默认不设置的话，上面multicastEvent也就直接  * 跳过异步执行了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTaskExecutor</span><span class="params">(@Nullable Executor taskExecutor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.taskExecutor = taskExecutor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the current task executor for this multicaster.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Executor <span class="title">getTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.taskExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步执行器的实现可以参考<strong>org.springframework.core.task.SimpleAsyncTaskExecutor</strong>。这个类为每个提交的任务创建新的线程。然而，它不会重用线程，所以如果我们有很多长执行时间的异步任务需要来处理的时候，线程创建的风险就会变得太大了，会占用大量的资源，不光是cpu还包括jvm。具体源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given task, within a concurrency throttle</span></span><br><span class="line"><span class="comment"> * if configured (through the superclass's settings).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doExecute(Runnable)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">execute(task, TIMEOUT_INDEFINITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given task, within a concurrency throttle</span></span><br><span class="line"><span class="comment"> * if configured (through the superclass's settings).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Executes urgent tasks (with 'immediate' timeout) directly,</span></span><br><span class="line"><span class="comment"> * bypassing the concurrency throttle (if active). All other</span></span><br><span class="line"><span class="comment"> * tasks are subject to throttling.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #TIMEOUT_IMMEDIATE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doExecute(Runnable)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">long</span> startTimeout)</span> </span>&#123;</span><br><span class="line">Assert.notNull(task, <span class="string">"Runnable must not be null"</span>);</span><br><span class="line">Runnable taskToUse = (<span class="keyword">this</span>.taskDecorator != <span class="keyword">null</span> ? <span class="keyword">this</span>.taskDecorator.decorate(task) : task);</span><br><span class="line"><span class="keyword">if</span> (isThrottleActive() &amp;&amp; startTimeout &gt; TIMEOUT_IMMEDIATE) &#123;</span><br><span class="line"><span class="keyword">this</span>.concurrencyThrottle.beforeAccess();</span><br><span class="line">doExecute(<span class="keyword">new</span> ConcurrencyThrottlingRunnable(taskToUse));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">doExecute(taskToUse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">     <span class="comment">//创建</span></span><br><span class="line">FutureTask&lt;Object&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(task, <span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">//执行</span></span><br><span class="line">execute(future, TIMEOUT_INDEFINITE);</span><br><span class="line"><span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">FutureTask&lt;T&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(task);</span><br><span class="line">execute(future, TIMEOUT_INDEFINITE);</span><br><span class="line"><span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Template method for the actual execution of a task.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation creates a new Thread and starts it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the Runnable to execute</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setThreadFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #createThread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Thread#start()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doExecute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">Thread thread = (<span class="keyword">this</span>.threadFactory != <span class="keyword">null</span> ? <span class="keyword">this</span>.threadFactory.newThread(task) : createThread(task));</span><br><span class="line">     <span class="comment">//可以看出，执行也只是简单的将创建的线程start执行下，别提什么重用了</span></span><br><span class="line">thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了从线程池功能中受益，我们可以使用另一个Spring的Executor实现，<strong>org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor</strong>。类如其名，这个<code>Executor</code>允许我们使用线程池。关于线程池的源码，请期待我的Java9的书籍，里面会涉及到这里面的细节分析，也可以参考其他博客的博文(哈哈，我就是打个小广告而已)。</p><p><strong>org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the underlying ThreadPoolExecutor for native access.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the underlying ThreadPoolExecutor (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the ThreadPoolTaskExecutor hasn't been initialized yet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">getThreadPoolExecutor</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">Assert.state(<span class="keyword">this</span>.threadPoolExecutor != <span class="keyword">null</span>, <span class="string">"ThreadPoolTaskExecutor not initialized"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.threadPoolExecutor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">Executor executor = getThreadPoolExecutor();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">executor.execute(task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(<span class="string">"Executor ["</span> + executor + <span class="string">"] did not accept task: "</span> + task, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">long</span> startTimeout)</span> </span>&#123;</span><br><span class="line">execute(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">ExecutorService executor = getThreadPoolExecutor();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> executor.submit(task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(<span class="string">"Executor ["</span> + executor + <span class="string">"] did not accept task: "</span> + task, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写一个Spring中异步事件的例子"><a href="#写一个Spring中异步事件的例子" class="headerlink" title="写一个Spring中异步事件的例子"></a>写一个Spring中异步事件的例子</h2><p>我们来编写一个能够同时处理同步和异步事件的multicaster。同步事件将使用本地同步调度程序进行调度(SyncTaskExecutor)，异步使用Spring的ThreadPoolTaskExecutor实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下面的注释意思很明显了，不多说了</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> TaskExecutor&#125; implementation that executes each task &lt;i&gt;synchronously&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * in the calling thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Mainly intended for testing scenarios.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Execution in the calling thread does have the advantage of participating</span></span><br><span class="line"><span class="comment"> * in it's thread context, for example the thread context class loader or the</span></span><br><span class="line"><span class="comment"> * thread's current transaction association. That said, in many cases,</span></span><br><span class="line"><span class="comment"> * asynchronous execution will be preferable: choose an asynchronous</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> TaskExecutor&#125; instead for such scenarios.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SimpleAsyncTaskExecutor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTaskExecutor</span> <span class="keyword">implements</span> <span class="title">TaskExecutor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given &#123;<span class="doctag">@code</span> task&#125; synchronously, through direct</span></span><br><span class="line"><span class="comment"> * invocation of it's &#123;<span class="doctag">@link</span> Runnable#run() run()&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the given &#123;<span class="doctag">@code</span> task&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">Assert.notNull(task, <span class="string">"Runnable must not be null"</span>);</span><br><span class="line">task.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们需要为我们的测试用例添加一些bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"syncTaskExecutor"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.core.task.SyncTaskExecutor"</span> /&gt;</span><br><span class="line">&lt;bean id=<span class="string">"asyncTaskExecutor"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span>&gt;</span><br><span class="line">  &lt;!-- <span class="number">10</span> task will be submitted immediately --&gt;</span><br><span class="line">  &lt;property name=<span class="string">"corePoolSize"</span> value=<span class="string">"10"</span> /&gt;</span><br><span class="line">  &lt;!-- If <span class="number">10</span> task are already submitted and treated, we allow to enlarge pool capacity to <span class="number">15</span> (<span class="number">10</span> from core pool size + <span class="number">5</span> from max pool size) --&gt;</span><br><span class="line">  &lt;property name=<span class="string">"maxPoolSize"</span> value=<span class="string">"15"</span> /&gt;</span><br><span class="line">  &lt;!-- Number of tasks that can be placed into waiting queue --&gt;</span><br><span class="line">  &lt;property name=<span class="string">"queueCapacity"</span> value=<span class="string">"10"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;bean id=<span class="string">"applicationEventMulticaster"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.migo.event.SimpleEventMulticaster"</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">"taskExecutor"</span> ref=<span class="string">"syncTaskExecutor"</span> /&gt;</span><br><span class="line">  &lt;property name=<span class="string">"asyncTaskExecutor"</span> ref=<span class="string">"asyncTaskExecutor"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"taskStatsHolder"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.migo.event.TaskStatsHolder"</span> /&gt;</span><br></pre></td></tr></table></figure><p>用于测试任务执行结果的两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskStatsHolder.java</span></span><br><span class="line"><span class="comment">/****</span></span><br><span class="line"><span class="comment"> ** Holder bean for all executed tasks.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskStatsHolder</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, TaskStatData&gt; tasks = <span class="keyword">new</span> HashMap&lt;String, TaskStatData&gt;();</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewTaskStatHolder</span><span class="params">(String key, TaskStatData value)</span> </span>&#123;</span><br><span class="line">    tasks.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> TaskStatData <span class="title">getTaskStatHolder</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// TaskStatData.java</span></span><br><span class="line"><span class="comment">/****</span></span><br><span class="line"><span class="comment"> ** Holder class for all statistic data about already executed tasks.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskStatData</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> executionTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> endTime;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskStatData</span><span class="params">(String threadName, <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">      <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">      <span class="keyword">this</span>.endTime = endTime;</span><br><span class="line">      <span class="keyword">this</span>.executionTime = Math.round((endTime - startTime) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> threadName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getExecutionTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.executionTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStartTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.startTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getEndTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.endTime;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      result.append(<span class="string">"TaskStatData &#123;thread name: "</span>).append(<span class="keyword">this</span>.threadName).append(<span class="string">", start time: "</span>).append(<span class="keyword">new</span> Date(<span class="keyword">this</span>.startTime));</span><br><span class="line">      result.append(<span class="string">", end time: "</span>).append(<span class="keyword">new</span> Date(<span class="keyword">this</span>.endTime)).append(<span class="string">", execution time: "</span>).append(<span class="keyword">this</span>.executionTime).append(<span class="string">" seconds&#125;"</span>);</span><br><span class="line">      <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，这些都是简单对象。我们会使用这些对象来检查我们的假设和执行结果是否相匹配。两个要分发的事件也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProductChangeFailureEvent.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is synchronous event dispatched when one product is modified in the backoffice. </span></span><br><span class="line"><span class="comment"> * When product's modification fails (database, validation problem), this event is dispatched to</span></span><br><span class="line"><span class="comment"> * all listeners. It's synchronous because we want to inform the user that some actions were done </span></span><br><span class="line"><span class="comment"> * after the failure. Otherwise (asynchronous character of event) we shouldn't be able to</span></span><br><span class="line"><span class="comment"> * know if something was done or not after the dispatch.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductChangeFailureEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationContextEvent</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1681426286796814792L</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_KEY = <span class="string">"ProductChangeFailureEvent"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProductChangeFailureEvent</span><span class="params">(ApplicationContext source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// NotifMailDispatchEvent.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Event dispatched asynchronously every time when we want to send a notification mail. </span></span><br><span class="line"><span class="comment"> * Notification mails to send should be stored somewhere (filesystem, database...) but in</span></span><br><span class="line"><span class="comment"> * our case, we'll handle only one notification mail: when one product out-of-stock becomes available again.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifMailDispatchEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationContextEvent</span> <span class="keyword">implements</span> <span class="title">AsyncApplicationEvent</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">9202282810553100778L</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_KEY = <span class="string">"NotifMailDispatchEvent"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NotifMailDispatchEvent</span><span class="params">(ApplicationContext source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而用于处理相应调度事件的监听器也只需要将数据放入<code>TaskStatsHolder实例类</code>中即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProductChangeFailureListener.java</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductChangeFailureListener</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ProductChangeFailureEvent</span>&gt;</span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ProductChangeFailureEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    ((TaskStatsHolder) event.getApplicationContext().getBean(<span class="string">"taskStatsHolder"</span>)).addNewTaskStatHolder(ProductChangeFailureEvent.TASK_KEY, <span class="keyword">new</span> TaskStatData(Thread.currentThread().getName(), start, end));</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// NotifMailDispatchListener.java</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifMailDispatchListener</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">NotifMailDispatchEvent</span>&gt;</span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(NotifMailDispatchEvent event)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// sleep 5 seconds to avoid that two listeners execute at the same moment</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    ((TaskStatsHolder) event.getApplicationContext().getBean(<span class="string">"taskStatsHolder"</span>)).addNewTaskStatHolder(NotifMailDispatchEvent.TASK_KEY, <span class="keyword">new</span> TaskStatData(Thread.currentThread().getName(), start, end));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于测试的controller如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/products/change-failure"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">changeFailure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"I'm modifying the product but a NullPointerException will be thrown"</span>);</span><br><span class="line">      String name = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (name.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// show error message here</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"NullPointerException"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            context.publishEvent(<span class="keyword">new</span> ProductChangeFailureEvent(context));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/products/change-success"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">changeSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Product was correctly changed"</span>);</span><br><span class="line">    context.publishEvent(<span class="keyword">new</span> NotifMailDispatchEvent(context));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations=&#123;<span class="string">"classpath:applicationContext-test.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSyncAsyncEventsTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(<span class="keyword">this</span>.wac).build();</span><br><span class="line">    <span class="comment">// execute both urls simultaneously</span></span><br><span class="line">    mockMvc.perform(get(<span class="string">"/products/change-success"</span>));</span><br><span class="line">    mockMvc.perform(get(<span class="string">"/products/change-failure"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// get stats holder and check if both stats are available:</span></span><br><span class="line">    <span class="comment">// - mail dispatching shouldn't be available because it's executed after a sleep of 5 seconds</span></span><br><span class="line">    <span class="comment">// - product failure should be available because it's executed synchronously, almost immediately (no operations in listeners)</span></span><br><span class="line">    TaskStatsHolder statsHolder = (TaskStatsHolder) <span class="keyword">this</span>.wac.getBean(<span class="string">"taskStatsHolder"</span>);</span><br><span class="line">    TaskStatData mailStatData = statsHolder.getTaskStatHolder(NotifMailDispatchEvent.TASK_KEY);</span><br><span class="line">    TaskStatData productFailureData = statsHolder.getTaskStatHolder(ProductChangeFailureEvent.TASK_KEY);</span><br><span class="line">    assertTrue(<span class="string">"Task for mail dispatching is executed after 5 seconds, so at this moment, it taskStatsHolder shouldn't contain it"</span>, </span><br><span class="line">        mailStatData == <span class="keyword">null</span>);</span><br><span class="line">    assertTrue(<span class="string">"productFailureHolder shouldn't be null but it is"</span>, </span><br><span class="line">        productFailureData != <span class="keyword">null</span>);</span><br><span class="line">    assertTrue(<span class="string">"Product failure listener should be executed within 0 seconds but took "</span>+productFailureData.getExecutionTime()+<span class="string">" seconds"</span>, </span><br><span class="line">        productFailureData.getExecutionTime() == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (mailStatData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mailStatData = statsHolder.getTaskStatHolder(NotifMailDispatchEvent.TASK_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// check mail dispatching stats again, when available</span></span><br><span class="line">    assertTrue(<span class="string">"Now task for mail dispatching should be at completed state"</span>, </span><br><span class="line">        mailStatData != <span class="keyword">null</span>);</span><br><span class="line">    assertTrue(<span class="string">"Task for mail dispatching should take 5 seconds but it took "</span>+mailStatData.getExecutionTime()+<span class="string">" seconds"</span>, </span><br><span class="line">        mailStatData.getExecutionTime() == <span class="number">5</span>);</span><br><span class="line">    assertTrue(<span class="string">"productFailureHolder shouldn't be null but it is"</span>, </span><br><span class="line">        productFailureData != <span class="keyword">null</span>);</span><br><span class="line">    assertTrue(<span class="string">"Product failure listener should be executed within 0 seconds but took "</span>+productFailureData.getExecutionTime()+<span class="string">" seconds"</span>, </span><br><span class="line">        productFailureData.getExecutionTime() == <span class="number">0</span>);</span><br><span class="line">    assertTrue(<span class="string">"Thread executing mail dispatch and product failure listeners shouldn't be the same"</span>, </span><br><span class="line">        !productFailureData.getThreadName().equals(mailStatData.getThreadName()));</span><br><span class="line">    assertTrue(<span class="string">"Thread executing product failure listener ("</span>+productFailureData.getThreadName()+<span class="string">") should be the same as current thread ("</span>+Thread.currentThread().getName()+<span class="string">") but it wasn't"</span>, </span><br><span class="line">        Thread.currentThread().getName().equals(productFailureData.getThreadName()));</span><br><span class="line">    assertTrue(<span class="string">"Thread executing mail dispatch listener ("</span>+mailStatData.getThreadName()+<span class="string">") shouldn't be the same as current thread ("</span>+Thread.currentThread().getName()+<span class="string">") but it was"</span>, </span><br><span class="line">        !Thread.currentThread().getName().equals(mailStatData.getThreadName()));</span><br><span class="line">    <span class="comment">// make some output to see the informations about tasks</span></span><br><span class="line">    System.out.println(<span class="string">"Data about mail notif dispatching event: "</span>+mailStatData);</span><br><span class="line">    System.out.println(<span class="string">"Data about product failure dispatching event: "</span>+productFailureData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因之前整理的笔记此处SimpleEventMulticaster忘了放进去，也懒得去找了，可以通过xml定义去查看下，这个测试用例可以看出两个listener不是由同一个executor启动的，Product failure 监听器由同步执行器执行。因为他们没有做任何操作，几乎立即返回结果。关于邮件调度事件，通过休眠5秒可以得到其执行时间超过Product failure 监听器的执行时间。通过分析输出可以知道，两者在不同的线程中执行，所以由不同的执行器执行(关于这俩执行器的例子可以再搜下相关博文，其实主要还是想表达<code>SyncTaskExecutor</code>是在主线程里执行，而<code>asyncTaskExecutor</code>由线程池里管理的线程执行)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Product was correctly changed</span><br><span class="line">I<span class="string">'m modifying the product but a NullPointerException will be thrown</span></span><br><span class="line"><span class="string">Data about mail notif dispatching event: TaskStatData &#123;thread name: asyncTaskExecutor-1(异步线程), start time: Thu Jun 19 21:14:18 CEST 2016, end time: Thu Jun 19 21:14:23 CEST 2016, execution time: 5 seconds&#125;</span></span><br><span class="line"><span class="string">Data about product failure dispatching event: TaskStatData &#123;thread name: main(主线程), start time: Thu Jun 19 21:14:21 CEST 2016, end time: Thu Jun 19 21:14:21 CEST 2016, execution time: 0 seconds&#125;</span></span><br></pre></td></tr></table></figure><p>本文简单介绍了如何在Spring中处理异步事件。当监听器需要执行很长时间，而我们又不想阻塞应用程序执行，就可以使用异步执行。异步执行可以通过异步执行器(如ThreadPoolTaskExecutor或SimpleAsyncTaskExecutor)实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring5源码解析-Spring中的异步事件&quot;&gt;&lt;a href=&quot;#Spring5源码解析-Spring中的异步事件&quot; class=&quot;headerlink&quot; title=&quot;Spring5源码解析-Spring中的异步事件&quot;&gt;&lt;/a&gt;Spring5源码解析-Spring中的异步事件&lt;/h1&gt;&lt;p&gt;上一篇 &lt;a href=&quot;https://muyinchen.github.io/2017/09/27/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/&quot;&gt;Spring框架中的事件和监听器&lt;/a&gt;并未对Spring框架中的异步事件涉及太多，所以本篇是对其一个补充。&lt;/p&gt;
&lt;p&gt;同步事件有一个主要缺点：它们在所调用线程的本地执行(也就是将所调用线程看成主线程的话，就是在主线程里依次执行)。如果监听器处理同步事件需要5秒钟的响应，则最终结果是用户将在至少5秒内无法看到响应(可以通过&lt;a href=&quot;https://muyinchen.github.io/2017/09/27/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/&quot;&gt;Spring框架中的事件和监听器&lt;/a&gt;中的例子了解具体)。所以，我们可以通过一个替代方案来解决这个问题 - 异步事件。&lt;/p&gt;
&lt;p&gt;接下来也就是介绍Spring框架中的异步事件。老规矩，第一部分深入框架源码，将描述主要组成部分以及它们如何一起协作的。在第二部分，我们将编写一些测试用例来检查异步事件的执行情况。&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="https://muyinchen.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Spring" scheme="https://muyinchen.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
