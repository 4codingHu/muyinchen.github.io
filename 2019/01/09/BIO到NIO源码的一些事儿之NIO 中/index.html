<!doctype html>



  


<html class="theme-next mist use-motion">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Reactor  响应式 Rxjava  Tomcat NIO">





  <link rel="alternate" href="/atom.xml" title="一叶知秋" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2">






<meta name="description" content="前言此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。 关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下: Rxjava源码解读与分享：https://www.bilibili.com/video/av34537840 Reactor源码解读与分享：https://www.bil">
<meta name="keywords" content="Reactor  响应式 Rxjava  Tomcat NIO">
<meta property="og:type" content="article">
<meta property="og:title" content="BIO到NIO源码的一些事儿之NIO 中">
<meta property="og:url" content="https://muyinchen.github.io/2019/01/09/BIO到NIO源码的一些事儿之NIO 中/index.html">
<meta property="og:site_name" content="一叶知秋">
<meta property="og:description" content="前言此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。 关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下: Rxjava源码解读与分享：https://www.bilibili.com/video/av34537840 Reactor源码解读与分享：https://www.bil">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-09T04:00:49.235Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BIO到NIO源码的一些事儿之NIO 中">
<meta name="twitter:description" content="前言此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。 关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下: Rxjava源码解读与分享：https://www.bilibili.com/video/av34537840 Reactor源码解读与分享：https://www.bil">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://muyinchen.github.io/2019/01/09/BIO到NIO源码的一些事儿之NIO 中/">


  <title> BIO到NIO源码的一些事儿之NIO 中 | 一叶知秋 </title>
</head>

<body itemscope="" itemtype="//schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=UA-83014983-1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一叶知秋</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            日程
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                BIO到NIO源码的一些事儿之NIO 中
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-01-09T01:40:25+08:00" content="2019-01-09">
              2019-01-09
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/响应式/" itemprop="url" rel="index">
                    <span itemprop="name">响应式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/01/09/BIO到NIO源码的一些事儿之NIO 中/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/01/09/BIO到NIO源码的一些事儿之NIO 中/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-user"> 本站访客数 </i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>人次
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。</p>
<p>关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:</p>
<p>Rxjava源码解读与分享：<a href="https://www.bilibili.com/video/av34537840" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840</a></p>
<p>Reactor源码解读与分享：<a href="https://www.bilibili.com/video/av35326911" target="_blank" rel="noopener">https://www.bilibili.com/video/av35326911</a></p>
<p>本系列源码解读基于JDK11 api细节可能与其他版本有所差别，请自行解决jdk版本问题。</p>
<a id="more"></a>
<h2 id="Channel解读"><a href="#Channel解读" class="headerlink" title="Channel解读"></a>Channel解读</h2><p>接上一篇<a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a></p>
<h3 id="赋予Channel支持网络socket的能力"><a href="#赋予Channel支持网络socket的能力" class="headerlink" title="赋予Channel支持网络socket的能力"></a>赋予Channel支持网络socket的能力</h3><p>我们最初的目的就是为了增强Socket，基于这个基本需求，没有条件创造条件，于是为了让Channel拥有网络socket的能力，这里定义了一个<code>java.nio.channels.NetworkChannel</code>接口。花不多说，我们来看这个接口的定义:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetworkChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">NetworkChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SocketAddress <span class="title">getLocalAddress</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">NetworkChannel <span class="title">setOption</span><span class="params">(SocketOption&lt;T&gt; name, T value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getOption</span><span class="params">(SocketOption&lt;T&gt; name)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>bind(SocketAddress)</code> 方法将<code>socket</code>绑定到本地 <code>SocketAddress</code>上，通过getLocalAddress()方法返回<code>socket</code>绑定的地址，<br>通过 <code>setOption(SocketOption,Object)</code>和<code>getOption(SocketOption)</code>方法设置和查询<code>socket</code>支持的配置选项。 </p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>接下来我们来看 <code>java.nio.channels.ServerSocketChannel</code>抽象类及其实现类<code>sun.nio.ch.ServerSocketChannelImpl</code>对之实现的细节。<br>首先我们来看其对于bind的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#bind</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="comment">//通过localAddress判断是否已经调用过bind</span></span><br><span class="line">        <span class="keyword">if</span> (localAddress != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlreadyBoundException();</span><br><span class="line">        <span class="comment">//InetSocketAddress(0)表示绑定到本机的所有地址，由操作系统选择合适的端口</span></span><br><span class="line">        InetSocketAddress isa = (local == <span class="keyword">null</span>)</span><br><span class="line">                                ? <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>)</span><br><span class="line">                                : Net.checkAddress(local);</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>)</span><br><span class="line">            sm.checkListen(isa.getPort());</span><br><span class="line">        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">        Net.bind(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">        <span class="comment">//开启监听，s如果参数backlog小于1，默认接受50个连接 </span></span><br><span class="line">        Net.listen(fd, backlog &lt; <span class="number">1</span> ? <span class="number">50</span> : backlog);</span><br><span class="line">        localAddress = Net.localAddress(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们来看看Net中的bind和listen方法是如何实现的。</p>
<h5 id="Net-bind"><a href="#Net-bind" class="headerlink" title="Net.bind"></a>Net.bind</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.Net#bind(java.io.FileDescriptor, java.net.InetAddress, int)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(FileDescriptor fd, InetAddress addr, <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bind(UNSPEC, fd, addr, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ProtocolFamily family, FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                    InetAddress addr, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果传入的协议域不是IPV4而且支持IPV6,则使用ipv6</span></span><br><span class="line">    <span class="keyword">boolean</span> preferIPv6 = isIPv6Available() &amp;&amp;</span><br><span class="line">        (family != StandardProtocolFamily.INET);</span><br><span class="line">    bind0(fd, preferIPv6, exclusiveBind, addr, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">bind0</span><span class="params">(FileDescriptor fd, <span class="keyword">boolean</span> preferIPv6,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">boolean</span> useExclBind, InetAddress addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>bind0为native方法实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_sun_nio_ch_Net_bind0(JNIEnv *env, jclass clazz, jobject fdo, jboolean preferIPv6,</span><br><span class="line">                          jboolean useExclBind, jobject iao, <span class="keyword">int</span> port)</span><br><span class="line">&#123;</span><br><span class="line">    SOCKETADDRESS sa;</span><br><span class="line">    <span class="keyword">int</span> sa_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将java的InetAddress转换为c的struct sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len,</span><br><span class="line">                                  preferIPv6) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//转换失败，方法返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用bind方法:int bind(int sockfd, struct sockaddr* addr, socklen_t addrlen) </span></span><br><span class="line">    rv = NET_Bind(fdval(env, fdo), &amp;sa, sa_len);</span><br><span class="line">    <span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">        handleSocketError(env, errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>socket是用户程序与内核交互信息的枢纽，它自身没有网络协议地址和端口号等信息,在进行网络通信的时候，必须把一个socket与一个地址相关联。<br>很多时候内核会我们自动绑定一个地址，然而有时用户可能需要自己来完成这个绑定的过程，以满足实际应用的需要；<br>最典型的情况是一个服务器进程需要绑定一个众所周知的地址或端口以等待客户来连接。<br>对于客户端，很多时候并不需要调用bind方法，而是由内核自动绑定；</p>
<p><strong>这里要注意</strong>，绑定归绑定，在有连接过来的时候会创建一个新的Socket，然后服务端操作这个新的Socket即可。这里就可以关注<strong>accept</strong>方法了。由<code>sun.nio.ch.ServerSocketChannelImpl#bind</code>最后，我们知道其通过<code>Net.listen(fd, backlog &lt; 1 ? 50 : backlog)</code>开启监听，如果参数backlog小于1，默认接受50个连接。由此，我们来关注下<code>Net.listen</code>方法细节。</p>
<h5 id="Net-listen"><a href="#Net-listen" class="headerlink" title="Net.listen"></a>Net.listen</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.Net#listen</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(FileDescriptor fd, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>可以知道，<code>Net.listen</code>是<code>native</code>方法，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_sun_nio_ch_Net_listen(JNIEnv *env, jclass cl, jobject fdo, jint backlog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (listen(fdval(env, fdo), backlog) &lt; <span class="number">0</span>)</span><br><span class="line">        handleSocketError(env, errno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到底层是调用<code>listen</code>实现的，<code>listen</code>函数在一般在调用<code>bind</code>之后到调用<code>accept</code>之前调用，它的函数原型是：<br><code>int listen(int sockfd, int backlog)</code>返回值：0表示成功， -1表示失败</p>
<p>我们再来关注下bind操作中的其他细节，最开始时的<code>ensureOpen()</code>方法判断:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#ensureOpen</span></span><br><span class="line"><span class="comment">// @throws ClosedChannelException if channel is closed</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> ClosedChannelException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isOpen())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.channels.spi.AbstractInterruptibleChannel#isOpen</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !closed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>socket</code>关闭，则抛出<code>ClosedChannelException</code> 。</p>
<p>我们再来看下<code>Net#checkAddress</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.Net#checkAddress(java.net.SocketAddress)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InetSocketAddress <span class="title">checkAddress</span><span class="params">(SocketAddress sa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sa == <span class="keyword">null</span>)<span class="comment">//地址为空  </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//非InetSocketAddress类型地址 </span></span><br><span class="line">    <span class="keyword">if</span> (!(sa <span class="keyword">instanceof</span> InetSocketAddress))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedAddressTypeException(); <span class="comment">// ## needs arg</span></span><br><span class="line">    InetSocketAddress isa = (InetSocketAddress)sa;</span><br><span class="line">    <span class="comment">//地址不可识别  </span></span><br><span class="line">    <span class="keyword">if</span> (isa.isUnresolved())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnresolvedAddressException(); <span class="comment">// ## needs arg</span></span><br><span class="line">    InetAddress addr = isa.getAddress();</span><br><span class="line">        <span class="comment">//非ip4和ip6地址  </span></span><br><span class="line">    <span class="keyword">if</span> (!(addr <span class="keyword">instanceof</span> Inet4Address || addr <span class="keyword">instanceof</span> Inet6Address))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid address type"</span>);</span><br><span class="line">    <span class="keyword">return</span> isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，bind首先检查<code>ServerSocket</code>是否关闭，是否绑定地址， 如果既没有绑定也没关闭，则检查绑定的<code>socketaddress</code>是否正确或合法； 然后通过Net工具类的<code>bind</code>和<code>listen</code>，完成实际的<code>ServerSocket</code>地址绑定和开启监听，如果绑定是开启的参数小于<code>1</code>，则默认接受<code>50</code>个连接。 </p>
<p>对照我们之前在第一篇中接触的BIO，我们来看些<code>accept()</code>方法的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#accept()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    acceptLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        FileDescriptor newfd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        InetSocketAddress[] isaa = <span class="keyword">new</span> InetSocketAddress[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> blocking = isBlocking();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin(blocking);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                n = accept(<span class="keyword">this</span>.fd, newfd, isaa);</span><br><span class="line">            &#125; <span class="keyword">while</span> (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            end(blocking, n &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">assert</span> IOStatus.check(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//针对接受连接的处理通道socketchannelimpl，默认为阻塞模式 </span></span><br><span class="line">        <span class="comment">// newly accepted socket is initially in blocking mode</span></span><br><span class="line">        IOUtil.configureBlocking(newfd, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        InetSocketAddress isa = isaa[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//构建SocketChannelImpl，这个具体在SocketChannelImpl再说  </span></span><br><span class="line">        SocketChannel sc = <span class="keyword">new</span> SocketChannelImpl(provider(), newfd, isa);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check permitted to accept connections from the remote address</span></span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//检查地址和port权限</span></span><br><span class="line">                sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException x) &#123;</span><br><span class="line">                sc.close();</span><br><span class="line">                <span class="keyword">throw</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//返回socketchannelimpl  </span></span><br><span class="line">        <span class="keyword">return</span> sc;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        acceptLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<code>accept(this.fd, newfd, isaa)</code>，调用accept接收socket中已建立的连接，我们之前有在BIO中了解过，函数最终会调用:int accept(int sockfd,struct sockaddr <em>addr, socklen_t </em>addrlen);</p>
<ul>
<li>如果fd监听socket的队列中没有等待的连接，socket也没有被标记为Non-blocking，accept()会阻塞直到连接出现；</li>
<li>如果socket被标记为Non-blocking，队列中也没有等待的连接，accept()返回错误EAGAIN或EWOULDBLOCK</li>
</ul>
<p>这里<code>begin(blocking);</code> 与 <code>end(blocking, n &gt; 0);</code>的合作模式我们在<a href="https://github.com/muyinchen/woker/blob/master/NIO/%E8%A1%A5%E5%85%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%9AInterruptibleChannel%20%E4%B8%8E%E5%8F%AF%E4%B8%AD%E6%96%AD%20IO.md" target="_blank" rel="noopener">InterruptibleChannel 与可中断 IO</a>这一篇文章中已经涉及过，这里再次提一下，让大家看到其应用，此处专注的是等待连接这个过程，期间可以出现异常打断，这个过程正常结束的话，就会正常往下执行逻辑，不要搞的好像这个Channel要结束了一样，<code>end(blocking, n &gt; 0)</code>的第二个参数completed也只是在判断这个等待过程是否结束而已，不要功能范围扩大化。</p>
<h4 id="supportedOptions"><a href="#supportedOptions" class="headerlink" title="supportedOptions"></a>supportedOptions</h4><p>我们再来看下<code>NetworkChannel</code>的其他方法实现，首先来看<code>supportedOptions</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#supportedOptions</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultOptionsHolder.defaultOptions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl.DefaultOptionsHolder</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultOptionsHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() &#123;</span><br><span class="line">        HashSet&lt;SocketOption&lt;?&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(StandardSocketOptions.SO_RCVBUF);</span><br><span class="line">        set.add(StandardSocketOptions.SO_REUSEADDR);</span><br><span class="line">        <span class="keyword">if</span> (Net.isReusePortAvailable()) &#123;</span><br><span class="line">            set.add(StandardSocketOptions.SO_REUSEPORT);</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(StandardSocketOptions.IP_TOS);</span><br><span class="line">        set.addAll(ExtendedSocketOptions.options(SOCK_STREAM));</span><br><span class="line">        <span class="comment">//返回不可修改的HashSet </span></span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对上述配置中的一些配置我们大致来瞅眼:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.StandardSocketOptions</span></span><br><span class="line"><span class="comment">//socket接受缓存大小  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SocketOption&lt;Integer&gt; SO_RCVBUF =</span><br><span class="line">        <span class="keyword">new</span> StdSocketOption&lt;Integer&gt;(<span class="string">"SO_RCVBUF"</span>, Integer.class);</span><br><span class="line"><span class="comment">//是否可重用地址  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SocketOption&lt;Boolean&gt; SO_REUSEADDR =</span><br><span class="line">        <span class="keyword">new</span> StdSocketOption&lt;Boolean&gt;(<span class="string">"SO_REUSEADDR"</span>, Boolean.class);</span><br><span class="line"><span class="comment">//是否可重用port</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SocketOption&lt;Boolean&gt; SO_REUSEPORT =</span><br><span class="line">        <span class="keyword">new</span> StdSocketOption&lt;Boolean&gt;(<span class="string">"SO_REUSEPORT"</span>, Boolean.class);</span><br><span class="line"><span class="comment">//Internet协议（IP）标头（header）中的服务类型（ToS）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SocketOption&lt;Integer&gt; IP_TOS =</span><br><span class="line">        <span class="keyword">new</span> StdSocketOption&lt;Integer&gt;(<span class="string">"IP_TOS"</span>, Integer.class);</span><br></pre></td></tr></table></figure></p>
<h4 id="setOption实现"><a href="#setOption实现" class="headerlink" title="setOption实现"></a>setOption实现</h4><p>知道了上面的支持配置，我们来看下<code>setOption</code>实现细节:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#setOption</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ServerSocketChannel <span class="title">setOption</span><span class="params">(SocketOption&lt;T&gt; name, T value)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(name);</span><br><span class="line">    <span class="keyword">if</span> (!supportedOptions().contains(name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"'"</span> + name + <span class="string">"' not supported"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name == StandardSocketOptions.IP_TOS) &#123;</span><br><span class="line">            ProtocolFamily family = Net.isIPv6Available() ?</span><br><span class="line">                StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;</span><br><span class="line">            Net.setSocketOption(fd, family, name, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) &#123;</span><br><span class="line">            <span class="comment">// SO_REUSEADDR emulated when using exclusive bind</span></span><br><span class="line">            isReuseAddress = (Boolean)value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no options that require special handling</span></span><br><span class="line">            Net.setSocketOption(fd, Net.UNSPEC, name, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，大家就能看到<code>supportedOptions().contains(name)</code>的作用了，首先会进行支持配置的判断，然后进行正常的设置逻辑。里面对于Socket配置设定主要执行了<code>Net.setSocketOption</code>，这里，就只对其代码做中文注释就好，整个逻辑过程没有太复杂的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSocketOption</span><span class="params">(FileDescriptor fd, ProtocolFamily family,</span></span></span><br><span class="line"><span class="function"><span class="params">                            SocketOption&lt;?&gt; name, Object value)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid option value"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// only simple values supported by this method</span></span><br><span class="line">    Class&lt;?&gt; type = name.type();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (extendedOptions.isOptionSupported(name)) &#123;</span><br><span class="line">        extendedOptions.setOption(fd, name, value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非整形和布尔型，则抛出断言错误  </span></span><br><span class="line">    <span class="keyword">if</span> (type != Integer.class &amp;&amp; type != Boolean.class)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// special handling</span></span><br><span class="line">    <span class="keyword">if</span> (name == StandardSocketOptions.SO_RCVBUF ||</span><br><span class="line">        name == StandardSocketOptions.SO_SNDBUF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断接受和发送缓冲区大小  </span></span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)value).intValue();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid send/receive buffer size"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//缓冲区有数据，延迟关闭socket的的时间 </span></span><br><span class="line">    <span class="keyword">if</span> (name == StandardSocketOptions.SO_LINGER) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)value).intValue();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            value = Integer.valueOf(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">65535</span>)</span><br><span class="line">            value = Integer.valueOf(<span class="number">65535</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//UDP单播  </span></span><br><span class="line">    <span class="keyword">if</span> (name == StandardSocketOptions.IP_TOS) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)value).intValue();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid IP_TOS value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//UDP多播  </span></span><br><span class="line">    <span class="keyword">if</span> (name == StandardSocketOptions.IP_MULTICAST_TTL) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)value).intValue();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid TTL/hop value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map option name to platform level/name</span></span><br><span class="line">    OptionKey key = SocketOptionRegistry.findOption(name, family);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Option not found"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">    <span class="comment">//转换配置参数值  </span></span><br><span class="line">    <span class="keyword">if</span> (type == Integer.class) &#123;</span><br><span class="line">        arg = ((Integer)value).intValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = ((Boolean)value).booleanValue();</span><br><span class="line">        arg = (b) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> mayNeedConversion = (family == UNSPEC);</span><br><span class="line">    <span class="keyword">boolean</span> isIPv6 = (family == StandardProtocolFamily.INET6);</span><br><span class="line">    <span class="comment">//设置文件描述符的值及其他</span></span><br><span class="line">    setIntOption0(fd, mayNeedConversion, key.level(), key.name(), arg, isIPv6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getOption"><a href="#getOption" class="headerlink" title="getOption"></a>getOption</h4><p>接下来，我们来看<code>getOption</code>实现，源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#getOption</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getOption</span><span class="params">(SocketOption&lt;T&gt; name)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(name);</span><br><span class="line">    <span class="comment">//非通道支持选项，则抛出UnsupportedOperationException  </span></span><br><span class="line">    <span class="keyword">if</span> (!supportedOptions().contains(name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"'"</span> + name + <span class="string">"' not supported"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) &#123;</span><br><span class="line">            <span class="comment">// SO_REUSEADDR emulated when using exclusive bind</span></span><br><span class="line">            <span class="keyword">return</span> (T)Boolean.valueOf(isReuseAddress);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//假如获取的不是上面的配置，则委托给Net来处理 </span></span><br><span class="line">        <span class="comment">// no options that require special handling</span></span><br><span class="line">        <span class="keyword">return</span> (T) Net.getSocketOption(fd, Net.UNSPEC, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.Net#getSocketOption</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">getSocketOption</span><span class="params">(FileDescriptor fd, ProtocolFamily family,</span></span></span><br><span class="line"><span class="function"><span class="params">                                SocketOption&lt;?&gt; name)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class&lt;?&gt; type = name.type();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (extendedOptions.isOptionSupported(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> extendedOptions.getOption(fd, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只支持整形和布尔型，否则抛出断言错误  </span></span><br><span class="line">    <span class="comment">// only simple values supported by this method</span></span><br><span class="line">    <span class="keyword">if</span> (type != Integer.class &amp;&amp; type != Boolean.class)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map option name to platform level/name</span></span><br><span class="line">    OptionKey key = SocketOptionRegistry.findOption(name, family);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Option not found"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> mayNeedConversion = (family == UNSPEC);</span><br><span class="line">    <span class="comment">//获取文件描述的选项配置 </span></span><br><span class="line">    <span class="keyword">int</span> value = getIntOption0(fd, mayNeedConversion, key.level(), key.name());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == Integer.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//我们要看到前面支持配置处的源码其支持的类型要么是Boolean，要么是Integer</span></span><br><span class="line">        <span class="comment">//所以，返回值为Boolean.FALSE 或 Boolean.TRUE也就不足为奇了</span></span><br><span class="line">        <span class="keyword">return</span> (value == <span class="number">0</span>) ? Boolean.FALSE : Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ServerSocketChannel与ServerSocket在bind处的异同"><a href="#ServerSocketChannel与ServerSocket在bind处的异同" class="headerlink" title="ServerSocketChannel与ServerSocket在bind处的异同"></a>ServerSocketChannel与ServerSocket在bind处的异同</h4><p>在<strong>Net.bind</strong>一节中，我们最后说了一个注意点，每个连接过来的时候都会创建一个Socket来供此连接进行操作，这个在accept方法中可以看到，其在得到连接之后，就 <code>new SocketChannelImpl(provider(), newfd, isa)</code>这个对象。那这里，就引出一个话题，我们在使用bind方法的时候，是不是也应该绑定到一个Socket之上呢，那之前bio是怎么做呢，我们先来回顾一下。<br>我们之前在调用<code>java.net.ServerSocket#ServerSocket(int, int, java.net.InetAddress)</code>方法的时候，里面有一个<code>setImpl()</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        setImpl();</span><br><span class="line">        <span class="keyword">if</span> (port &lt; <span class="number">0</span> || port &gt; <span class="number">0xFFFF</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                       <span class="string">"Port value out of range: "</span> + port);</span><br><span class="line">        <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">          backlog = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bind(<span class="keyword">new</span> InetSocketAddress(bindAddr, port), backlog);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//java.net.ServerSocket#setImpl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            impl = factory.createSocketImpl();</span><br><span class="line">            checkOldImpl();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No need to do a checkOldImpl() here, we know it's an up to date</span></span><br><span class="line">            <span class="comment">// SocketImpl!</span></span><br><span class="line">            impl = <span class="keyword">new</span> SocksSocketImpl();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>)</span><br><span class="line">            impl.setServerSocket(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，我们此处的重点在<code>bind(new InetSocketAddress(bindAddr, port), backlog);</code>，这里的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress endpoint, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oldImpl &amp;&amp; isBound())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Already bound"</span>);</span><br><span class="line">        <span class="keyword">if</span> (endpoint == <span class="keyword">null</span>)</span><br><span class="line">            endpoint = <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(endpoint <span class="keyword">instanceof</span> InetSocketAddress))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported address type"</span>);</span><br><span class="line">        InetSocketAddress epoint = (InetSocketAddress) endpoint;</span><br><span class="line">        <span class="keyword">if</span> (epoint.isUnresolved())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Unresolved address"</span>);</span><br><span class="line">        <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">          backlog = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SecurityManager security = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>)</span><br><span class="line">                security.checkListen(epoint.getPort());</span><br><span class="line">                <span class="comment">//重点！！</span></span><br><span class="line">            getImpl().bind(epoint.getAddress(), epoint.getPort());</span><br><span class="line">            getImpl().listen(backlog);</span><br><span class="line">            bound = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们有看到 <code>getImpl()</code>我标示了重点，这里面做了什么，我们走进去:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket#getImpl</span></span><br><span class="line"><span class="function">SocketImpl <span class="title">getImpl</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!created)</span><br><span class="line">        createImpl();</span><br><span class="line">    <span class="keyword">return</span> impl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在整个过程中<code>created</code>还是对象刚创建时的初始值，为false，那么，铁定会进入<code>createImpl()</code>方法中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket#createImpl</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createImpl</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (impl == <span class="keyword">null</span>)</span><br><span class="line">        setImpl();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        impl.create(<span class="keyword">true</span>);</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而此处，因为前面<code>impl</code>已经赋值，所以，会走<code>impl.create(true)</code>，进而将<code>created</code>设定为<code>true</code>。而此刻，终于到我想讲的重点了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.AbstractPlainSocketImpl#create</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stream = stream;</span><br><span class="line">    <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">        ResourceManager.beforeUdpCreate();</span><br><span class="line">        <span class="comment">// only create the fd after we know we will be able to create the socket</span></span><br><span class="line">        fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketCreate(<span class="keyword">false</span>);</span><br><span class="line">            SocketCleanable.register(fd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            ResourceManager.afterUdpClose();</span><br><span class="line">            fd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">throw</span> ioe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        socketCreate(<span class="keyword">true</span>);</span><br><span class="line">        SocketCleanable.register(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">        socket.setCreated();</span><br><span class="line">    <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)</span><br><span class="line">        serverSocket.setCreated();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>socketCreate(true);</code>，它的实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketCreate</span><span class="params">(<span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket closed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newfd = socket0(stream);</span><br><span class="line"></span><br><span class="line">    fdAccess.set(fd, newfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过本地方法<code>socket0(stream)</code>得到了一个文件描述符，由此，Socket创建了出来，然后进行相应的绑定。<br>我们再把眼光放回到<code>sun.nio.ch.ServerSocketChannelImpl#accept()</code>中，这里new的<code>SocketChannelImpl</code>对象是得到连接之后做的事情，那对于服务器来讲，绑定时候用的Socket呢，这里，我们在使用<code>ServerSocketChannel</code>的时候，往往要使用JDK给我们提供的对我统一的方法<code>open</code>，也是为了降低我们使用的复杂度，这里是<code>java.nio.channels.ServerSocketChannel#open</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.ServerSocketChannel#open</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openServerSocketChannel();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorProviderImpl#openServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">openServerSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServerSocketChannelImpl(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#ServerSocketChannelImpl(SelectorProvider)</span></span><br><span class="line">ServerSocketChannelImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    <span class="keyword">this</span>.fd =  Net.serverSocket(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.fdVal = IOUtil.fdVal(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.Net#serverSocket</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FileDescriptor <span class="title">serverSocket</span><span class="params">(<span class="keyword">boolean</span> stream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IOUtil.newFD(socket0(isIPv6Available(), stream, <span class="keyword">true</span>, fastLoopback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，只要new了一个ServerSocketChannelImpl对象，就相当于拿到了一个<code>socket</code>然后bind也就有着落了。但是，我们要注意下细节<code>ServerSocketChannel#open</code>得到的是<code>ServerSocketChannel</code>类型。我们accept到一个客户端来的连接后，应该在客户端与服务器之间创建一个Socket通道来供两者通信操作的，所以，<code>sun.nio.ch.ServerSocketChannelImpl#accept()</code>中所做的是<code>SocketChannel sc = new SocketChannelImpl(provider(), newfd, isa);</code>，得到的是<code>SocketChannel</code>类型的对象，这样，就可以将Socket的读写数据的方法定义在这个类里面。</p>
<h4 id="由ServerSocketChannel的socket方法延伸的"><a href="#由ServerSocketChannel的socket方法延伸的" class="headerlink" title="由ServerSocketChannel的socket方法延伸的"></a>由ServerSocketChannel的socket方法延伸的</h4><p>关于<code>ServerSocketChannel</code>，我们还有方法需要接触一下，如socket():<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#socket</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerSocket <span class="title">socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (socket == <span class="keyword">null</span>)</span><br><span class="line">            socket = ServerSocketAdaptor.create(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> socket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到了<code>ServerSocketAdaptor</code>，我们通过此类的注释可知，这是一个和<code>ServerSocket</code>调用一样，但是底层是用<code>ServerSocketChannelImpl</code>来实现的一个类，其适配是的目的是适配我们使用<code>ServerSocket</code>的方式，所以该<code>ServerSocketAdaptor</code>继承<code>ServerSocket</code>并按顺序重写了它的方法，所以，我们在写这块儿代码的时候也就有了新的选择。</p>
<p><a href="https://github.com/muyinchen/woker/blob/master/NIO/%E8%A1%A5%E5%85%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%9AInterruptibleChannel%20%E4%B8%8E%E5%8F%AF%E4%B8%AD%E6%96%AD%20IO.md" target="_blank" rel="noopener">InterruptibleChannel 与可中断 IO</a>这一篇文章中已经涉及过<code>java.nio.channels.spi.AbstractInterruptibleChannel#close</code>的实现，这里，我们再来回顾下其中的某些细节，顺带引出我们新的话题:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractInterruptibleChannel#close</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closed)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">        implCloseChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#implCloseChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">implCloseChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        implCloseSelectableChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clone keys to avoid calling cancel when holding keyLock</span></span><br><span class="line">        SelectionKey[] copyOfKeys = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys != <span class="keyword">null</span>) &#123;</span><br><span class="line">                copyOfKeys = keys.clone();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copyOfKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SelectionKey k : copyOfKeys) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    k.cancel();   <span class="comment">// invalidate and adds key to cancelledKey set</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.ServerSocketChannelImpl#implCloseSelectableChannel</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implCloseSelectableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> !isOpen();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> blocking;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set state to ST_CLOSING</span></span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="keyword">assert</span> state &lt; ST_CLOSING;</span><br><span class="line">        state = ST_CLOSING;</span><br><span class="line">        blocking = isBlocking();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for any outstanding accept to complete</span></span><br><span class="line">    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">            <span class="keyword">assert</span> state == ST_CLOSING;</span><br><span class="line">            <span class="keyword">long</span> th = thread;</span><br><span class="line">            <span class="keyword">if</span> (th != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//本地线程不为null，则本地Socket预先关闭</span></span><br><span class="line">                <span class="comment">//并通知线程通知关闭</span></span><br><span class="line">                nd.preClose(fd);</span><br><span class="line">                NativeThread.signal(th);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// wait for accept operation to end</span></span><br><span class="line">                <span class="keyword">while</span> (thread != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        stateLock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        interrupted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// non-blocking mode: wait for accept to complete</span></span><br><span class="line">        acceptLock.lock();</span><br><span class="line">        acceptLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set state to ST_KILLPENDING</span></span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="keyword">assert</span> state == ST_CLOSING;</span><br><span class="line">        state = ST_KILLPENDING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close socket if not registered with Selector</span></span><br><span class="line">    <span class="comment">//如果未在Selector上注册，直接kill掉</span></span><br><span class="line">    <span class="comment">//即关闭文件描述  </span></span><br><span class="line">    <span class="keyword">if</span> (!isRegistered())</span><br><span class="line">        kill();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore interrupt status</span></span><br><span class="line">    <span class="comment">//印证了我们上一篇中在异步打断中若是通过线程的中断方法中断线程的话</span></span><br><span class="line">    <span class="comment">//最后要设定该线程状态是interrupt</span></span><br><span class="line">    <span class="keyword">if</span> (interrupted)</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == ST_KILLPENDING) &#123;</span><br><span class="line">            state = ST_KILLED;</span><br><span class="line">            nd.close(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="channel的close-应用"><a href="#channel的close-应用" class="headerlink" title="channel的close()应用"></a>channel的close()应用</h5><p>也是因为<code>close()</code>并没有在<a href="https://github.com/muyinchen/woker/blob/master/NIO/%E8%A1%A5%E5%85%85%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%9AInterruptibleChannel%20%E4%B8%8E%E5%8F%AF%E4%B8%AD%E6%96%AD%20IO.md" target="_blank" rel="noopener">InterruptibleChannel 与可中断 IO</a>这一篇文章中进行具体的讲解应用，这里其应用的更多是在<code>SocketChannel</code>这里，其更多的涉及到客户端与服务端建立连接交换数据，所以断开连接后，将不用的Channel关闭是很正常的。<br>这里，在<code>sun.nio.ch.ServerSocketChannelImpl#accept()</code>中的源码中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// newly accepted socket is initially in blocking mode</span></span><br><span class="line">        IOUtil.configureBlocking(newfd, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        InetSocketAddress isa = isaa[<span class="number">0</span>];</span><br><span class="line">        SocketChannel sc = <span class="keyword">new</span> SocketChannelImpl(provider(), newfd, isa);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check permitted to accept connections from the remote address</span></span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException x) &#123;</span><br><span class="line">                sc.close();</span><br><span class="line">                <span class="keyword">throw</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sc;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        acceptLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过对所接收的连接的远程地址做合法性判断，假如验证出现异常，则关闭上面创建的<code>SocketChannel</code>。<br>还有一个关于close()的实际用法，在客户端建立连接的时候，如果连接出异常，同样是要关闭所创建的Socket:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.SocketChannel#open(java.net.SocketAddress)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">(SocketAddress remote)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SocketChannel sc = open();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sc.connect(remote);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sc.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable suppressed) &#123;</span><br><span class="line">                x.addSuppressed(suppressed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> sc.isConnected();</span><br><span class="line">        <span class="keyword">return</span> sc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，我们在<code>implCloseSelectableChannel</code>中会发现<code>nd.preClose(fd);</code>与<code>nd.close(fd);</code>，这个在<code>SocketChannelImpl</code>与<code>ServerSocketChannelImpl</code>两者对于<code>implCloseSelectableChannel</code>实现中都可以看到，这个nd是什么，这里，我们拿<code>ServerSocketChannelImpl</code>来讲，在这个类的最后面有一段静态代码块(<code>SocketChannelImpl</code>同理)，也就是在这个类加载的时候就会执行:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C:/Program Files/Java/jdk-11.0.1/lib/src.zip!/java.base/sun/nio/ch/ServerSocketChannelImpl.java:550</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">     <span class="comment">//加载nio，net资源库</span></span><br><span class="line">        IOUtil.load();</span><br><span class="line">        initIDs();</span><br><span class="line">        nd = <span class="keyword">new</span> SocketDispatcher();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，在<code>ServerSocketChannelImpl</code>这个类字节码加载的时候，就会创建<code>SocketDispatcher</code>对象。通过<code>SocketDispatcher</code>允许在不同的平台调用不同的本地方法进行读写操作,然后基于这个类，我们就可以在<code>sun.nio.ch.SocketChannelImpl</code>做Socket的I/O操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketDispatcher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketDispatcher</span> <span class="keyword">extends</span> <span class="title">NativeDispatcher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        IOUtil.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读操作  </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read0(fd, address, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">readv</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readv0(fd, address, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写操作  </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> write0(fd, address, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">writev</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> writev0(fd, address, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预关闭文件描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preClose</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        preClose0(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件描述</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        close0(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- Native methods</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">read0</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">readv0</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">write0</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">writev0</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">preClose0</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">close0</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="FileDescriptor"><a href="#FileDescriptor" class="headerlink" title="FileDescriptor"></a>FileDescriptor</h4><p>我们有看到<code>FileDescriptor</code>在前面代码中有大量的出现，这里，我们对它来专门介绍。通过FileDescriptor 这个类的实例来充当底层机器特定结构的不透明处理，表示打开文件，打开socket或其他字节源或接收器。<br>文件描述符的主要用途是创建一个 FileInputStream或 FileOutputStream来包含它。<br>注意: 应用程序不应创建自己的文件描述符。<br>我们来看其部分源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> handle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Closeable parent;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Closeable&gt; otherParents;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> closed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * true, if file is opened for appending.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> append;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        initIDs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在未明确关闭FileDescriptor的情况下进行清理.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> PhantomCleanable&lt;FileDescriptor&gt; cleanup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个无效的FileDescriptor对象，fd或handle会在之后进行设定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fd = -<span class="number">1</span>;</span><br><span class="line">        handle = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Used for standard input, output, and error only.</span></span><br><span class="line"><span class="comment">     * For Windows the corresponding handle is initialized.</span></span><br><span class="line"><span class="comment">     * For Unix the append mode is cached.</span></span><br><span class="line"><span class="comment">     * 仅用于标准输入，输出和错误。</span></span><br><span class="line"><span class="comment">     * 对于Windows，初始化相应的句柄。</span></span><br><span class="line"><span class="comment">     * 对于Unix，缓存附加模式。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fd the raw fd number (0, 1, 2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileDescriptor</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fd = fd;</span><br><span class="line">        <span class="keyword">this</span>.handle = getHandle(fd);</span><br><span class="line">        <span class="keyword">this</span>.append = getAppend(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们平时所用的标准输入，输出，错误流的句柄可以如下，通常，我们不会直接使用它们，而是使用<code>java.lang.System.in</code>，<code>java.lang.System#out</code>，<code>java.lang.System#err</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor in = <span class="keyword">new</span> FileDescriptor(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor out = <span class="keyword">new</span> FileDescriptor(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor err = <span class="keyword">new</span> FileDescriptor(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>测试该文件描述符是否有效可以使用如下方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.io.FileDescriptor#valid</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (handle != -<span class="number">1</span>) || (fd != -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>返回值为true的话，那么这个文件描述符对象所代表的<code>socket</code> <code>文件操作</code>或其他活动的网络连接都是有效的，反之，false则是无效。<br>更多内容，读者可以自行深入源码，此处就不过多解释了。为了让大家可以更好的理解上述内容，我们会在后面的部分还要进一步涉及一下。</p>
<h3 id="NIO包下SocketChannel解读"><a href="#NIO包下SocketChannel解读" class="headerlink" title="NIO包下SocketChannel解读"></a>NIO包下SocketChannel解读</h3><p>在前面，我们已经接触了<code>SocketChannel</code>，这里，来接触下细节。</p>
<p>同样，我们也可以通过调用此类的<code>open</code>方法来创建<code>socket channel</code>。这里需要注意：</p>
<ul>
<li>无法为任意预先存在的<code>socket</code>创建<code>channel</code>。</li>
<li>新创建的<code>socket channel</code>已打开但尚未连接。</li>
<li>尝试在未连接的<code>channel</code>上调用<code>I/O</code>操作将导致抛出<code>NotYetConnectedException</code>。</li>
<li>可以通过调用<code>connect</code>方法连接<code>socket channel</code>;</li>
<li>一旦连接后，<code>socket channel</code>会保持连接状态，直到它关闭。</li>
<li>是否有连接<code>socket channel</code>可以通过确定调用其<code>isConnected</code>方法。</li>
</ul>
<p><code>socket channel</code>支持 非阻塞连接：</p>
<ul>
<li>可以先创建<code>socket channel</code>，然后可以通过 <code>connect</code> 方法建立到远程<code>socket</code>的连接。</li>
<li>通过调用<code>finishConnect</code>方法来结束连接。</li>
<li>判断是否正在进行连接操作可以通过调用<code>isConnectionPending</code>方法来确定。</li>
</ul>
<p><code>socket channel</code>支持异步关闭，类似于<code>Channel</code>类中的异步关闭操作。</p>
<ul>
<li>如果<code>socket</code>的输入端被一个线程关闭而另一个线程在此<code>socket channel</code>上因在进行读操作而被阻塞，那么被阻塞线程中的读操作将不读取任何字节并将返回 <code>-1</code> 。</li>
<li>如果<code>socket</code>的输出端被一个线程关闭而另一个线程在<code>socket channel</code>上因在进行写操作而被阻塞，则被阻塞的线程将收到<code>AsynchronousCloseException</code>。</li>
</ul>
<p>接下来，我们来看其具体实现方法。</p>
<h4 id="ServerSocketChannel与SocketChannel的open"><a href="#ServerSocketChannel与SocketChannel的open" class="headerlink" title="ServerSocketChannel与SocketChannel的open()"></a>ServerSocketChannel与SocketChannel的open()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.SocketChannel#open()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSocketChannel();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.channels.SocketChannel#open(java.net.SocketAddress)</span></span><br><span class="line"><span class="comment">//这个方法省的我们再次调用connect了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">(SocketAddress remote)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//默认是堵塞的，这个在AbstractSelectableChannel处讨论过了</span></span><br><span class="line">    SocketChannel sc = open();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sc.connect(remote);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable suppressed) &#123;</span><br><span class="line">            x.addSuppressed(suppressed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> sc.isConnected();</span><br><span class="line">    <span class="keyword">return</span> sc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorProviderImpl#openSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">openSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SocketChannelImpl(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#SocketChannelImpl(java.nio.channels.spi.SelectorProvider)</span></span><br><span class="line">SocketChannelImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">     <span class="comment">//调用socket函数，true表示TCP</span></span><br><span class="line">    <span class="keyword">this</span>.fd = Net.socket(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.fdVal = IOUtil.fdVal(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.Net#socket(boolean)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FileDescriptor <span class="title">socket</span><span class="params">(<span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> socket(UNSPEC, stream);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.Net#socket(java.net.ProtocolFamily, boolean)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FileDescriptor <span class="title">socket</span><span class="params">(ProtocolFamily family, <span class="keyword">boolean</span> stream)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> preferIPv6 = isIPv6Available() &amp;&amp;</span><br><span class="line">        (family != StandardProtocolFamily.INET);</span><br><span class="line">    <span class="keyword">return</span> IOUtil.newFD(socket0(preferIPv6, stream, <span class="keyword">false</span>, fastLoopback));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.IOUtil#newFD</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileDescriptor <span class="title">newFD</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    setfdVal(fd, i);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setfdVal</span><span class="params">(FileDescriptor fd, <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>关于<code>Net.socket(true)</code>，我们前面已经提到过了，这里，通过其底层源码来再次调教下 (此处不想看可以跳过):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,</span><br><span class="line">                            jboolean stream, jboolean reuse, jboolean ignored)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//字节流还是数据报,TCP对应SOCK_STREAM,UDP对应SOCK_DGRAM,此处传入的stream=true;</span></span><br><span class="line">    <span class="keyword">int</span> type = (stream ? SOCK_STREAM : SOCK_DGRAM);</span><br><span class="line">    <span class="comment">//判断是IPV6还是IPV4</span></span><br><span class="line">    <span class="keyword">int</span> domain = (ipv6_available() &amp;&amp; preferIPv6) ? AF_INET6 : AF_INET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用Linux的socket函数,domain为代表协议;</span></span><br><span class="line">    <span class="comment">//type为套接字类型，protocol设置为0来表示使用默认的传输协议</span></span><br><span class="line">    fd = socket(domain, type, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//出错</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> handleSocketError(env, errno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disable IPV6_V6ONLY to ensure dual-socket support */</span></span><br><span class="line">    <span class="keyword">if</span> (domain == AF_INET6) &#123;</span><br><span class="line">        <span class="keyword">int</span> arg = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//arg=1设置ipv6的socket只接收ipv6地址的报文,arg=0表示也可接受ipv4的请求</span></span><br><span class="line">        <span class="keyword">if</span> (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (<span class="keyword">char</span>*)&amp;arg,</span><br><span class="line">                       sizeof(<span class="keyword">int</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            JNU_ThrowByNameWithLastError(env,</span><br><span class="line">                                         JNU_JAVANETPKG <span class="string">"SocketException"</span>,</span><br><span class="line">                                         <span class="string">"Unable to set IPV6_V6ONLY"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SO_REUSEADDR有四种用途:</span></span><br><span class="line">    <span class="comment">//1.当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。 </span></span><br><span class="line">    <span class="comment">//2.SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但每个实例绑定的IP地址是不能相同的。</span></span><br><span class="line">    <span class="comment">//3.SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。 </span></span><br><span class="line">   <span class="comment">//4.SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP;</span></span><br><span class="line">    <span class="keyword">if</span> (reuse) &#123;</span><br><span class="line">        <span class="keyword">int</span> arg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">char</span>*)&amp;arg,</span><br><span class="line">                       sizeof(arg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            JNU_ThrowByNameWithLastError(env,</span><br><span class="line">                                         JNU_JAVANETPKG <span class="string">"SocketException"</span>,</span><br><span class="line">                                         <span class="string">"Unable to set SO_REUSEADDR"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if defined(__linux__)</span><br><span class="line">    <span class="keyword">if</span> (type == SOCK_DGRAM) &#123;</span><br><span class="line">        <span class="keyword">int</span> arg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = (domain == AF_INET6) ? IPPROTO_IPV6 : IPPROTO_IP;</span><br><span class="line">        <span class="keyword">if</span> ((setsockopt(fd, level, IP_MULTICAST_ALL, (<span class="keyword">char</span>*)&amp;arg, sizeof(arg)) &lt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (errno != ENOPROTOOPT)) &#123;</span><br><span class="line">            JNU_ThrowByNameWithLastError(env,</span><br><span class="line">                                         JNU_JAVANETPKG <span class="string">"SocketException"</span>,</span><br><span class="line">                                         <span class="string">"Unable to set IP_MULTICAST_ALL"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//IPV6_MULTICAST_HOPS用于控制多播的范围，</span></span><br><span class="line">     <span class="comment">// 1表示只在本地网络转发,</span></span><br><span class="line">     <span class="comment">//更多介绍请参考(http://www.ctt.sbras.ru/cgi-bin/www/unix_help/unix-man?ip6+4);</span></span><br><span class="line">    <span class="comment">/* By default, Linux uses the route default */</span></span><br><span class="line">    <span class="keyword">if</span> (domain == AF_INET6 &amp;&amp; type == SOCK_DGRAM) &#123;</span><br><span class="line">        <span class="keyword">int</span> arg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &amp;arg,</span><br><span class="line">                       sizeof(arg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            JNU_ThrowByNameWithLastError(env,</span><br><span class="line">                                         JNU_JAVANETPKG <span class="string">"SocketException"</span>,</span><br><span class="line">                                         <span class="string">"Unable to set IPV6_MULTICAST_HOPS"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Linux 3.9之后加入了<code>SO_REUSEPORT</code>配置，这个配置很强大，多个<code>socket</code>(不管是处于监听还是非监听，不管是TCP还是UDP)只要在绑定之前设置了<code>SO_REUSEPORT</code>属性，那么就可以绑定到完全相同的地址和端口。<br>为了阻止”port 劫持”(<code>Port hijacking</code>)有一个特别的限制：所有希望共享源地址和端口的socket都必须拥有相同的有效用户id(<code>effective user ID</code>)。这样一个用户就不能从另一个用户那里”偷取”端口。另外，内核在处理<code>SO_REUSEPORT socket</code>的时候使用了其它系统上没有用到的”特殊技巧”：</p>
<ul>
<li>对于UDP socket，内核尝试平均的转发数据报;</li>
<li>对于TCP监听socket，内核尝试将新的客户连接请求(由accept返回)平均的交给共享同一地址和端口的socket(服务器监听socket)。</li>
</ul>
<p>例如：一个简单的服务器程序的多个实例可以使用<code>SO_REUSEPORT socket</code>，这样就实现一个简单的负载均衡，因为内核已经把请求的分配都做了。</p>
<p>在前面的代码中可以看到，在这个<code>socket</code>创建成功之后，调用<code>IOUtil.newFD</code>创建了文件描述符<br>。这里，我只是想知道这个Socket是可以输入呢，还是可以读呢，还是有错呢，参考<code>FileDescriptor</code>这一节最后那几个标准状态的设定，其实这里也是一样，因为我们要往Socket中写和读，其标准状态无非就这三种:输入，输出，出错。而这个Socket是绑定在<code>SocketChannel</code>上的，那就把<code>FileDescriptor</code>也绑定到上面即可，这样我们就可以获取到它的状态了。由于FileDescriptor没有提供外部设置fd的方法，setfdVal是通过本地方法实现的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_sun_nio_ch_IOUtil_setfdVal(JNIEnv *env, jclass clazz, jobject fdo, jint val)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;SetIntField(env, fdo, fd_fdID, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假如各位有对Linux下的shell编程或者命令有了解的话，我们知道，shell对报错进行重定向要使用2&gt;，也就是将错误信息由2号所指向的通道写出，这里0和1 同样指向一个通道。此处同样也代表了状态，这样就可以对代表Socket的状态进行操作了，也就是改变<code>SelectionKey</code>的<code>interest ops</code>，即首先对<code>SelectionKey</code>按输入输出类型进行分类，然后我们的读写状态的操作也就有着落了。此处我们打个戳，在下一篇中会对其进行细节讲解。</p>
<p>我们回归到<code>SocketChannel</code>的<code>open</code>方法中。我们可以看到，<code>SelectorProvider.provider().openSocketChannel()</code>返回的是<code>SocketChannelImpl</code>对象实例。在<code>SocketChannelImpl(SelectorProvider sp)</code>中我们并未看到其对<code>this.state</code>进行值操作，也就是其默认为0，即<code>ST_UNCONNECTED</code>(未连接状态)，同时Socket默认是堵塞的。<br>所以，一般情况下，当采用异步方式时，使用不带参数的open方法比较常见，这样，我们会随之调用<code>configureBlocking</code>来设置非堵塞。</p>
<h4 id="SocketChannel的connect解读"><a href="#SocketChannel的connect解读" class="headerlink" title="SocketChannel的connect解读"></a>SocketChannel的connect解读</h4><p>由前面可知，我们调用<code>connect</code>方法连接到远程服务器,其源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#connect</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress sa)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InetSocketAddress isa = Net.checkAddress(sa);</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>)</span><br><span class="line">        sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());</span><br><span class="line"></span><br><span class="line">    InetAddress ia = isa.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (ia.isAnyLocalAddress())</span><br><span class="line">        ia = InetAddress.getLocalHost();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> blocking = isBlocking();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//支持线程中断，通过设置当前线程的Interruptible blocker属性实现</span></span><br><span class="line">                    beginConnect(blocking, isa);</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//调用connect函数实现，如果采用堵塞模式，会一直等待，直到成功或出//现异常</span></span><br><span class="line">                        n = Net.connect(fd, ia, isa.getPort());</span><br><span class="line">                    &#125; <span class="keyword">while</span> (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    endConnect(blocking, (n &gt; <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">assert</span> IOStatus.check(n);</span><br><span class="line">                <span class="comment">//连接成功</span></span><br><span class="line">                <span class="keyword">return</span> n &gt; <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="comment">// connect failed, close the channel</span></span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> SocketExceptions.of(ioe, isa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于<code>beginConnect</code>与<code>endConnect</code>，是针对<code>AbstractInterruptibleChannel</code>中<code>begin()</code>与<code>end</code>方法的一种增强。这里我们需要知道的是，假如是非阻塞Channel的话，我们无须去关心连接过程的打断。顾名思义，只有阻塞等待才需要去考虑打断这一场景的出现。剩下的细节我已经在代码中进行了完整的注释，读者可自行查看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#beginConnect</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beginConnect</span><span class="params">(<span class="keyword">boolean</span> blocking, InetSocketAddress isa)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//只有阻塞的时候才会进入begin</span></span><br><span class="line">    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">        <span class="comment">// set hook for Thread.interrupt</span></span><br><span class="line">        <span class="comment">//支持线程中断，通过设置当前线程的Interruptible blocker属性实现</span></span><br><span class="line">        begin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="comment">//默认为open, 除非调用了close方法</span></span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="comment">//检查连接状态</span></span><br><span class="line">        <span class="keyword">int</span> state = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">if</span> (state == ST_CONNECTED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlreadyConnectedException();</span><br><span class="line">        <span class="keyword">if</span> (state == ST_CONNECTIONPENDING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionPendingException();</span><br><span class="line">        <span class="comment">//断言当前的状态是否是未连接状态，如果是，赋值表示正在连接中</span></span><br><span class="line">        <span class="keyword">assert</span> state == ST_UNCONNECTED;</span><br><span class="line">        <span class="comment">//表示正在连接中</span></span><br><span class="line">        <span class="keyword">this</span>.state = ST_CONNECTIONPENDING;</span><br><span class="line">        <span class="comment">//只有未绑定本地地址也就是说未调用bind方法才执行,</span></span><br><span class="line">        <span class="comment">//该方法在ServerSocketChannel中也见过</span></span><br><span class="line">        <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>)</span><br><span class="line">            NetHooks.beforeTcpConnect(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">        remoteAddress = isa;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">            <span class="comment">// record thread so it can be signalled if needed</span></span><br><span class="line">            readerThread = NativeThread.current();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在连接过程中，我们需要注意的就是几个连接的状态:<code>ST_UNCONNECTED</code>、<code>ST_CONNECTED</code> 、<code>ST_CONNECTIONPENDING</code>、<code>ST_CLOSING</code>、<code>ST_KILLPENDING</code>、<code>ST_KILLED</code>，也是因为其是一个公共状态，可能会有多个线程对其进行连接操作的。所以，<code>state</code>被定义为一个<code>volatile</code>变量，这个变量在改变的时候需要有<code>stateLock</code>这个对象来作为<code>synchronized</code>锁对象来控制同步操作的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#endConnect</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">endConnect</span><span class="params">(<span class="keyword">boolean</span> blocking, <span class="keyword">boolean</span> completed)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    endRead(blocking, completed);</span><br><span class="line">    <span class="comment">//当上面代码中n&gt;0，说明连接成功，更新状态为ST_CONNECTED</span></span><br><span class="line">    <span class="keyword">if</span> (completed) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == ST_CONNECTIONPENDING) &#123;</span><br><span class="line">                localAddress = Net.localAddress(fd);</span><br><span class="line">                state = ST_CONNECTED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#endRead</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">endRead</span><span class="params">(<span class="keyword">boolean</span> blocking, <span class="keyword">boolean</span> completed)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> AsynchronousCloseException</span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//当阻塞状态下的话，才进入</span></span><br><span class="line">    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">            readerThread = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// notify any thread waiting in implCloseSelectableChannel</span></span><br><span class="line">            <span class="keyword">if</span> (state == ST_CLOSING) &#123;</span><br><span class="line">                stateLock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//和begin成对出现，当线程中断时，抛出ClosedByInterruptException</span></span><br><span class="line">        <span class="comment">// remove hook for Thread.interrupt</span></span><br><span class="line">        end(completed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来关注<code>connect</code>中的<code>Net.connect(fd, ia, isa.getPort())</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.Net#connect</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">connect</span><span class="params">(FileDescriptor fd, InetAddress remote, <span class="keyword">int</span> remotePort)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connect(UNSPEC, fd, remote, remotePort);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.Net#connect</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">connect</span><span class="params">(ProtocolFamily family, FileDescriptor fd, InetAddress remote, <span class="keyword">int</span> remotePort)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> preferIPv6 = isIPv6Available() &amp;&amp;</span><br><span class="line">        (family != StandardProtocolFamily.INET);</span><br><span class="line">    <span class="keyword">return</span> connect0(preferIPv6, fd, remote, remotePort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法最终会调用native方法，具体注释如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_Net_connect0(JNIEnv *env, jclass clazz, jboolean preferIPv6,</span><br><span class="line">                             jobject fdo, jobject iao, jint port)</span><br><span class="line">&#123;</span><br><span class="line">    SOCKETADDRESS sa;</span><br><span class="line">    <span class="keyword">int</span> sa_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rv;</span><br><span class="line">    <span class="comment">//地址转换为struct sockaddr格式</span></span><br><span class="line">    <span class="keyword">if</span> (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> IOS_THROWN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传入fd和sockaddr,与远程服务器建立连接，一般就是TCP三次握手</span></span><br><span class="line">   <span class="comment">//如果设置了configureBlocking(false),不会堵塞，否则会堵塞一直到超时或出现异常</span></span><br><span class="line">    rv = connect(fdval(env, fdo), &amp;sa.sa, sa_len);</span><br><span class="line">    <span class="comment">//0表示连接成功，失败时通过errno获取具体原因</span></span><br><span class="line">    <span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//非堵塞，连接还未建立(-2)</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EINPROGRESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> IOS_UNAVAILABLE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="comment">//中断(-3)</span></span><br><span class="line">            <span class="keyword">return</span> IOS_INTERRUPTED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handleSocketError(env, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接建立,一般TCP连接连接都需要时间，因此除非是本地网络，</span></span><br><span class="line">    <span class="comment">//一般情况下非堵塞模式返回IOS_UNAVAILABLE比较多；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以通过注释看到，如果是非堵塞，而且连接也并未立马建立成功，其返回的是-2，也就是连接未建立成功，由之前<code>beginConnect</code>部分源码可知，此时状态为<code>ST_CONNECTIONPENDING</code>，那么，非阻塞条件下，什么时候会变为<code>ST_CONNECTED</code>?有什么方法可以查询状态或者等待连接完成？<br>那就让我们来关注下<code>sun.nio.ch.SocketChannelImpl#finishConnect</code></p>
<h4 id="SocketChannelImpl中finishConnect解读"><a href="#SocketChannelImpl中finishConnect解读" class="headerlink" title="SocketChannelImpl中finishConnect解读"></a>SocketChannelImpl中finishConnect解读</h4><p>首先，我们回顾下，前面我们涉及了<code>sun.nio.ch.ServerSocketAdaptor</code>的用法，方便我们只有Socket编程习惯人群使用，这里，我们也就可以看到基本的核心实现逻辑，那么有<code>ServerSocketAdaptor</code>就有<code>SocketAdaptor</code>，这里，在BIO的Socket编程中最后也是调用了<code>connect(address)</code>操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.Socket#Socket</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Socket</span><span class="params">(SocketAddress address, SocketAddress localAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    setImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// backward compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (address == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        createImpl(stream);</span><br><span class="line">        <span class="keyword">if</span> (localAddr != <span class="keyword">null</span>)</span><br><span class="line">            bind(localAddr);</span><br><span class="line">        connect(address);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | IllegalArgumentException | SecurityException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ce) &#123;</span><br><span class="line">            e.addSuppressed(ce);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，我们可以调用<code>java.nio.channels.SocketChannel#open()</code>，然后调用所得到的<code>SocketChannel</code>对象的<code>socket()</code>方法，就可以得到<code>sun.nio.ch.SocketAdaptor</code>对象实例了。我们来查看<code>SocketAdaptor</code>的connect实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketAdaptor#connect</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress remote)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    connect(remote, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress remote, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remote == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connect: The address can't be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connect: timeout can't be negative"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sc.blockingLock()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sc.isBlocking())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//未设定超时则会一直在此等待直到连接或者出现异常</span></span><br><span class="line">            <span class="comment">// no timeout</span></span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">                sc.connect(remote);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有超时设定，则会将Socket给设定为非阻塞</span></span><br><span class="line">            <span class="comment">// timed connect</span></span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc.connect(remote))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> timeoutNanos = NANOSECONDS.convert(timeout, MILLISECONDS);</span><br><span class="line">            <span class="keyword">long</span> to = timeout;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//通过计算超时时间，在允许的时间范围内无限循环来进行连接，</span></span><br><span class="line">                <span class="comment">//如果超时，则关闭这个Socket</span></span><br><span class="line">                <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (sc.pollConnected(to)) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> connected = sc.finishConnect();</span><br><span class="line">                    <span class="comment">//看下文解释</span></span><br><span class="line">                    <span class="keyword">assert</span> connected;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                timeoutNanos -= System.nanoTime() - startTime;</span><br><span class="line">                <span class="keyword">if</span> (timeoutNanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sc.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException x) &#123; &#125;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SocketTimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">                to = MILLISECONDS.convert(timeoutNanos, NANOSECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">            Net.translateException(x, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里先解释下一个小注意点:在Java中，<code>assert</code>关键字是从<code>JAVA SE 1.4</code> 引入的，为了避免和<strong>老版本的Java代码</strong>中使用了<code>assert</code>关键字导致错误，<strong>Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都 将忽略！），如果要开启断言检查，则需要用开关-enableassertions或-ea来开启。</strong><br>通过上面的源码注释，相信大伙已经知道大致的流程了，那关于<code>sun.nio.ch.SocketChannelImpl#finishConnect</code>到底做了什么，此处，我们来探索一番:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#finishConnect</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// no-op if already connected</span></span><br><span class="line">                <span class="keyword">if</span> (isConnected())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> blocking = isBlocking();</span><br><span class="line">                <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beginFinishConnect(blocking);</span><br><span class="line">                    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//阻塞情况下，第二个参数传入true</span></span><br><span class="line">                            n = checkConnect(fd, <span class="keyword">true</span>);</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((n == <span class="number">0</span> || n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//非阻塞情况下，第二个参数传入false</span></span><br><span class="line">                        n = checkConnect(fd, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    connected = (n &gt; <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    endFinishConnect(blocking, connected);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">assert</span> (blocking &amp;&amp; connected) ^ !blocking;</span><br><span class="line">                <span class="keyword">return</span> connected;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="comment">// connect failed, close the channel</span></span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> SocketExceptions.of(ioe, remoteAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#checkConnect</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">checkConnect</span><span class="params">(FileDescriptor fd, <span class="keyword">boolean</span> block)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p>
<p>关于<code>beginFinishConnect</code>与<code>endFinishConnect</code>和我们之前分析的<code>sun.nio.ch.SocketChannelImpl#beginConnect</code>与<code>sun.nio.ch.SocketChannelImpl#endConnect</code>过程差不多，不懂读者可回看。剩下的，就是我们关注的主要核心逻辑<code>checkConnect(fd, true)</code>，它也是一个本地方法，涉及到的源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_SocketChannelImpl_checkConnect(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line">                                               jobject fdo, jboolean block)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    socklen_t n = sizeof(<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">//获取FileDescriptor中的fd</span></span><br><span class="line">    jint fd = fdval(env, fdo);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    struct pollfd poller;</span><br><span class="line">    <span class="comment">//文件描述符</span></span><br><span class="line">    poller.fd = fd;</span><br><span class="line">    <span class="comment">//请求的事件为写事件</span></span><br><span class="line">    poller.events = POLLOUT;</span><br><span class="line">    <span class="comment">//返回的事件</span></span><br><span class="line">    poller.revents = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-1表示阻塞,0表示立即返回，不阻塞进程</span></span><br><span class="line">    result = poll(&amp;poller, <span class="number">1</span>, block ? -<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//小于0表示调用失败</span></span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">return</span> IOS_INTERRUPTED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            JNU_ThrowIOExceptionWithLastError(env, <span class="string">"poll failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> IOS_THROWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非堵塞时，0表示没有准备好的连接</span></span><br><span class="line">    <span class="keyword">if</span> (!block &amp;&amp; (result == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> IOS_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//准备好写或出现错误的socket数量&gt;0</span></span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        result = getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;n);</span><br><span class="line">        <span class="comment">//出错</span></span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleSocketError(env, errno);</span><br><span class="line">        <span class="comment">//发生错误，处理错误</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleSocketError(env, error);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((poller.revents &amp; POLLHUP) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleSocketError(env, ENOTCONN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//socket已经准备好，可写，即连接已经建立好</span></span><br><span class="line">        <span class="comment">// connected</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体的过程如源码注释所示，其中是否阻塞我们在本地方法源码中和之前<code>sun.nio.ch.SocketChannelImpl#finishConnect</code>的行为产生对应。另外，从上面的源码看到，底层是通过<code>poll</code>查询<code>socket</code>的状态，从而判断连接是否建立成功；由于在非堵塞模式下，<code>finishConnect</code>方法会立即返回，根据此处<code>sun.nio.ch.SocketAdaptor#connect</code>的处理，其使用循环的方式判断连接是否建立，在我们的nio编程中，这个是不建议的，属于半成品，而是建议注册到<code>Selector</code>，通过<code>ops=OP_CONNECT</code>获取连接完成的<code>SelectionKey</code>,然后调用<code>finishConnect</code>完成连接的建立；<br>那么<code>finishConnect</code>是否可以不调用呢？答案是否定的，因为只有<code>finishConnect</code>中才会将状态更新为<code>ST_CONNECTED</code>，而在调用<code>read</code>和<code>write</code>时都会对状态进行判断。</p>
<p>这里，我们算是引出了我们即将要涉及的<code>Selector</code>和<code>SelectionKey</code>，我们会在下一篇中进行详细讲解。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://og0sybnix.bkt.clouddn.com/wechat-qcode.png" alt="知秋 WeChat Pay">
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Reactor-Rxjava-NIO/" rel="tag">#Reactor Rxjava  NIO</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/03/BIO到NIO源码的一些事儿之NIO 上/" rel="next" title="BIO到NIO源码的一些事儿之NIO 上">
                <i class="fa fa-chevron-left"></i> BIO到NIO源码的一些事儿之NIO 上
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/12/BIO到NIO源码的一些事儿之NIO 下 之 Selector/" rel="prev" title="BIO到NIO源码的一些事儿之NIO 下 之 Selector">
                BIO到NIO源码的一些事儿之NIO 下 之 Selector <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2019/01/09/BIO到NIO源码的一些事儿之NIO 中/" data-title="BIO到NIO源码的一些事儿之NIO 中" data-url="https://muyinchen.github.io/2019/01/09/BIO到NIO源码的一些事儿之NIO 中/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://og0sybnix.bkt.clouddn.com/18213496.jpg" alt="知秋">
          <p class="site-author-name" itemprop="name">知秋</p>
          <p class="site-description motion-element" itemprop="description">只记空山，只念新雨</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">99</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/lsgqjh" title="小舒哥" target="_blank">小舒哥</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel解读"><span class="nav-number">2.</span> <span class="nav-text">Channel解读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#赋予Channel支持网络socket的能力"><span class="nav-number">2.1.</span> <span class="nav-text">赋予Channel支持网络socket的能力</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bind"><span class="nav-number">2.1.1.</span> <span class="nav-text">bind</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Net-bind"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">Net.bind</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Net-listen"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">Net.listen</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#supportedOptions"><span class="nav-number">2.1.2.</span> <span class="nav-text">supportedOptions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setOption实现"><span class="nav-number">2.1.3.</span> <span class="nav-text">setOption实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getOption"><span class="nav-number">2.1.4.</span> <span class="nav-text">getOption</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServerSocketChannel与ServerSocket在bind处的异同"><span class="nav-number">2.1.5.</span> <span class="nav-text">ServerSocketChannel与ServerSocket在bind处的异同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#由ServerSocketChannel的socket方法延伸的"><span class="nav-number">2.1.6.</span> <span class="nav-text">由ServerSocketChannel的socket方法延伸的</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#channel的close-应用"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">channel的close()应用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FileDescriptor"><span class="nav-number">2.1.7.</span> <span class="nav-text">FileDescriptor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO包下SocketChannel解读"><span class="nav-number">2.2.</span> <span class="nav-text">NIO包下SocketChannel解读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ServerSocketChannel与SocketChannel的open"><span class="nav-number">2.2.1.</span> <span class="nav-text">ServerSocketChannel与SocketChannel的open()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SocketChannel的connect解读"><span class="nav-number">2.2.2.</span> <span class="nav-text">SocketChannel的connect解读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SocketChannelImpl中finishConnect解读"><span class="nav-number">2.2.3.</span> <span class="nav-text">SocketChannelImpl中finishConnect解读</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">知秋</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhiqiuyy"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

  


</body>
</html>
