<!doctype html>



  


<html class="theme-next mist use-motion">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Reactor  响应式 Rxjava  Tomcat NIO">





  <link rel="alternate" href="/atom.xml" title="一叶知秋" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2">






<meta name="description" content="前言此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。 关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下: Rxjava源码解读与分享：https://www.bilibili.com/video/av34537840 Reactor源码解读与分享：https://www.bil">
<meta name="keywords" content="Reactor  响应式 Rxjava  Tomcat NIO">
<meta property="og:type" content="article">
<meta property="og:title" content="BIO到NIO源码的一些事儿之NIO 下 之 Selector">
<meta property="og:url" content="https://muyinchen.github.io/2019/01/12/BIO到NIO源码的一些事儿之NIO 下 之 Selector/index.html">
<meta property="og:site_name" content="一叶知秋">
<meta property="og:description" content="前言此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。 关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下: Rxjava源码解读与分享：https://www.bilibili.com/video/av34537840 Reactor源码解读与分享：https://www.bil">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-12T15:48:02.347Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BIO到NIO源码的一些事儿之NIO 下 之 Selector">
<meta name="twitter:description" content="前言此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。 关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下: Rxjava源码解读与分享：https://www.bilibili.com/video/av34537840 Reactor源码解读与分享：https://www.bil">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://muyinchen.github.io/2019/01/12/BIO到NIO源码的一些事儿之NIO 下 之 Selector/">


  <title> BIO到NIO源码的一些事儿之NIO 下 之 Selector | 一叶知秋 </title>
</head>

<body itemscope="" itemtype="//schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=UA-83014983-1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一叶知秋</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            日程
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                BIO到NIO源码的一些事儿之NIO 下 之 Selector
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-01-12T23:40:25+08:00" content="2019-01-12">
              2019-01-12
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/响应式/" itemprop="url" rel="index">
                    <span itemprop="name">响应式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/01/12/BIO到NIO源码的一些事儿之NIO 下 之 Selector/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/01/12/BIO到NIO源码的一些事儿之NIO 下 之 Selector/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-user"> 本站访客数 </i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>人次
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此系列文章会详细解读NIO的功能逐步丰满的路程，为Reactor-Netty 库的讲解铺平道路。</p>
<p>关于Java编程方法论-Reactor与Webflux的视频分享，已经完成了Rxjava 与 Reactor，b站地址如下:</p>
<p>Rxjava源码解读与分享：<a href="https://www.bilibili.com/video/av34537840" target="_blank" rel="noopener">https://www.bilibili.com/video/av34537840</a></p>
<p>Reactor源码解读与分享：<a href="https://www.bilibili.com/video/av35326911" target="_blank" rel="noopener">https://www.bilibili.com/video/av35326911</a></p>
<p>本系列源码解读基于JDK11 api细节可能与其他版本有所差别，请自行解决jdk版本问题。</p>
<p>本系列前几篇:</p>
<p><a href="https://juejin.im/post/5c2cc075f265da611037298e" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之BIO</a></p>
<p><a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a></p>
<p><a href="https://juejin.im/post/5c34d1dd6fb9a049c84fa2ce" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 中</a></p>
<a id="more"></a>
<h2 id="SelectionKey的引入"><a href="#SelectionKey的引入" class="headerlink" title="SelectionKey的引入"></a>SelectionKey的引入</h2><p>如我们在前面内容所讲，在学生确定之后，我们就要对其状态进行设定，然后再交由<code>Selector</code>进行管理，其状态的设定我们就通过<code>SelectionKey</code>来进行。</p>
<p>那这里我们先通过之前在<code>Channel</code>中并未仔细讲解的<code>SelectableChannel</code>下的<code>register</code>方法。我们前面有提到过， <code>SelectableChannel</code>将<code>channel</code>打造成可以通过<code>Selector</code>来进行多路复用。作为管理者，<code>channel</code>想要实现复用，就必须在管理者这里进行注册登记。所以，<code>SelectableChannel</code>下的<code>register</code>方法也就是我们值得二次关注的核心了，也是对接我们接下来内容的切入点，对于<code>register</code>方法的解读，请看我们之前的文章<a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a> 中<strong>赋予Channel可被多路复用的能力</strong>这一节的内容。</p>
<p>这里要记住的是<code>SelectableChannel</code>是对接<code>channel</code>特征(即<code>SelectionKey</code>)的关键所在，这有点类似于表设计，原本可以将特征什么的设定在一张表内，但为了操作更加具有针对性，即为了让代码功能更易于管理，就进行抽取并设计了第二张表，这个就有点像人体器官，整体上大家共同协作完成一件事，但器官内部自己专注于自己的主要特定功能，偶尔也具备其他器官的一些小功能。</p>
<p>由此，我们也就可以知道，<code>SelectionKey</code>表示一个<code>SelectableChannel</code>与<code>Selector</code>关联的标记，可以简单理解为一个<code>token</code>。就好比是我们做权限管理系统用户登录后前台会从后台拿到的一个<code>token</code>一样，用户可以凭借此<code>token</code>来访问操作相应的资源信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelectableChannel#register</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function"></span>&#123;       ...</span><br><span class="line">    <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">           ...</span><br><span class="line">            SelectionKey k = findKey(sel);</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                k.attach(att);</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// New registration</span></span><br><span class="line">                k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">                addKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结合上下两段源码，在每次<code>Selector</code>使用<code>register</code>方法注册<code>channel</code>时，都会创建并返回一个<code>SelectionKey</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#register</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel ch,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object attachment)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(ch <span class="keyword">instanceof</span> SelChImpl))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalSelectorException();</span><br><span class="line">    SelectionKeyImpl k = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)ch, <span class="keyword">this</span>);</span><br><span class="line">    k.attach(attachment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register (if needed) before adding to key set</span></span><br><span class="line">    implRegister(k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add to the selector's key set, removing it immediately if the selector</span></span><br><span class="line">    <span class="comment">// is closed. The key is not in the channel's key set at this point but</span></span><br><span class="line">    <span class="comment">// it may be observed by a thread iterating over the selector's key set.</span></span><br><span class="line">    keys.add(k);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        k.interestOps(ops);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClosedSelectorException e) &#123;</span><br><span class="line">        <span class="keyword">assert</span> ch.keyFor(<span class="keyword">this</span>) == <span class="keyword">null</span>;</span><br><span class="line">        keys.remove(k);</span><br><span class="line">        k.cancel();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在<a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a> 中<strong>赋予Channel可被多路复用的能力</strong>这一节的内容知道，一旦注册到<code>Selector</code>上，<code>Channel</code>将一直保持注册直到其被解除注册。在解除注册的时候会解除<code>Selector</code>分配给<code>Channel</code>的所有资源。<br>也就是<code>SelectionKey</code>在其调用<code>SelectionKey#channel</code>方法，或这个key所代表的<code>channel</code> 关闭，抑或此key所关联的<code>Selector</code>关闭之前，都是有效。我们在前面的文章分析中也知道，取消一个<code>SelectionKey</code>，不会立刻从<code>Selector</code>移除，它将被添加到<code>Selector</code>的<code>cancelledKeys</code>这个<code>Set</code>集合中，以便在下一次选择操作期间删除，我们可以通过<code>java.nio.channels.SelectionKey#isValid</code>判断一个<code>SelectionKey</code>是否有效。 </p>
<p>SelectionKey包含四个操作集，每个操作集用一个Int来表示，int值中的低四位的bit 用于表示<code>channel</code>支持的可选操作种类。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Operation-set bit for read operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Operation-set bit for write operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Operation-set bit for socket-connect operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Operation-set bit for socket-accept operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="interestOps"><a href="#interestOps" class="headerlink" title="interestOps"></a>interestOps</h3><p>通过<code>interestOps</code>来确定了<code>selector</code>在下一个选择操作的过程中将测试哪些操作类别的准备情况，操作事件是否是<code>channel</code>关注的。<code>interestOps</code> 在<code>SelectionKey</code>创建时，初始化为注册<code>Selector</code>时的ops值，这个值可通过<code>sun.nio.ch.SelectionKeyImpl#interestOps(int)</code>来改变，这点我们在<code>SelectorImpl#register</code>可以清楚的看到。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//sun.nio.ch.SelectionKeyImpl</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionKeyImpl</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSelectionKey</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle INTERESTOPS =</span><br><span class="line">            ConstantBootstraps.fieldVarHandle(</span><br><span class="line">                    MethodHandles.lookup(),</span><br><span class="line">                    <span class="string">"interestOps"</span>,</span><br><span class="line">                    VarHandle.class,</span><br><span class="line">                    SelectionKeyImpl.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelChImpl channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectorImpl selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> interestOps;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> readyOps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// registered events in kernel, used by some Selector implementations</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> registeredEvents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index of key in pollfd array, used by some Selector implementations</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    SelectionKeyImpl(SelChImpl ch, SelectorImpl sel) &#123;</span><br><span class="line">        channel = ch;</span><br><span class="line">        selector = sel;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="readyOps"><a href="#readyOps" class="headerlink" title="readyOps"></a>readyOps</h3><p><code>readyOps</code>表示通过<code>Selector</code>检测到<code>channel</code>已经准备就绪的操作事件。在<code>SelectionKey</code>创建时（即上面源码所示），<code>readyOps</code>值为0，在<code>Selector</code>的<code>select</code>操作中可能会更新，但是需要注意的是我们不能直接调用来更新。</p>
<p><code>SelectionKey</code>的<code>readyOps</code>表示一个<code>channel</code>已经为某些操作准备就绪，但不能保证在针对这个就绪事件类型的操作过程中不会发生阻塞，即该操作所在线程有可能会发生阻塞。在完成<code>select</code>操作后，大部分情况下会立即对<code>readyOps</code>更新，此时<code>readyOps</code>值最准确，如果外部的事件或在该<code>channel</code>有IO操作，<code>readyOps</code>可能不准确。所以，我们有看到其是<code>volatile</code>类型。</p>
<p><code>SelectionKey</code>定义了所有的操作事件，但是具体<code>channel</code>支持的操作事件依赖于具体的<code>channel</code>，即具体问题具体分析。<br>所有可选择的<code>channel</code>（即<code>SelectableChannel</code>的子类）都可以通过<code>SelectableChannel#validOps</code>方法，判断一个操作事件是否被<code>channel</code>所支持，即每个子类都会有对<code>validOps</code>的实现，返回一个数字，仅标识<code>channel</code>支持的哪些操作。尝试设置或测试一个不被<code>channel</code>所支持的操作设定，将会抛出相关的运行时异常。<br>不同应用场景下，其所支持的<code>Ops</code>是不同的，摘取部分如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.SocketChannel#validOps</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//即1|4|8  1101</span></span><br><span class="line">    <span class="keyword">return</span> (SelectionKey.OP_READ</span><br><span class="line">            | SelectionKey.OP_WRITE</span><br><span class="line">            | SelectionKey.OP_CONNECT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.channels.ServerSocketChannel#validOps</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">return</span> SelectionKey.OP_ACCEPT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.nio.channels.DatagramChannel#validOps</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1|4</span></span><br><span class="line">    <span class="keyword">return</span> (SelectionKey.OP_READ</span><br><span class="line">            | SelectionKey.OP_WRITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果需要经常关联一些我们程序中指定数据到<code>SelectionKey</code>，比如一个我们使用一个object表示上层的一种高级协议的状态，object用于通知实现协议处理器。所以，SelectionKey支持通过<code>attach</code>方法将一个对象附加到<code>SelectionKey</code>的<code>attachment</code>上。<code>attachment</code>可以通过<code>java.nio.channels.SelectionKey#attachment</code>方法进行访问。如果要取消该对象，则可以通过该种方式:<code>selectionKey.attach(null)</code>。</p>
<p>需要注意的是如果附加的对象不再使用，一定要人为清除，如果没有，假如此<code>SelectionKey</code>一直存在，由于此处属于强引用，那么垃圾回收器不会回收该对象，若不清除的话会成内存泄漏。</p>
<p>SelectionKey在由多线程并发使用时，是线程安全的。我们只需要知道，<code>Selector</code>的<code>select</code>操作会一直使用在调用该操作开始时当前的<code>interestOps</code>所设定的值。</p>
<h2 id="Selector探究"><a href="#Selector探究" class="headerlink" title="Selector探究"></a>Selector探究</h2><p>到现在为止，我们已经多多少少接触了<code>Selector</code>，其是一个什么样的角色，想必都很清楚了，那我们就在我们已经接触到的来进一步深入探究<code>Selector</code>的设计运行机制。</p>
<h3 id="Selector的open方法"><a href="#Selector的open方法" class="headerlink" title="Selector的open方法"></a>Selector的open方法</h3><p>从命名上就可以知道 <code>SelectableChannel</code>对象是依靠<code>Selector</code>来实现多路复用的。<br>我们可以通过调用<code>java.nio.channels.Selector#open</code>来创建一个<code>selector</code>对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.Selector#open</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于这个<code>SelectorProvider.provider()</code>，其使用了根据所在系统的默认实现，我这里是windows系统，那么其默认实现为<code>sun.nio.ch.WindowsSelectorProvider</code>，这样，就可以调用基于相应系统的具体实现了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.SelectorProvider#provider</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.DefaultSelectorProvider</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prevent instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectorProvider</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the default SelectorProvider.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.WindowsSelectorProvider();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于windows来讲，selector这里最终会使用<code>sun.nio.ch.WindowsSelectorImpl</code>来做一些核心的逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsSelectorProvider</span> <span class="keyword">extends</span> <span class="title">SelectorProviderImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractSelector <span class="title">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowsSelectorImpl(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，我们需要来看一下<code>WindowsSelectorImpl</code>的构造函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#WindowsSelectorImpl</span></span><br><span class="line">WindowsSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    pollWrapper = <span class="keyword">new</span> PollArrayWrapper(INIT_CAP);</span><br><span class="line">    wakeupPipe = Pipe.open();</span><br><span class="line">    wakeupSourceFd = ((SelChImpl)wakeupPipe.source()).getFDVal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable the Nagle algorithm so that the wakeup is more immediate</span></span><br><span class="line">    SinkChannelImpl sink = (SinkChannelImpl)wakeupPipe.sink();</span><br><span class="line">    (sink.sc).socket().setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">    wakeupSinkFd = ((SelChImpl)sink).getFDVal();</span><br><span class="line"></span><br><span class="line">    pollWrapper.addWakeupSocket(wakeupSourceFd, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们由<code>Pipe.open()</code>就可知道<code>selector</code>会保持打开的状态，直到其调用它的<code>close</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelector#close</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> open = selectorOpen.getAndSet(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!open)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    implCloseSelector();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#implCloseSelector</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">implCloseSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    wakeup();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        implClose();</span><br><span class="line">        <span class="keyword">synchronized</span> (publicSelectedKeys) &#123;</span><br><span class="line">            <span class="comment">// Deregister channels</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; i = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                SelectionKeyImpl ski = (SelectionKeyImpl)i.next();</span><br><span class="line">                deregister(ski);</span><br><span class="line">                SelectableChannel selch = ski.channel();</span><br><span class="line">                <span class="keyword">if</span> (!selch.isOpen() &amp;&amp; !selch.isRegistered())</span><br><span class="line">                    ((SelChImpl)selch).kill();</span><br><span class="line">                selectedKeys.remove(ski);</span><br><span class="line">                i.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> selectedKeys.isEmpty() &amp;&amp; keys.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#implClose</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implClose</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> !isOpen();</span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prevent further wakeup</span></span><br><span class="line">    <span class="keyword">synchronized</span> (interruptLock) &#123;</span><br><span class="line">        interruptTriggered = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wakeupPipe.sink().close();</span><br><span class="line">    wakeupPipe.source().close();</span><br><span class="line">    pollWrapper.free();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make all remaining helper threads exit</span></span><br><span class="line">    <span class="keyword">for</span> (SelectThread t: threads)</span><br><span class="line">            t.makeZombie();</span><br><span class="line">    startLock.startThreads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，前面的<code>wakeupPipe</code>在close方法中关闭掉了。这里的close方法中又涉及了<code>wakeupPipe.sink()</code>与<code>wakeupPipe.source()</code>的关闭与<code>pollWrapper.free()</code>的释放，此处也是我们本篇的难点所在，这里，我们来看看它们到底是什么样的存在。<br>首先，我们对<code>WindowsSelectorImpl(SelectorProvider sp)</code>这个构造函数做下梳理:</p>
<ul>
<li>创建一个<code>PollArrayWrapper</code>对象（<code>pollWrapper</code>）；</li>
<li><code>Pipe.open()</code>打开一个管道；</li>
<li>拿到<code>wakeupSourceFd</code>和<code>wakeupSinkFd</code>两个文件描述符；</li>
<li>把pipe内Source端的文件描述符（<code>wakeupSourceFd</code>）放到<code>pollWrapper</code>里；<h4 id="Pipe-open-的解惑"><a href="#Pipe-open-的解惑" class="headerlink" title="Pipe.open()的解惑"></a>Pipe.open()的解惑</h4>这里我们会有疑惑，为什么要创建一个管道，它是用来做什么的。</li>
</ul>
<p>我们来看<code>Pipe.open()</code>源码实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.Pipe#open</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pipe <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openPipe();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorProviderImpl#openPipe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pipe <span class="title">openPipe</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PipeImpl(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.PipeImpl#PipeImpl</span></span><br><span class="line">PipeImpl(<span class="keyword">final</span> SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> Initializer(sp));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PrivilegedActionException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException)x.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Initializer</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">PrivilegedExceptionAction</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider sp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IOException ioe = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Initializer</span><span class="params">(SelectorProvider sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sp = sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    LoopbackConnector connector = <span class="keyword">new</span> LoopbackConnector();</span><br><span class="line">    connector.run();</span><br><span class="line">    <span class="keyword">if</span> (ioe <span class="keyword">instanceof</span> ClosedByInterruptException) &#123;</span><br><span class="line">        ioe = <span class="keyword">null</span>;</span><br><span class="line">        Thread connThread = <span class="keyword">new</span> Thread(connector) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        connThread.start();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connThread.join();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioe != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unable to establish loopback connection"</span>, ioe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述源码我们可以知道，创建了一个<code>PipeImpl</code>对象， 在<code>PipeImpl</code>的构造函数里会执行<code>AccessController.doPrivileged</code>，在它调用后紧接着会执行<code>Initializer</code>的<code>run</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.PipeImpl.Initializer.LoopbackConnector</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopbackConnector</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = <span class="keyword">null</span>;</span><br><span class="line">        SocketChannel sc1 = <span class="keyword">null</span>;</span><br><span class="line">        SocketChannel sc2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Create secret with a backing array.</span></span><br><span class="line">            ByteBuffer secret = ByteBuffer.allocate(NUM_SECRET_BYTES);</span><br><span class="line">            ByteBuffer bb = ByteBuffer.allocate(NUM_SECRET_BYTES);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Loopback address</span></span><br><span class="line">            InetAddress lb = InetAddress.getLoopbackAddress();</span><br><span class="line">            <span class="keyword">assert</span>(lb.isLoopbackAddress());</span><br><span class="line">            InetSocketAddress sa = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                <span class="comment">// Bind ServerSocketChannel to a port on the loopback</span></span><br><span class="line">                <span class="comment">// address</span></span><br><span class="line">                <span class="keyword">if</span> (ssc == <span class="keyword">null</span> || !ssc.isOpen()) &#123;</span><br><span class="line">                    ssc = ServerSocketChannel.open();</span><br><span class="line">                    ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(lb, <span class="number">0</span>));</span><br><span class="line">                    sa = <span class="keyword">new</span> InetSocketAddress(lb, ssc.socket().getLocalPort());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Establish connection (assume connections are eagerly</span></span><br><span class="line">                <span class="comment">// accepted)</span></span><br><span class="line">                sc1 = SocketChannel.open(sa);</span><br><span class="line">                RANDOM_NUMBER_GENERATOR.nextBytes(secret.array());</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    sc1.write(secret);</span><br><span class="line">                &#125; <span class="keyword">while</span> (secret.hasRemaining());</span><br><span class="line">                secret.rewind();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get a connection and verify it is legitimate</span></span><br><span class="line">                sc2 = ssc.accept();</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    sc2.read(bb);</span><br><span class="line">                &#125; <span class="keyword">while</span> (bb.hasRemaining());</span><br><span class="line">                bb.rewind();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bb.equals(secret))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                sc2.close();</span><br><span class="line">                sc1.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create source and sink channels</span></span><br><span class="line">            source = <span class="keyword">new</span> SourceChannelImpl(sp, sc1);</span><br><span class="line">            sink = <span class="keyword">new</span> SinkChannelImpl(sp, sc2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc1 != <span class="keyword">null</span>)</span><br><span class="line">                    sc1.close();</span><br><span class="line">                <span class="keyword">if</span> (sc2 != <span class="keyword">null</span>)</span><br><span class="line">                    sc2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;&#125;</span><br><span class="line">            ioe = e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ssc != <span class="keyword">null</span>)</span><br><span class="line">                    ssc.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里即为创建<code>pipe</code>的过程，<code>windows</code>下的实现是创建两个本地的<code>socketChannel</code>，然后连接（连接的过程通过写一个随机数据做两个socket的连接校验），两个<code>socketChannel</code>分别实现了管道<code>pipe</code>的<code>source</code>与<code>sink</code>端。<br>而我们依然不清楚这个<code>pipe</code>到底干什么用的，<br>假如大家熟悉系统调用的<code>C/C++</code>的话，就可以知道，一个阻塞在<code>select</code>上的线程有以下三种方式可以被唤醒：</p>
<ol>
<li>有数据可读/写，或出现异常。</li>
<li>阻塞时间到，即<code>time out</code>。</li>
<li>收到一个<code>non-block</code>的信号。可由<code>kill</code>或<code>pthread_kill</code>发出。</li>
</ol>
<p>所以，<code>Selector.wakeup()</code>要唤醒阻塞的<code>select</code>，那么也只能通过这三种方法，其中：</p>
<ul>
<li>第二种方法可以排除，因为<code>select</code>一旦阻塞，无法修改其<code>time out</code>时间。</li>
<li>而第三种看来只能在<code>Linux</code>上实现，<code>Windows</code>上没有这种信号通知的机制。</li>
</ul>
<p>看来只有第一种方法了。假如我们多次调用<code>Selector.open()</code>，那么在<code>Windows</code>上会每调用一次，就会建立一对自己和自己的<code>loopback</code>的<code>TCP</code>连接；在Linux上的话，每调用一次，会开一对<code>pipe</code>（pipe在Linux下一般都成对打开），到这里，估计我们能够猜得出来——那就是如果想要唤醒<code>select</code>，只需要朝着自己的这个<code>loopback</code>连接发点数据过去，于是，就可以唤醒阻塞在<code>select</code>上的线程了。</p>
<p>我们对上面所述做下总结:在<code>Windows</code>下，<code>Java</code>虚拟机在<code>Selector.open()</code>时会自己和自己建立<code>loopback</code>的<code>TCP</code>连接；在<code>Linux</code>下，<code>Selector</code>会创建<code>pipe</code>。这主要是为了<code>Selector.wakeup()</code>可以方便唤醒阻塞在<code>select()</code>系统调用上的线程（通过向自己所建立的<code>TCP</code>链接和管道上随便写点什么就可以唤醒阻塞线程）。</p>
<h3 id="PollArrayWrapper解读"><a href="#PollArrayWrapper解读" class="headerlink" title="PollArrayWrapper解读"></a>PollArrayWrapper解读</h3><p>在<code>WindowsSelectorImpl</code>构造器最后，我们看到这一句代码:<code>pollWrapper.addWakeupSocket(wakeupSourceFd, 0);</code>，即把pipe内Source端的文件描述符（<code>wakeupSourceFd</code>）放到<code>pollWrapper</code>里。<code>pollWrapper</code>作为<code>PollArrayWrapper</code>的实例，它到底是什么，这一节，我们就来对其探索一番。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PollArrayWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AllocatedNativeObject pollArray; <span class="comment">// The fd array</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> pollArrayAddress; <span class="comment">// pollArrayAddress</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> FD_OFFSET     = <span class="number">0</span>; <span class="comment">// fd offset in pollfd</span></span><br><span class="line">    <span class="meta">@Native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> EVENT_OFFSET  = <span class="number">4</span>; <span class="comment">// events offset in pollfd</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">short</span> SIZE_POLLFD = <span class="number">8</span>; <span class="comment">// sizeof pollfd struct</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// Size of the pollArray</span></span><br><span class="line"></span><br><span class="line">    PollArrayWrapper(<span class="keyword">int</span> newSize) &#123;</span><br><span class="line">        <span class="keyword">int</span> allocationSize = newSize * SIZE_POLLFD;</span><br><span class="line">        pollArray = <span class="keyword">new</span> AllocatedNativeObject(allocationSize, <span class="keyword">true</span>);</span><br><span class="line">        pollArrayAddress = pollArray.address();</span><br><span class="line">        <span class="keyword">this</span>.size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access methods for fd structures</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putDescriptor</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">        pollArray.putInt(SIZE_POLLFD * i + FD_OFFSET, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putEventOps</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">        pollArray.putShort(SIZE_POLLFD * i + EVENT_OFFSET, (<span class="keyword">short</span>)event);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">// Adds Windows wakeup socket at a given index.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWakeupSocket</span><span class="params">(<span class="keyword">int</span> fdVal, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        putDescriptor(index, fdVal);</span><br><span class="line">        putEventOps(index, Net.POLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里将<code>wakeupSourceFd</code>的<code>POLLIN</code>事件标识为<code>pollArray</code>的<code>EventOps</code>的对应的值，这里使用的是unsafe直接操作的内存，也就是相对于这个<code>pollArray</code>所在内存地址的偏移量<code>SIZE_POLLFD * i + EVENT_OFFSET</code>这个位置上写入<code>Net.POLLIN</code>所代表的值，即参考下面本地方法相关源码所展示的值。<code>putDescriptor</code>同样是这种类似操作。当<code>sink端</code>有数据写入时，<code>source</code>对应的文件描述符<code>wakeupSourceFd</code>就会处于就绪状态。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.base/windows/native/libnio/ch/nio_util.h</span></span><br><span class="line">    <span class="comment">/* WSAPoll()/WSAPOLLFD and the corresponding constants are only defined   */</span></span><br><span class="line">    <span class="comment">/* in Windows Vista / Windows Server 2008 and later. If we are on an      */</span></span><br><span class="line">    <span class="comment">/* older release we just use the Solaris constants as this was previously */</span></span><br><span class="line">    <span class="comment">/* done in PollArrayWrapper.java.                                         */</span></span><br><span class="line">    #define POLLIN       0x0001</span><br><span class="line">    #define POLLOUT      0x0004</span><br><span class="line">    #define POLLERR      0x0008</span><br><span class="line">    #define POLLHUP      0x0010</span><br><span class="line">    #define POLLNVAL     0x0020</span><br><span class="line">    #define POLLCONN     0x0002</span><br></pre></td></tr></table></figure></p>
<p><code>AllocatedNativeObject</code>这个类的父类有大量的<code>unsafe</code>类的操作，这些都是直接基于内存级别的操作。从其父类的构造器中，我们能也清楚的看到<code>pollArray</code>是通过<code>unsafe.allocateMemory(size + ps)</code>分配的一块系统内存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllocatedNativeObject</span>                             // <span class="title">package</span>-<span class="title">private</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">NativeObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allocates a memory area of at least &#123;<span class="doctag">@code</span> size&#125; bytes outside of the</span></span><br><span class="line"><span class="comment">     * Java heap and creates a native object for that area.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AllocatedNativeObject(<span class="keyword">int</span> size, <span class="keyword">boolean</span> pageAligned) &#123;</span><br><span class="line">        <span class="keyword">super</span>(size, pageAligned);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Frees the native memory area associated with this object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (allocationAddress != <span class="number">0</span>) &#123;</span><br><span class="line">            unsafe.freeMemory(allocationAddress);</span><br><span class="line">            allocationAddress = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.NativeObject#NativeObject(int, boolean)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">NativeObject</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">boolean</span> pageAligned)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pageAligned) &#123;</span><br><span class="line">            <span class="keyword">this</span>.allocationAddress = unsafe.allocateMemory(size);</span><br><span class="line">            <span class="keyword">this</span>.address = <span class="keyword">this</span>.allocationAddress;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ps = pageSize();</span><br><span class="line">            <span class="keyword">long</span> a = unsafe.allocateMemory(size + ps);</span><br><span class="line">            <span class="keyword">this</span>.allocationAddress = a;</span><br><span class="line">            <span class="keyword">this</span>.address = a + ps - (a &amp; (ps - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，我们算是完成了对<code>Selector.open()</code>的解读，其主要任务就是完成建立<code>Pipe</code>，并把<code>pipe</code> <code>source</code>端的<code>wakeupSourceFd</code>放入<code>pollArray</code>中，这个<code>pollArray</code>是<code>Selector</code>完成其角色任务的枢纽。本篇主要围绕Windows的实现来进行分析，即在windows下通过两个连接的<code>socketChannel</code>实现了<code>Pipe</code>，<code>linux</code>下则直接使用系统的<code>pipe</code>即可。</p>
<h3 id="SelectionKey在selector中的管理"><a href="#SelectionKey在selector中的管理" class="headerlink" title="SelectionKey在selector中的管理"></a>SelectionKey在selector中的管理</h3><h4 id="SelectionKey在selector中注册"><a href="#SelectionKey在selector中注册" class="headerlink" title="SelectionKey在selector中注册"></a>SelectionKey在selector中注册</h4><p>所谓的注册，其实就是将一个对象放到注册地对象内的一个容器字段上，这个字段可以是数组，队列，也可以是一个set集合，也可以是一个list。这里，同样是这样，只不过，其需要有个返回值，那么把这个要放入集合的对象返回即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#register</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel ch,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object attachment)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(ch <span class="keyword">instanceof</span> SelChImpl))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalSelectorException();</span><br><span class="line">    SelectionKeyImpl k = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)ch, <span class="keyword">this</span>);</span><br><span class="line">    k.attach(attachment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register (if needed) before adding to key set</span></span><br><span class="line">    implRegister(k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add to the selector's key set, removing it immediately if the selector</span></span><br><span class="line">    <span class="comment">// is closed. The key is not in the channel's key set at this point but</span></span><br><span class="line">    <span class="comment">// it may be observed by a thread iterating over the selector's key set.</span></span><br><span class="line">    keys.add(k);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        k.interestOps(ops);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClosedSelectorException e) &#123;</span><br><span class="line">        <span class="keyword">assert</span> ch.keyFor(<span class="keyword">this</span>) == <span class="keyword">null</span>;</span><br><span class="line">        keys.remove(k);</span><br><span class="line">        k.cancel();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#implRegister</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">synchronized</span> (updateLock) &#123;</span><br><span class="line">        newKeys.addLast(ski);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码我们之前已经有看过，这里我们再次温习下。<br>首先会新建一个<code>SelectionKeyImpl</code>对象，这个对象就是对<code>Channel</code>的包装，不仅如此，还顺带把当前这个<code>Selector</code>对象给收了进去，这样，我们也可以通过<code>SelectionKey</code>的对象来拿到其对应的<code>Selector</code>对象。</p>
<p>接着，基于<code>windows</code>平台实现的<code>implRegister</code>，先通过<code>ensureOpen()</code>来确保该<code>Selector</code>是打开的。接着将这个<code>SelectionKeyImpl</code>加入到<code>WindowsSelectorImpl</code>内针对于<strong>新注册</strong>SelectionKey进行管理的<code>newKeys</code>之中，<code>newKeys</code>是一个<code>ArrayDeque</code>对象。对于<code>ArrayDeque</code>有不懂的，可以参考<a href="https://github.com/muyinchen/woker/blob/master/JAVA8/jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Java%20%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20Deque%20%E4%B8%8E%20ArrayDeque.md" target="_blank" rel="noopener">Java 容器源码分析之 Deque 与 ArrayDeque</a>这篇文章。</p>
<p>然后再将此这个<code>SelectionKeyImpl</code>加入到<code>sun.nio.ch.SelectorImpl#keys</code>中去，这个<code>Set&lt;SelectionKey&gt;</code>集合代表那些已经注册到当前这个<code>Selector</code>对象上的<code>SelectionKey</code>集合。我们来看<code>sun.nio.ch.SelectorImpl</code>的构造函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#SelectorImpl</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    keys = ConcurrentHashMap.newKeySet();</span><br><span class="line">    selectedKeys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    publicKeys = Collections.unmodifiableSet(keys);</span><br><span class="line">    publicSelectedKeys = Util.ungrowableSet(selectedKeys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，这里的<code>publicKeys</code>就来源于<code>keys</code>，只是<code>publicKeys</code>属于只读的，我们想要知道当前<code>Selector</code>对象上所注册的<code>keys</code>，就可以调用<code>sun.nio.ch.SelectorImpl#keys</code>来得到:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#keys</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">return</span> publicKeys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再回到这个构造函数中，<code>selectedKeys</code>，顾名思义，其属于已选择Keys，即前一次操作期间，已经准备就绪的<code>Channel</code>所对应的<code>SelectionKey</code>。此集合为<code>keys</code>的子集。通过<code>selector.selectedKeys()</code>获取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#selectedKeys</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; <span class="title">selectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">return</span> publicSelectedKeys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到其返回的是<code>publicSelectedKeys</code>，针对这个字段里的元素操作可以做删除，但不能做增加。<br>在前面的内容中，我们有涉及到<code>SelectionKey</code>的取消，所以，我们在<code>java.nio.channels.spi.AbstractSelector</code>方法内，是有定义<code>cancelledKeys</code>的，也是一个<code>HashSet</code>对象。其代表已经被取消但尚未取消注册(deregister)的<code>SelectionKey</code>。此Set集合无法直接访问，同样，它也是keys()的子集。</p>
<p>对于新的<code>Selector</code>实例，上面几个集合均为空。由上面展示的源码可知，通过<code>channel.register</code>将<code>SelectionKey</code>添加<code>keys</code>中，此为key的来源。<br>如果某个<code>selectionKey.cancel()</code>被调用,那么此key将会被添加到<code>cancelledKeys</code>这个集合中，然后在下一次调用selector <code>select</code>方法期间，此时<code>canceldKeys</code>不为空，将会触发此<code>SelectionKey</code>的<code>deregister</code>操作(释放资源,并从<code>keys</code>中移除)。无论通过<code>channel.close()</code>还是通过<code>selectionKey.cancel()</code>，都会导致<code>SelectionKey</code>被加入到<code>cannceldKey</code>中.</p>
<p>每次选择操作(select)期间，都可以将key添加到<code>selectedKeys</code>中或者将从<code>cancelledKeys</code>中移除。</p>
<h4 id="Selector的select方法的解读"><a href="#Selector的select方法的解读" class="headerlink" title="Selector的select方法的解读"></a>Selector的select方法的解读</h4><p>了解了上面的这些，我们来进入到<code>select</code>方法中，观察下它的细节。由<code>Selector</code>的api可知，<code>select</code>操作有两种形式，一种为<br>select(),selectNow(),select(long timeout);另一种为<code>select(Consumer&lt;SelectionKey&gt; action, long timeout)</code>，<code>select(Consumer&lt;SelectionKey&gt; action)</code>，<code>selectNow(Consumer&lt;SelectionKey&gt; action)</code>。后者为JDK11新加入的api，主要针对那些准备好进行I/O操作的channels在select过程中对相应的key进行的一个字的自定义的一个操作。<br>需要注意的是，有<code>Consumer&lt;SelectionKey&gt; action</code>参数的select操作是阻塞的，只有在选择了至少一个Channel的情况下，才会调用此<code>Selector</code>实例的<code>wakeup</code>方法来唤醒，同样，其所在线程被打断也可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative timeout"</span>);</span><br><span class="line">    <span class="keyword">return</span> lockAndDoSelect(<span class="keyword">null</span>, (timeout == <span class="number">0</span>) ? -<span class="number">1</span> : timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(Consumer&lt;SelectionKey&gt; action, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative timeout"</span>);</span><br><span class="line">    <span class="keyword">return</span> lockAndDoSelect(action, (timeout == <span class="number">0</span>) ? -<span class="number">1</span> : timeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#lockAndDoSelect</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockAndDoSelect</span><span class="params">(Consumer&lt;SelectionKey&gt; action, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">if</span> (inSelect)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"select in progress"</span>);</span><br><span class="line">            inSelect = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (publicSelectedKeys) &#123;</span><br><span class="line">                    <span class="keyword">return</span> doSelect(action, timeout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                inSelect = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以观察，无论哪种，它们最后都落在了<code>lockAndDoSelect</code>这个方法上，最终会执行特定系统上的<code>doSelect(action, timeout)</code>实现。<br>这里我们以<code>sun.nio.ch.WindowsSelectorImpl#doSelect</code>为例来讲述其操作执行的步骤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.nio.ch.WindowsSelectorImpl#doSelect</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(Consumer&lt;SelectionKey&gt; action, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout; <span class="comment">// set selector timeout</span></span><br><span class="line">        processUpdateQueue();  <span class="comment">// &lt;1&gt;</span></span><br><span class="line">        processDeregisterQueue(); <span class="comment">// &lt;2&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (interruptTriggered) &#123;</span><br><span class="line">            resetWakeupSocket();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Calculate number of helper threads needed for poll. If necessary</span></span><br><span class="line">        <span class="comment">// threads are created here and start waiting on startLock</span></span><br><span class="line">        adjustThreadsCount();</span><br><span class="line">        finishLock.reset(); <span class="comment">// reset finishLock</span></span><br><span class="line">        <span class="comment">// Wakeup helper threads, waiting on startLock, so they start polling.</span></span><br><span class="line">        <span class="comment">// Redundant threads will exit here after wakeup.</span></span><br><span class="line">        startLock.startThreads();</span><br><span class="line">        <span class="comment">// do polling in the main thread. Main thread is responsible for</span></span><br><span class="line">        <span class="comment">// first MAX_SELECTABLE_FDS entries in pollArray.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                subSelector.poll();  <span class="comment">// &lt;3&gt;</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                finishLock.setException(e); <span class="comment">// Save this exception</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Main thread is out of poll(). Wakeup others and wait for them</span></span><br><span class="line">            <span class="keyword">if</span> (threads.size() &gt; <span class="number">0</span>)</span><br><span class="line">                finishLock.waitForHelperThreads();</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              end();</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// Done with poll(). Set wakeupSocket to nonsignaled  for the next run.</span></span><br><span class="line">        finishLock.checkForException();</span><br><span class="line">        processDeregisterQueue();  <span class="comment">// &lt;4&gt;</span></span><br><span class="line">        <span class="keyword">int</span> updated = updateSelectedKeys(action); <span class="comment">// &lt;5&gt;</span></span><br><span class="line">        <span class="comment">// Done with poll(). Set wakeupSocket to nonsignaled  for the next run.</span></span><br><span class="line">        resetWakeupSocket(); <span class="comment">// &lt;6&gt;</span></span><br><span class="line">        <span class="keyword">return</span> updated;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="processUpdateQueue解读"><a href="#processUpdateQueue解读" class="headerlink" title="processUpdateQueue解读"></a>processUpdateQueue解读</h4><ol>
<li><p>首先通过相应操作系统实现类（此处是WindowsSelectorImpl）的具体实现我们可以知道，通过<code>&lt;1&gt;</code> 处的 <code>processUpdateQueue()</code>获得关于每个剩余<code>Channel</code>（有些Channel取消了）的在此刻的<code>interestOps</code>，这里包括新注册的和<code>updateKeys</code>，并对其进行<code>pollWrapper</code>的管理操作。</p>
<blockquote>
<ul>
<li><p>即对于新注册的<code>SelectionKeyImpl</code>，我们在相对于这个<code>pollArray</code>所在内存地址的偏移量<code>SIZE_POLLFD * totalChannels + FD_OFFSET</code>与<code>SIZE_POLLFD * totalChannels + EVENT_OFFSET</code>分别存入<code>SelectionKeyImpl</code>的文件描述符<code>fd</code>与其对应的<code>EventOps</code>（初始为0）。</p>
</li>
<li><p>对<code>updateKeys</code>，因为是其之前已经在<code>pollArray</code>的某个相对位置上存储过，这里我们还需要对拿到的key的有效性进行判断，如果有效，只需要将正在操作的这个<code>SelectionKeyImpl</code>对象的<code>interestOps</code>写入到在<code>pollWrapper</code>中的存放它的<code>EventOps</code>位置上。</p>
</li>
</ul>
<p><strong>注意</strong>: 在对<code>newKeys</code>进行key的有效性判断之后，如果有效，会调用<code>growIfNeeded()</code>方法，这里首先会判断<code>channelArray.length == totalChannels</code>，此为一个<code>SelectionKeyImpl</code>的数组，初始容量大小为8。<code>channelArray</code>其实就是方便<code>Selector</code>管理在册<code>SelectionKeyImpl</code>数量的一个数组而已，通过判断它的数组长度大小，如果和<code>totalChannels</code>(初始值为1)相等，不仅仅是为了<code>channelArray</code>扩容，更重要的是为了辅助<code>pollWrapper</code>，让<code>pollWrapper</code>扩容才是这里的目的所在。<br>而当<code>totalChannels % MAX_SELECTABLE_FDS == 0</code>时，则多开一个线程处理<code>selector</code>。<code>windows</code>上<code>select</code>系统调用有最大文件描述符限制，一次只能轮询<code>1024</code>个文件描述符，如果多于1024个，需要多线程进行轮询。通过<code>ski.setIndex(totalChannels)</code>选择键记录下在数组中的索引位置<code>SelectionKeyImpl</code>选择键的映射关系，以待后续使用。同时调用<code>pollWrapper.addWakeupSocket(wakeupSourceFd, totalChannels)</code>在相对于这个<code>pollArray</code>所在内存地址的偏移量<code>SIZE_POLLFD * totalChannels + FD_OFFSET</code>这个位置上写入<code>wakeupSourceFd</code>所代表的<code>fdVal</code>值。这样在新起的线程就可以通过<code>MAX_SELECTABLE_FDS</code>来确定这个用来监控的<code>wakeupSourceFd</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * sun.nio.ch.WindowsSelectorImpl#processUpdateQueue</span></span><br><span class="line"><span class="comment">    * Process new registrations and changes to the interest ops.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processUpdateQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (updateLock) &#123;</span><br><span class="line">        SelectionKeyImpl ski;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new registrations</span></span><br><span class="line">        <span class="keyword">while</span> ((ski = newKeys.pollFirst()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ski.isValid()) &#123;</span><br><span class="line">                growIfNeeded();</span><br><span class="line">                channelArray[totalChannels] = ski;</span><br><span class="line">                ski.setIndex(totalChannels);</span><br><span class="line">                pollWrapper.putEntry(totalChannels, ski);</span><br><span class="line">                totalChannels++;</span><br><span class="line">                MapEntry previous = fdMap.put(ski);</span><br><span class="line">                <span class="keyword">assert</span> previous == <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// changes to interest ops</span></span><br><span class="line">        <span class="keyword">while</span> ((ski = updateKeys.pollFirst()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> events = ski.translateInterestOps();</span><br><span class="line">            <span class="keyword">int</span> fd = ski.getFDVal();</span><br><span class="line">            <span class="keyword">if</span> (ski.isValid() &amp;&amp; fdMap.containsKey(fd)) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = ski.getIndex();</span><br><span class="line">                <span class="keyword">assert</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; totalChannels;</span><br><span class="line">                pollWrapper.putEventOps(index, events);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.PollArrayWrapper#putEntry</span></span><br><span class="line"><span class="comment">// Prepare another pollfd struct for use.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putEntry</span><span class="params">(<span class="keyword">int</span> index, SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">    putDescriptor(index, ski.getFDVal());</span><br><span class="line">    putEventOps(index, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#growIfNeeded</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">growIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channelArray.length == totalChannels) &#123;</span><br><span class="line">        <span class="keyword">int</span> newSize = totalChannels * <span class="number">2</span>; <span class="comment">// Make a larger array</span></span><br><span class="line">        SelectionKeyImpl temp[] = <span class="keyword">new</span> SelectionKeyImpl[newSize];</span><br><span class="line">        System.arraycopy(channelArray, <span class="number">1</span>, temp, <span class="number">1</span>, totalChannels - <span class="number">1</span>);</span><br><span class="line">        channelArray = temp;</span><br><span class="line">        pollWrapper.grow(newSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totalChannels % MAX_SELECTABLE_FDS == <span class="number">0</span>) &#123; <span class="comment">// more threads needed</span></span><br><span class="line">        pollWrapper.addWakeupSocket(wakeupSourceFd, totalChannels);</span><br><span class="line">        totalChannels++;</span><br><span class="line">        threadsCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Initial capacity of the poll array</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_CAP = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// Maximum number of sockets for select().</span></span><br><span class="line"><span class="comment">// Should be INIT_CAP times a power of 2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SELECTABLE_FDS = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The list of SelectableChannels serviced by this Selector. Every mod</span></span><br><span class="line"><span class="comment">// MAX_SELECTABLE_FDS entry is bogus, to align this array with the poll</span></span><br><span class="line"><span class="comment">// array,  where the corresponding entry is occupied by the wakeupSocket</span></span><br><span class="line"><span class="keyword">private</span> SelectionKeyImpl[] channelArray = <span class="keyword">new</span> SelectionKeyImpl[INIT_CAP];</span><br><span class="line"><span class="comment">// The number of valid entries in  poll array, including entries occupied</span></span><br><span class="line"><span class="comment">// by wakeup socket handle.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> totalChannels = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.PollArrayWrapper#grow</span></span><br><span class="line"><span class="comment">// Grows the pollfd array to new size</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">    PollArrayWrapper temp = <span class="keyword">new</span> PollArrayWrapper(newSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        replaceEntry(<span class="keyword">this</span>, i, temp, i);</span><br><span class="line">    pollArray.free();</span><br><span class="line">    pollArray = temp.pollArray;</span><br><span class="line">    <span class="keyword">this</span>.size = temp.size;</span><br><span class="line">    pollArrayAddress = pollArray.address();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Maps file descriptors to their indices in  pollArray</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FdMap</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Integer</span>, <span class="title">MapEntry</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapEntry <span class="title">get</span><span class="params">(<span class="keyword">int</span> desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(Integer.valueOf(desc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapEntry <span class="title">put</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> put(Integer.valueOf(ski.getFDVal()), <span class="keyword">new</span> MapEntry(ski));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapEntry <span class="title">remove</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">        Integer fd = Integer.valueOf(ski.getFDVal());</span><br><span class="line">        MapEntry x = get(fd);</span><br><span class="line">        <span class="keyword">if</span> ((x != <span class="keyword">null</span>) &amp;&amp; (x.ski.channel() == ski.channel()))</span><br><span class="line">            <span class="keyword">return</span> remove(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class for fdMap entries</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SelectionKeyImpl ski;</span><br><span class="line">    <span class="keyword">long</span> updateCount = <span class="number">0</span>;</span><br><span class="line">    MapEntry(SelectionKeyImpl ski) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ski = ski;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FdMap fdMap = <span class="keyword">new</span> FdMap();</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h5 id="processDeregisterQueue解读"><a href="#processDeregisterQueue解读" class="headerlink" title="processDeregisterQueue解读"></a>processDeregisterQueue解读</h5><ol>
<li>接着通过<code>上面WindowsSelectorImpl#doSelect展示源码中&lt;2&gt;</code> 处的 <code>processDeregisterQueue()</code>。<ul>
<li>对<code>cancelledKeys</code>进行清除，遍历<code>cancelledKeys</code>，并对每个<code>key</code>进行<code>deregister</code>操作，然后从<code>cancelledKeys</code>集合中删除，从<code>keys</code>集合与<code>selectedKeys</code>中删除，以此来释放引用，方便gc回收，</li>
<li>其内调用<code>implDereg</code>方法，将会从<code>channelArray</code>中移除对应的<code>Channel</code>代表的<code>SelectionKeyImpl</code>，调整<code>totalChannels</code>和线程数，从<code>map</code>和<code>keys</code>中移除<code>SelectionKeyImpl</code>，移除<code>Channel</code>上的<code>SelectionKeyImpl</code>并关闭<code>Channel</code>。</li>
<li>同时还发现该<code>processDeregisterQueue()</code>方法在调用<code>poll</code>方法前后都进行调用，这是确保能够正确处理在调用<code>poll</code>方法阻塞的这一段时间之内取消的键能被及时清理。</li>
<li>最后，还会判断这个<code>cancelledKey</code>所代表的<code>channel</code>是否打开和解除注册，如果关闭并解除注册，则应该将相应的文件描述符对应占用的资源给关闭掉。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * sun.nio.ch.SelectorImpl#processDeregisterQueue</span></span><br><span class="line"><span class="comment">    * Invoked by selection operations to process the cancelled-key set</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processDeregisterQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(publicSelectedKeys);</span><br><span class="line"></span><br><span class="line">    Set&lt;SelectionKey&gt; cks = cancelledKeys();</span><br><span class="line">    <span class="keyword">synchronized</span> (cks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cks.isEmpty()) &#123;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; i = cks.iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                SelectionKeyImpl ski = (SelectionKeyImpl)i.next();</span><br><span class="line">                i.remove();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// remove the key from the selector</span></span><br><span class="line">                implDereg(ski);</span><br><span class="line"></span><br><span class="line">                selectedKeys.remove(ski);</span><br><span class="line">                keys.remove(ski);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// remove from channel's key set</span></span><br><span class="line">                deregister(ski);</span><br><span class="line"></span><br><span class="line">                SelectableChannel ch = ski.channel();</span><br><span class="line">                <span class="keyword">if</span> (!ch.isOpen() &amp;&amp; !ch.isRegistered())</span><br><span class="line">                    ((SelChImpl)ch).kill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#implDereg</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implDereg</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> !ski.isValid();</span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fdMap.remove(ski) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ski.getIndex();</span><br><span class="line">        <span class="keyword">assert</span> (i &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i != totalChannels - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Copy end one over it</span></span><br><span class="line">            SelectionKeyImpl endChannel = channelArray[totalChannels-<span class="number">1</span>];</span><br><span class="line">            channelArray[i] = endChannel;</span><br><span class="line">            endChannel.setIndex(i);</span><br><span class="line">            pollWrapper.replaceEntry(pollWrapper, totalChannels-<span class="number">1</span>, pollWrapper, i);</span><br><span class="line">        &#125;</span><br><span class="line">        ski.setIndex(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        channelArray[totalChannels - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        totalChannels--;</span><br><span class="line">        <span class="keyword">if</span> (totalChannels != <span class="number">1</span> &amp;&amp; totalChannels % MAX_SELECTABLE_FDS == <span class="number">1</span>) &#123;</span><br><span class="line">            totalChannels--;</span><br><span class="line">            threadsCount--; <span class="comment">// The last thread has become redundant.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.SocketChannelImpl#kill</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == ST_KILLPENDING) &#123;</span><br><span class="line">            state = ST_KILLED;</span><br><span class="line">            nd.close(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C:/Program Files/Java/jdk-11.0.1/lib/src.zip!/java.base/sun/nio/ch/SocketChannelImpl.java:1126</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    IOUtil.load();</span><br><span class="line">    nd = <span class="keyword">new</span> SocketDispatcher();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SocketDispatcher#close</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    close0(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h5 id="adjustThreadsCount解读"><a href="#adjustThreadsCount解读" class="headerlink" title="adjustThreadsCount解读"></a>adjustThreadsCount解读</h5><ol>
<li>接着我们来看到<code>上面WindowsSelectorImpl#doSelect</code>展示源码中<code>adjustThreadsCount()</code>方法的调用。<ul>
<li>前面有提到如果<code>totalChannels % MAX_SELECTABLE_FDS == 0</code>，则多开一个线程处理<code>selector</code>。这里就是根据<strong>分配的线程数量值</strong>来增加或减少线程，其实就是针对操作系统的最大<code>select</code>操作的文件描述符限制对线程个数进行调整。</li>
<li>我们来观察所建线程做了什么事情，即观察<code>SelectThread</code>的<code>run</code>方法实现。通过观察其源码可以看到它首先是<code>while (true)</code>，通过<code>startLock.waitForStart(this)</code>来控制该线程是否运行还是等待，运行状态的话，会进而调用<code>subSelector.poll(index)</code>（这个我们后面内容详细解读），</li>
<li>当此线程<code>poll</code>结束，而且相对于当前主线程假如有多条<code>SelectThread</code>子线程的话，当前这条<code>SelectThread</code>线程第一个结束<code>poll</code>的话，就调用<code>finishLock.threadFinished()</code>来通知主线程。在刚新建这个线程并调用其<code>run</code>方法的时候，此时<code>lastRun = 0</code>，在第一次启动的时候<code>sun.nio.ch.WindowsSelectorImpl.StartLock#runsCounter</code>同样为0，所以会调用<code>startLock.wait()</code>进而进入等待状态。 </li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><code>sun.nio.ch.WindowsSelectorImpl.StartLock</code>同样会判断当前其所检测的线程是否废弃，废弃的话就返回<code>true</code>，这样被检测线程也就能跳出其内run方法的<code>while</code>循环从而结束线程运行。</li>
<li>在调整线程的时候（调用<code>adjustThreadsCount</code>方法）与<code>Selector</code>调用<code>close</code>方法会间接调用到<code>sun.nio.ch.WindowsSelectorImpl#implClose</code>，这两个方法都会涉及到<code>Selector</code>线程的释放，即调用<code>sun.nio.ch.WindowsSelectorImpl.SelectThread#makeZombie</code>。</li>
<li><code>finishLock.threadFinished()</code>会调用<code>wakeup()</code>方法来通知主线程，这里，我们可以学到一个细节，如果线程正阻塞在<code>select</code>方法上，就可以调用<code>wakeup</code>方法会使阻塞的选择操作立即返回，通过<code>Windows</code>的相关实现，原理其实是向<code>pipe</code>的<code>sink</code>端写入了一个字节，<code>source</code>文件描述符就会处于就绪状态，<code>poll</code>方法会返回，从而导致<code>select</code>方法返回。而在其他solaris或者linux系统上其实采用系统调用<code>pipe</code>来完成管道的创建，相当于直接用了系统的管道。通过<code>wakeup()</code>相关实现还可以看出，调用<code>wakeup</code>会设置<code>interruptTriggered</code>的标志位，所以连续多次调用<code>wakeup</code>的效果等同于一次调用，不会引起无所谓的bug出现。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#adjustThreadsCount</span></span><br><span class="line"><span class="comment">// After some channels registered/deregistered, the number of required</span></span><br><span class="line"><span class="comment">// helper threads may have changed. Adjust this number.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustThreadsCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadsCount &gt; threads.size()) &#123;</span><br><span class="line">        <span class="comment">// More threads needed. Start more threads.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = threads.size(); i &lt; threadsCount; i++) &#123;</span><br><span class="line">            SelectThread newThread = <span class="keyword">new</span> SelectThread(i);</span><br><span class="line">            threads.add(newThread);</span><br><span class="line">            newThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            newThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threadsCount &lt; threads.size()) &#123;</span><br><span class="line">        <span class="comment">// Some threads become redundant. Remove them from the threads List.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = threads.size() - <span class="number">1</span> ; i &gt;= threadsCount; i--)</span><br><span class="line">            threads.remove(i).makeZombie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl.SelectThread</span></span><br><span class="line"><span class="comment">// Represents a helper thread used for select.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index; <span class="comment">// index of this thread</span></span><br><span class="line">    <span class="keyword">final</span> SubSelector subSelector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastRun = <span class="number">0</span>; <span class="comment">// last run number</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> zombie;</span><br><span class="line">    <span class="comment">// Creates a new thread</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SelectThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"SelectorHelper"</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.index = i;</span><br><span class="line">        <span class="keyword">this</span>.subSelector = <span class="keyword">new</span> SubSelector(i);</span><br><span class="line">        <span class="comment">//make sure we wait for next round of poll</span></span><br><span class="line">        <span class="keyword">this</span>.lastRun = startLock.runsCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeZombie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        zombie = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isZombie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zombie;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// poll loop</span></span><br><span class="line">            <span class="comment">// wait for the start of poll. If this thread has become</span></span><br><span class="line">            <span class="comment">// redundant, then exit.</span></span><br><span class="line">            <span class="keyword">if</span> (startLock.waitForStart(<span class="keyword">this</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// call poll()</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                subSelector.poll(index);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Save this exception and let other threads finish.</span></span><br><span class="line">                finishLock.setException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// notify main thread, that this thread has finished, and</span></span><br><span class="line">            <span class="comment">// wakeup others, if this thread is the first to finish.</span></span><br><span class="line">            finishLock.threadFinished();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sun.nio.ch.WindowsSelectorImpl.FinishLock#threadFinished</span></span><br><span class="line"><span class="comment">// Each helper thread invokes this function on finishLock, when</span></span><br><span class="line"><span class="comment">// the thread is done with poll().</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">threadFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadsToFinish == threads.size()) &#123; <span class="comment">// finished poll() first</span></span><br><span class="line">        <span class="comment">// if finished first, wakeup others</span></span><br><span class="line">        wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">    threadsToFinish--;</span><br><span class="line">    <span class="keyword">if</span> (threadsToFinish == <span class="number">0</span>) <span class="comment">// all helper threads finished poll().</span></span><br><span class="line">        notify();             <span class="comment">// notify the main thread</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#wakeup</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Selector <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (interruptLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!interruptTriggered) &#123;</span><br><span class="line">            setWakeupSocket();</span><br><span class="line">            interruptTriggered = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#setWakeupSocket</span></span><br><span class="line"><span class="comment">// Sets Windows wakeup socket to a signaled state.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setWakeupSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setWakeupSocket0(wakeupSinkFd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setWakeupSocket0</span><span class="params">(<span class="keyword">int</span> wakeupSinkFd)</span></span>;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_sun_nio_ch_WindowsSelectorImpl_setWakeupSocket0(JNIEnv *env, jclass <span class="keyword">this</span>,</span><br><span class="line">                                                jint scoutFd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Write one byte into the pipe */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> <span class="keyword">byte</span> = <span class="number">1</span>;</span><br><span class="line">    send(scoutFd, &amp;<span class="keyword">byte</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="subSelector的poll方法解读"><a href="#subSelector的poll方法解读" class="headerlink" title="subSelector的poll方法解读"></a>subSelector的poll方法解读</h5><ol>
<li><code>subSelector.poll()</code> 是select的核心，由<code>native</code>函数<code>poll0</code>实现，并把<code>pollWrapper.pollArrayAddress</code>作为参数传给<code>poll0</code>，<code>readFds</code>、<code>writeFds</code> 和<code>exceptFds</code>数组用来保存底层<code>select</code>的结果，数组的第一个位置都是存放发生事件的<code>socket</code>的总数，其余位置存放发生事件的<code>socket</code>句柄<code>fd</code>。<br> 我们通过下面的代码可知:<br> 这个<code>poll0()</code>会监听<code>pollWrapper</code>中的<code>FD</code>有没有数据进出，这里会造成<code>IO</code>阻塞，直到有数据读写事件发生。由于<code>pollWrapper</code>中保存的也有<code>ServerSocketChannel</code>的<code>FD</code>，所以只要<code>ClientSocket</code>发一份数据到<code>ServerSocket</code>,那么<code>poll0()</code>就会返回；又由于<code>pollWrapper</code>中保存的也有<code>pipe</code>的<code>write</code>端的<code>FD</code>，所以只要<code>pipe</code>的<code>write</code>端向<code>FD</code>发一份数据，也会造成<code>poll0()</code>返回；如果这两种情况都没有发生，那么<code>poll0()</code>就一直阻塞，也就是<code>selector.select()</code>会一直阻塞；如果有任何一种情况发生，那么<code>selector.select()</code>就会返回，所有在<code>SelectThread</code>的<code>run()</code>里要用<code>while (true) {}</code>，这样就可以保证在<code>selector</code>接收到数据并处理完后继续监听<code>poll()</code>;</li>
</ol>
<blockquote>
<p>可以看出，NIO依然是阻塞式的IO，那么它和BIO的区别究竟在哪呢。<br>其实它的区别在于阻塞的位置不同，<code>BIO</code>是阻塞在<code>read</code>方法(recvfrom)，而<code>NIO</code>阻塞在<code>select</code>方法。那么这样做有什么好处呢。如果单纯的改变阻塞的位置，自然是没有什么变化的，但<code>epoll等</code>的实现的巧妙之处就在于，它利用回调机制，让监听能够只需要知晓哪些<code>socket</code>上的数据已经准备好了，只需要处理这些线程上面的数据就行了。采用<code>BIO</code>，假设有<code>1000</code>个连接，需要开<code>1000</code>个线程，然后有<code>1000</code>个<code>read</code>的位置在阻塞(我们在讲解BIO部分已经通过Demo体现)，采用<code>NIO</code>编程，只需要<strong>1</strong>个线程，它利用<code>select</code>的轮询策略配合<code>epoll</code>的事件机制及红黑树数据结构，降低了其内部轮询的开销，同时极大的减小了线程上下文切换的开销。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl.SubSelector</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSelector</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pollArrayIndex; <span class="comment">// starting index in pollArray to poll</span></span><br><span class="line">        <span class="comment">// These arrays will hold result of native select().</span></span><br><span class="line">        <span class="comment">// The first element of each array is the number of selected sockets.</span></span><br><span class="line">        <span class="comment">// Other elements are file descriptors of selected sockets.</span></span><br><span class="line">        <span class="comment">// 保存发生read的FD</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] readFds = <span class="keyword">new</span> <span class="keyword">int</span> [MAX_SELECTABLE_FDS + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 保存发生write的FD</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] writeFds = <span class="keyword">new</span> <span class="keyword">int</span> [MAX_SELECTABLE_FDS + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//保存发生except的FD</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] exceptFds = <span class="keyword">new</span> <span class="keyword">int</span> [MAX_SELECTABLE_FDS + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SubSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.pollArrayIndex = <span class="number">0</span>; <span class="comment">// main thread</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SubSelector</span><span class="params">(<span class="keyword">int</span> threadIndex)</span> </span>&#123; <span class="comment">// helper threads</span></span><br><span class="line">            <span class="keyword">this</span>.pollArrayIndex = (threadIndex + <span class="number">1</span>) * MAX_SELECTABLE_FDS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123; <span class="comment">// poll for the main thread</span></span><br><span class="line">            <span class="keyword">return</span> poll0(pollWrapper.pollArrayAddress,</span><br><span class="line">                         Math.min(totalChannels, MAX_SELECTABLE_FDS),</span><br><span class="line">                         readFds, writeFds, exceptFds, timeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">// poll for helper threads</span></span><br><span class="line">            <span class="keyword">return</span>  poll0(pollWrapper.pollArrayAddress +</span><br><span class="line">                     (pollArrayIndex * PollArrayWrapper.SIZE_POLLFD),</span><br><span class="line">                     Math.min(MAX_SELECTABLE_FDS,</span><br><span class="line">                             totalChannels - (index + <span class="number">1</span>) * MAX_SELECTABLE_FDS),</span><br><span class="line">                     readFds, writeFds, exceptFds, timeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">poll0</span><span class="params">(<span class="keyword">long</span> pollAddress, <span class="keyword">int</span> numfds,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span>[] readFds, <span class="keyword">int</span>[] writeFds, <span class="keyword">int</span>[] exceptFds, <span class="keyword">long</span> timeout)</span></span>;</span><br><span class="line">             ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="updateSelectedKeys解读"><a href="#updateSelectedKeys解读" class="headerlink" title="updateSelectedKeys解读"></a>updateSelectedKeys解读</h5><ol>
<li>接下来将通过<code>上面WindowsSelectorImpl#doSelect展示源码中&lt;5&gt;</code> 处的 <code>updateSelectedKeys(action)</code>来处理每个<code>channel</code>的 <strong>准备就绪</strong>的信息。<ul>
<li>如果该通道的<code>key</code>尚未在<code>selectedKeys</code>中存在，则将其添加到该集合中。</li>
<li>如果该通道的<code>key</code>已经存在<code>selectedKeys</code>中，即这个<code>channel</code>存在所支持的<code>ReadyOps</code>就绪操作中必须包含一个这种操作(由<code>(ski.nioReadyOps() &amp; ski.nioInterestOps()) != 0</code>来确定)，此时修改其<code>ReadyOps</code>为当前所要进行的操作。而我们之前看到的<code>Consumer&lt;SelectionKey&gt;</code>这个动作也是在此处进行。而由下面源码可知，先前记录在<code>ReadyOps</code>中的任何就绪信息在调用此<code>action</code>之前被丢弃掉，直接进行设定。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl#updateSelectedKeys</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">updateSelectedKeys</span><span class="params">(Consumer&lt;SelectionKey&gt; action)</span> </span>&#123;</span><br><span class="line">    updateCount++;</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = <span class="number">0</span>;</span><br><span class="line">    numKeysUpdated += subSelector.processSelectedKeys(updateCount, action);</span><br><span class="line">    <span class="keyword">for</span> (SelectThread t: threads) &#123;</span><br><span class="line">        numKeysUpdated += t.subSelector.processSelectedKeys(updateCount, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.SelectorImpl#processReadyEvents</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">processReadyEvents</span><span class="params">(<span class="keyword">int</span> rOps,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        SelectionKeyImpl ski,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Consumer&lt;SelectionKey&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ski.translateAndSetReadyOps(rOps);</span><br><span class="line">        <span class="keyword">if</span> ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != <span class="number">0</span>) &#123;</span><br><span class="line">            action.accept(ski);</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(publicSelectedKeys);</span><br><span class="line">        <span class="keyword">if</span> (selectedKeys.contains(ski)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ski.translateAndUpdateReadyOps(rOps)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ski.translateAndSetReadyOps(rOps);</span><br><span class="line">            <span class="keyword">if</span> ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != <span class="number">0</span>) &#123;</span><br><span class="line">                selectedKeys.add(ski);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.WindowsSelectorImpl.SubSelector#processSelectedKeys</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processSelectedKeys</span><span class="params">(<span class="keyword">long</span> updateCount, Consumer&lt;SelectionKey&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = <span class="number">0</span>;</span><br><span class="line">    numKeysUpdated += processFDSet(updateCount, action, readFds,</span><br><span class="line">                                    Net.POLLIN,</span><br><span class="line">                                    <span class="keyword">false</span>);</span><br><span class="line">    numKeysUpdated += processFDSet(updateCount, action, writeFds,</span><br><span class="line">                                    Net.POLLCONN |</span><br><span class="line">                                    Net.POLLOUT,</span><br><span class="line">                                    <span class="keyword">false</span>);</span><br><span class="line">    numKeysUpdated += processFDSet(updateCount, action, exceptFds,</span><br><span class="line">                                    Net.POLLIN |</span><br><span class="line">                                    Net.POLLCONN |</span><br><span class="line">                                    Net.POLLOUT,</span><br><span class="line">                                    <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * sun.nio.ch.WindowsSelectorImpl.SubSelector#processFDSet</span></span><br><span class="line"><span class="comment">    * updateCount is used to tell if a key has been counted as updated</span></span><br><span class="line"><span class="comment">    * in this select operation.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * me.updateCount &lt;= updateCount</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processFDSet</span><span class="params">(<span class="keyword">long</span> updateCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Consumer&lt;SelectionKey&gt; action,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span>[] fds, <span class="keyword">int</span> rOps,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> isExceptFds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= fds[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> desc = fds[i];</span><br><span class="line">        <span class="keyword">if</span> (desc == wakeupSourceFd) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (interruptLock) &#123;</span><br><span class="line">                interruptTriggered = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MapEntry me = fdMap.get(desc);</span><br><span class="line">        <span class="comment">// If me is null, the key was deregistered in the previous</span></span><br><span class="line">        <span class="comment">// processDeregisterQueue.</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        SelectionKeyImpl sk = me.ski;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The descriptor may be in the exceptfds set because there is</span></span><br><span class="line">        <span class="comment">// OOB data queued to the socket. If there is OOB data then it</span></span><br><span class="line">        <span class="comment">// is discarded and the key is not added to the selected set.</span></span><br><span class="line">        <span class="keyword">if</span> (isExceptFds &amp;&amp;</span><br><span class="line">            (sk.channel() <span class="keyword">instanceof</span> SocketChannelImpl) &amp;&amp;</span><br><span class="line">            discardUrgentData(desc))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//我们应该关注的</span></span><br><span class="line">        <span class="keyword">int</span> updated = processReadyEvents(rOps, sk, action);</span><br><span class="line">        <span class="keyword">if</span> (updated &gt; <span class="number">0</span> &amp;&amp; me.updateCount != updateCount) &#123;</span><br><span class="line">            me.updateCount = updateCount;</span><br><span class="line">            numKeysUpdated++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>至此，关于Selector的内容就暂时告一段落，在下一篇中，我会针对Java NIO Buffer进行相关解读。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://og0sybnix.bkt.clouddn.com/wechat-qcode.png" alt="知秋 WeChat Pay">
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Reactor-Rxjava-NIO/" rel="tag">#Reactor Rxjava  NIO</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/09/BIO到NIO源码的一些事儿之NIO 中/" rel="next" title="BIO到NIO源码的一些事儿之NIO 中">
                <i class="fa fa-chevron-left"></i> BIO到NIO源码的一些事儿之NIO 中
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2019/01/12/BIO到NIO源码的一些事儿之NIO 下 之 Selector/" data-title="BIO到NIO源码的一些事儿之NIO 下 之 Selector" data-url="https://muyinchen.github.io/2019/01/12/BIO到NIO源码的一些事儿之NIO 下 之 Selector/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://og0sybnix.bkt.clouddn.com/18213496.jpg" alt="知秋">
          <p class="site-author-name" itemprop="name">知秋</p>
          <p class="site-description motion-element" itemprop="description">只记空山，只念新雨</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">99</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/lsgqjh" title="小舒哥" target="_blank">小舒哥</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SelectionKey的引入"><span class="nav-number">2.</span> <span class="nav-text">SelectionKey的引入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#interestOps"><span class="nav-number">2.1.</span> <span class="nav-text">interestOps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readyOps"><span class="nav-number">2.2.</span> <span class="nav-text">readyOps</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Selector探究"><span class="nav-number">3.</span> <span class="nav-text">Selector探究</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Selector的open方法"><span class="nav-number">3.1.</span> <span class="nav-text">Selector的open方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Pipe-open-的解惑"><span class="nav-number">3.1.1.</span> <span class="nav-text">Pipe.open()的解惑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PollArrayWrapper解读"><span class="nav-number">3.2.</span> <span class="nav-text">PollArrayWrapper解读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SelectionKey在selector中的管理"><span class="nav-number">3.3.</span> <span class="nav-text">SelectionKey在selector中的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SelectionKey在selector中注册"><span class="nav-number">3.3.1.</span> <span class="nav-text">SelectionKey在selector中注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Selector的select方法的解读"><span class="nav-number">3.3.2.</span> <span class="nav-text">Selector的select方法的解读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#processUpdateQueue解读"><span class="nav-number">3.3.3.</span> <span class="nav-text">processUpdateQueue解读</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#processDeregisterQueue解读"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">processDeregisterQueue解读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#adjustThreadsCount解读"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">adjustThreadsCount解读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#subSelector的poll方法解读"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">subSelector的poll方法解读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#updateSelectedKeys解读"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">updateSelectedKeys解读</span></a></li></ol></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">知秋</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhiqiuyy"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

  


</body>
</html>
